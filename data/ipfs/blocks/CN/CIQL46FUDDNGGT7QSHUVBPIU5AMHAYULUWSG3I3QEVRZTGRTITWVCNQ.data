.subarray(0,zK),n=e.subarray(zK,e.length);return new ij(t,n)}const t=(e=lj(e,zK)).subarray(0,zK),n=e.subarray(ZK);return new ij(t,n)}function sj(e){return e=lj(e,ZK),new rj(e)}async function aj(){const{privateKey:e,publicKey:t}=await async function(){const e=ql.utils.randomPrivateKey(),t=ql.getPublicKey(e);return{privateKey:HK(e,t),publicKey:t}}();return new ij(e,t)}async function cj(e){const{privateKey:t,publicKey:n}=await async function(e){if(e.length!==VK)throw new TypeError('"seed" must be 32 bytes in length.');if(!(e instanceof Uint8Array))throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');const t=e,n=ql.getPublicKey(t);return{privateKey:HK(t,n),publicKey:n}}(e);return new ij(t,n)}function lj(e,t){var n;if((e=Uint8Array.from(null!==(n=e)&&void 0!==n?n:[])).length!==t)throw new QF("Key must be a Uint8Array of length ".concat(t,", got ").concat(e.length),"ERR_INVALID_KEY_TYPE");return e}function uj(e,t){let n=Uint8Array.from(e.abs().toByteArray());if(n=0===n[0]?n.subarray(1):n,null!=t){if(n.length>t)throw new Error("byte array longer than desired length");n=(0,Ls.z)([new Uint8Array(t-n.length),n])}return(0,Au.B)(n,"base64url")}function hj(e){const t=function(e,t){let n=(0,yu.m)(e,"base64urlpad");if(null!=t){if(n.length>t)throw new Error("byte array longer than desired length");n=(0,Ls.z)([new Uint8Array(t-n.length),n])}return n}(e);return new(gu().jsbn.BigInteger)((0,Au.B)(t,"base16"),16)}const dj={"P-256":256,"P-384":384,"P-521":521};Object.keys(dj).join(" / ");function fj(e,t){return t.map((t=>hj(e[t])))}async function pj(e){const t=[await YK.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["sign"]),await yj(e)],n=await gj({privateKey:t[0],publicKey:t[1]});return{privateKey:n[0],publicKey:n[1]}}async function gj(e){if(null==e.privateKey||null==e.publicKey)throw new QF("Private and public key are required","ERR_INVALID_PARAMETERS");return Promise.all([YK.get().subtle.exportKey("jwk",e.privateKey),YK.get().subtle.exportKey("jwk",e.publicKey)])}async function yj(e){return YK.get().subtle.importKey("jwk",{kty:e.kty,n:e.n,e:e.e},{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["verify"])}function mj(e,t,n,r){const i=t?function(e){return gu().pki.setRsaPublicKey(...fj(e,["n","e"]))}(e):function(e){return gu().pki.setRsaPrivateKey(...fj(e,["n","e","d","p","q","dp","dq","qi"]))}(e),o=r((0,Au.B)(Uint8Array.from(n),"ascii"),i);return(0,yu.m)(o,"ascii")}function vj(e){if("RSA"!==e.kty)throw new QF("invalid key type","ERR_INVALID_KEY_TYPE");if(null==e.n)throw new QF("invalid key modulus","ERR_INVALID_KEY_MODULUS");return 8*(0,yu.m)(e.n,"base64url").length}const bj=8192;class wj{constructor(e){(0,Yo.Z)(this,"_key",void 0),this._key=e}async verify(e,t){return async function(e,t,n){const r=await YK.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);return YK.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},r,t,n)}(this._key,t,e)}marshal(){return function(e){if(null==e.n||null==e.e)throw new QF("JWK was missing components","ERR_INVALID_PARAMETERS");const t=gu().pki.publicKeyToAsn1({n:hj(e.n),e:hj(e.e)});return(0,yu.m)(gu().asn1.toDer(t).getBytes(),"ascii")}(this._key)}get bytes(){return tj.encode({Type:$K.RSA,Data:this.marshal()}).subarray()}encrypt(e){return mj(this._key,!0,e,((e,t)=>t.encrypt(e)))}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await KK.digest(this.bytes);return e}}class Ej{constructor(e,t){(0,Yo.Z)(this,"_key",void 0),(0,Yo.Z)(this,"_publicKey",void 0),this._key=e,this._publicKey=t}genSecret(){return function(e){if(isNaN(e)||e<=0)throw new QF("random bytes length must be a Number bigger than 0","ERR_INVALID_LENGTH");return _c(e)}(16)}async sign(e){return async function(e,t){const n=await YK.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["sign"]),r=await YK.get().subtle.sign({name:"RSASSA-PKCS1-v1_5"},n,Uint8Array.from(t));return new Uint8Array(r,0,r.byteLength)}(this._key,e)}get public(){if(null==this._publicKey)throw new QF("public key not provided","ERR_PUBKEY_NOT_PROVIDED");return new wj(this._publicKey)}decrypt(e){return mj(this._key,!1,e,((e,t)=>t.decrypt(e)))}marshal(){return function(e){if(null==e.n||null==e.e||null==e.d||null==e.p||null==e.q||null==e.dp||null==e.dq||null==e.qi)throw new QF("JWK was missing components","ERR_INVALID_PARAMETERS");const t=gu().pki.privateKeyToAsn1({n:hj(e.n),e:hj(e.e),d:hj(e.d),p:hj(e.p),q:hj(e.q),dP:hj(e.dp),dQ:hj(e.dq),qInv:hj(e.qi)});return(0,yu.m)(gu().asn1.toDer(t).getBytes(),"ascii")}(this._key)}get bytes(){return nj.encode({Type:$K.RSA,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await KK.digest(this.bytes);return e}async id(){const e=await this.public.hash();return(0,Au.B)(e,"base58btc")}async export(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"pkcs-8";if("pkcs-8"===t){const t=new(gu().util.ByteBuffer)(this.marshal()),n=gu().asn1.fromDer(t),r=gu().pki.privateKeyFromAsn1(n),i={algorithm:"aes256",count:1e4,saltSize:16,prfAlgorithm:"sha512"};return gu().pki.encryptRsaPrivateKey(r,e,i)}if("libp2p-key"===t)return XK(this.bytes,e);throw new QF("export format '".concat(t,"' is not supported"),"ERR_INVALID_EXPORT_FORMAT")}}async function Aj(e){const t=function(e){const t=gu().asn1.fromDer((0,Au.B)(e,"ascii")),n=gu().pki.privateKeyFromAsn1(t);return{kty:"RSA",n:uj(n.n),e:uj(n.e),d:uj(n.d),p:uj(n.p),q:uj(n.q),dp:uj(n.dP),dq:uj(n.dQ),qi:uj(n.qInv),alg:"RS256"}}(e);if(vj(t)>bj)throw new QF("key size is too large","ERR_KEY_SIZE_TOO_LARGE");const n=await pj(t);return new Ej(n.privateKey,n.publicKey)}function Sj(e){const t=function(e){const t=gu().asn1.fromDer((0,Au.B)(e,"ascii")),n=gu().pki.publicKeyFromAsn1(t);return{kty:"RSA",n:uj(n.n),e:uj(n.e)}}(e);if(vj(t)>bj)throw new QF("key size is too large","ERR_KEY_SIZE_TOO_LARGE");return new wj(t)}async function _j(e){if(vj(e)>bj)throw new QF("key size is too large","ERR_KEY_SIZE_TOO_LARGE");const t=await pj(e);return new Ej(t.privateKey,t.publicKey)}async function Ij(e){if(e>bj)throw new QF("key size is too large","ERR_KEY_SIZE_TOO_LARGE");const t=await async function(e){const t=await YK.get().subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:e,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),n=await gj(t);return{privateKey:n[0],publicKey:n[1]}}(e);return new Ej(t.privateKey,t.publicKey)}function Cj(e){try{Eh.ProjectivePoint.fromHex(e)}catch(t){throw new QF(String(t),"ERR_INVALID_PUBLIC_KEY")}}class Tj{constructor(e){(0,Yo.Z)(this,"_key",void 0),Cj(e),this._key=e}async verify(e,t){return async function(e,t,n){try{const{digest:r}=await KK.digest(n);return Eh.verify(t,r,e)}catch(r){throw new QF(String(r),"ERR_INVALID_INPUT")}}(this._key,t,e)}marshal(){return e=this._key,Eh.ProjectivePoint.fromHex(e).toRawBytes(!0);var e}get bytes(){return tj.encode({Type:$K.Secp256k1,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await KK.digest(this.bytes);return e}}class kj{constructor(e,t){(0,Yo.Z)(this,"_key",void 0),(0,Yo.Z)(this,"_publicKey",void 0),this._key=e,this._publicKey=null!==t&&void 0!==t?t:function(e){try{return Eh.getPublicKey(e,!0)}catch(t){throw new QF(String(t),"ERR_INVALID_PRIVATE_KEY")}}(e),function(e){try{Eh.getPublicKey(e,!0)}catch(t){throw new QF(String(t),"ERR_INVALID_PRIVATE_KEY")}}(this._key),Cj(this._publicKey)}async sign(e){return async function(e,t){const{digest:n}=await KK.digest(t);try{return Eh.sign(n,e).toDERRawBytes()}catch(r){throw new QF(String(r),"ERR_INVALID_INPUT")}}(this._key,e)}get public(){return new Tj(this._publicKey)}marshal(){return this._key}get bytes(){return nj.encode({Type:$K.Secp256k1,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await KK.digest(this.bytes);return e}async id(){const e=await this.public.hash();return(0,Au.B)(e,"base58btc")}async export(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"libp2p-key";if("libp2p-key"===t)return XK(this.bytes,e);throw new QF("export format '".concat(t,"' is not supported"),"ERR_INVALID_EXPORT_FORMAT")}}function Rj(e){return new kj(e)}function xj(e){return new Tj(e)}async function Pj(){const e=Eh.utils.randomPrivateKey();return new kj(e)}const Dj={rsa:kt,ed25519:Tt,secp256k1:Rt};function Oj(e){const t=Object.keys(Dj).join(" / ");return new QF("invalid or unsupported key type ".concat(e,". Must be ").concat(t),"ERR_UNSUPPORTED_KEY_TYPE")}async function Nj(e){var t,n;const r=nj.decode(e),i=null!==(t=r.Data)&&void 0!==t?t:new Uint8Array;switch(r.Type){case $K.RSA:return Dj.rsa.unmarshalRsaPrivateKey(i);case $K.Ed25519:return Dj.ed25519.unmarshalEd25519PrivateKey(i);case $K.Secp256k1:return Dj.secp256k1.unmarshalSecp256k1PrivateKey(i);default:throw Oj(null!==(n=r.Type)&&void 0!==n?n:"RSA")}}const Bj=Symbol.for("@libp2p/peer-id");const Lj=cK({prefix:"9",name:"base10",alphabet:"0123456789"}),Mj=lK({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Uj=lK({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),Fj=lK({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),Kj=Array.from("\ud83d\ude80\ud83e\ude90\u2604\ud83d\udef0\ud83c\udf0c\ud83c\udf11\ud83c\udf12\ud83c\udf13\ud83c\udf14\ud83c\udf15\ud83c\udf16\ud83c\udf17\ud83c\udf18\ud83c\udf0d\ud83c\udf0f\ud83c\udf0e\ud83d\udc09\u2600\ud83d\udcbb\ud83d\udda5\ud83d\udcbe\ud83d\udcbf\ud83d\ude02\u2764\ud83d\ude0d\ud83e\udd23\ud83d\ude0a\ud83d\ude4f\ud83d\udc95\ud83d\ude2d\ud83d\ude18\ud83d\udc4d\ud83d\ude05\ud83d\udc4f\ud83d\ude01\ud83d\udd25\ud83e\udd70\ud83d\udc94\ud83d\udc96\ud83d\udc99\ud83d\ude22\ud83e\udd14\ud83d\ude06\ud83d\ude44\ud83d\udcaa\ud83d\ude09\u263a\ud83d\udc4c\ud83e\udd17\ud83d\udc9c\ud83d\ude14\ud83d\ude0e\ud83d\ude07\ud83c\udf39\ud83e\udd26\ud83c\udf89\ud83d\udc9e\u270c\u2728\ud83e\udd37\ud83d\ude31\ud83d\ude0c\ud83c\udf38\ud83d\ude4c\ud83d\ude0b\ud83d\udc97\ud83d\udc9a\ud83d\ude0f\ud83d\udc9b\ud83d\ude42\ud83d\udc93\ud83e\udd29\ud83d\ude04\ud83d\ude00\ud83d\udda4\ud83d\ude03\ud83d\udcaf\ud83d\ude48\ud83d\udc47\ud83c\udfb6\ud83d\ude12\ud83e\udd2d\u2763\ud83d\ude1c\ud83d\udc8b\ud83d\udc40\ud83d\ude2a\ud83d\ude11\ud83d\udca5\ud83d\ude4b\ud83d\ude1e\ud83d\ude29\ud83d\ude21\ud83e\udd2a\ud83d\udc4a\ud83e\udd73\ud83d\ude25\ud83e\udd24\ud83d\udc49\ud83d\udc83\ud83d\ude33\u270b\ud83d\ude1a\ud83d\ude1d\ud83d\ude34\ud83c\udf1f\ud83d\ude2c\ud83d\ude43\ud83c\udf40\ud83c\udf37\ud83d\ude3b\ud83d\ude13\u2b50\u2705\ud83e\udd7a\ud83c\udf08\ud83d\ude08\ud83e\udd18\ud83d\udca6\u2714\ud83d\ude23\ud83c\udfc3\ud83d\udc90\u2639\ud83c\udf8a\ud83d\udc98\ud83d\ude20\u261d\ud83d\ude15\ud83c\udf3a\ud83c\udf82\ud83c\udf3b\ud83d\ude10\ud83d\udd95\ud83d\udc9d\ud83d\ude4a\ud83d\ude39\ud83d\udde3\ud83d\udcab\ud83d\udc80\ud83d\udc51\ud83c\udfb5\ud83e\udd1e\ud83d\ude1b\ud83d\udd34\ud83d\ude24\ud83c\udf3c\ud83d\ude2b\u26bd\ud83e\udd19\u2615\ud83c\udfc6\ud83e\udd2b\ud83d\udc48\ud83d\ude2e\ud83d\ude46\ud83c\udf7b\ud83c\udf43\ud83d\udc36\ud83d\udc81\ud83d\ude32\ud83c\udf3f\ud83e\udde1\ud83c\udf81\u26a1\ud83c\udf1e\ud83c\udf88\u274c\u270a\ud83d\udc4b\ud83d\ude30\ud83e\udd28\ud83d\ude36\ud83e\udd1d\ud83d\udeb6\ud83d\udcb0\ud83c\udf53\ud83d\udca2\ud83e\udd1f\ud83d\ude41\ud83d\udea8\ud83d\udca8\ud83e\udd2c\u2708\ud83c\udf80\ud83c\udf7a\ud83e\udd13\ud83d\ude19\ud83d\udc9f\ud83c\udf31\ud83d\ude16\ud83d\udc76\ud83e\udd74\u25b6\u27a1\u2753\ud83d\udc8e\ud83d\udcb8\u2b07\ud83d\ude28\ud83c\udf1a\ud83e\udd8b\ud83d\ude37\ud83d\udd7a\u26a0\ud83d\ude45\ud83d\ude1f\ud83d\ude35\ud83d\udc4e\ud83e\udd32\ud83e\udd20\ud83e\udd27\ud83d\udccc\ud83d\udd35\ud83d\udc85\ud83e\uddd0\ud83d\udc3e\ud83c\udf52\ud83d\ude17\ud83e\udd11\ud83c\udf0a\ud83e\udd2f\ud83d\udc37\u260e\ud83d\udca7\ud83d\ude2f\ud83d\udc86\ud83d\udc46\ud83c\udfa4\ud83d\ude47\ud83c\udf51\u2744\ud83c\udf34\ud83d\udca3\ud83d\udc38\ud83d\udc8c\ud83d\udccd\ud83e\udd40\ud83e\udd22\ud83d\udc45\ud83d\udca1\ud83d\udca9\ud83d\udc50\ud83d\udcf8\ud83d\udc7b\ud83e\udd10\ud83e\udd2e\ud83c\udfbc\ud83e\udd75\ud83d\udea9\ud83c\udf4e\ud83c\udf4a\ud83d\udc7c\ud83d\udc8d\ud83d\udce3\ud83e\udd42"),jj=Kj.reduce(((e,t,n)=>(e[n]=t,e)),[]),Zj=Kj.reduce(((e,t,n)=>(e[t.codePointAt(0)]=n,e)),[]);const zj=aK({prefix:"\ud83d\ude80",name:"base256emoji",encode:function(e){return e.reduce(((e,t)=>e+=jj[t]),"")},decode:function(e){const t=[];for(const n of e){const e=Zj[n.codePointAt(0)];if(void 0===e)throw new Error("Non-base256emoji character: ".concat(n));t.push(e)}return new Uint8Array(t)}}),Vj=lK({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Hj=lK({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),qj=lK({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Gj=lK({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Wj=lK({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Qj=lK({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Yj=lK({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Jj=lK({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Xj=lK({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),$j=cK({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),eZ=cK({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),tZ=lK({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),nZ=aK({prefix:"\0",name:"identity",encode:e=>{return t=e,(new TextDecoder).decode(t);var t},decode:e=>(e=>(new TextEncoder).encode(e))(e)}),rZ=new TextEncoder,iZ=new TextDecoder,oZ="json",sZ=512,aZ=e=>rZ.encode(JSON.stringify(e)),cZ=e=>JSON.parse(iZ.decode(e)),lZ="raw",uZ=85,hZ=e=>tK(e),dZ=e=>tK(e),fZ=(e,t)=>{const{bytes:n,version:r}=e;return 0===r?vZ(n,gZ(e),t||uK.encoder):bZ(n,gZ(e),t||Vj.encoder)},pZ=new WeakMap,gZ=e=>{const t=pZ.get(e);if(null==t){const t=new Map;return pZ.set(e,t),t}return t};class yZ{constructor(e,t,n,r){this.code=t,this.version=e,this.multihash=n,this.bytes=r,this["/"]=r}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==wZ)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==EZ)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return yZ.createV0(t)}default:throw Error("Can not convert CID version ".concat(this.version," to version 0. This is a bug please report"))}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=DK(e,t);return yZ.createV1(this.code,n)}case 1:return this;default:throw Error("Can not convert CID version ".concat(this.version," to version 1. This is a bug please report"))}}equals(e){return yZ.equals(this,e)}static equals(e,t){const n=t;return n&&e.code===n.code&&e.version===n.version&&((e,t)=>{if(e===t)return!0;{const n=t;return e.code===n.code&&e.size===n.size&&n.bytes instanceof Uint8Array&&((e,t)=>{if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0})(e.bytes,n.bytes)}})(e.multihash,n.multihash)}toString(e){return fZ(this,e)}toJSON(){return{"/":fZ(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return"CID(".concat(this.toString(),")")}static asCID(e){if(null==e)return null;const t=e;if(t instanceof yZ)return t;if(null!=t["/"]&&t["/"]===t.bytes||t.asCID===t){const{version:e,code:n,multihash:r,bytes:i}=t;return new yZ(e,n,r,i||AZ(e,n,r.bytes))}if(!0===t[SZ]){const{version:e,multihash:n,code:r}=t,i=OK(n);return yZ.create(e,r,i)}return null}static create(e,t,n){if("number"!==typeof t)throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:if(t!==wZ)throw new Error("Version 0 CID must use dag-pb (code: ".concat(wZ,") block encoding"));return new yZ(e,t,n,n.bytes);case 1:{const r=AZ(e,t,n.bytes);return new yZ(e,t,n,r)}default:throw new Error("Invalid version")}}static createV0(e){return yZ.create(0,wZ,e)}static createV1(e,t){return yZ.create(1,e,t)}static decode(e){const[t,n]=yZ.decodeFirst(e);if(n.length)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=yZ.inspectBytes(e),n=t.size-t.multihashSize,r=tK(e.subarray(n,n+t.multihashSize));if(r.byteLength!==t.multihashSize)throw new Error("Incorrect length");const i=r.subarray(t.multihashSize-t.digestSize),o=new NK(t.multihashCode,t.digestSize,i,r);return[0===t.version?yZ.createV0(o):yZ.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[n,r]=RK(e.subarray(t));return t+=r,n};let r=n(),i=wZ;if(18===r?(r=0,t=0):i=n(),0!==r&&1!==r)throw new RangeError("Invalid CID version ".concat(r));const o=t,s=n(),a=n(),c=t+a;return{version:r,codec:i,multihashCode:s,digestSize:a,multihashSize:c-o,size:c}}static parse(e,t){const[n,r]=mZ(e,t),i=yZ.decode(r);if(0===i.version&&"Q"!==e[0])throw Error("Version 0 CID string must not include multibase prefix");return gZ(i).set(n,e),i}}const mZ=(e,t)=>{switch(e[0]){case"Q":{const n=t||uK;return[uK.prefix,n.decode("".concat(uK.prefix).concat(e))]}case uK.prefix:{const n=t||uK;return[uK.prefix,n.decode(e)]}case Vj.prefix:{const n=t||Vj;return[Vj.prefix,n.decode(e)]}default:if(null==t)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}},vZ=(e,t,n)=>{const{prefix:r}=n;if(r!==uK.prefix)throw Error("Cannot string encode V0 in ".concat(n.name," encoding"));const i=t.get(r);if(null==i){const i=n.encode(e).slice(1);return t.set(r,i),i}return i},bZ=(e,t,n)=>{const{prefix:r}=n,i=t.get(r);if(null==i){const i=n.encode(e);return t.set(r,i),i}return i},wZ=112,EZ=18,AZ=(e,t,n)=>{const r=PK(e),i=r+PK(t),o=new Uint8Array(i+n.byteLength);return xK(e,o,0),xK(t,o,r),o.set(n,i),o},SZ=Symbol.for("@ipld/js-cid/CID"),_Z={...Mt,...Dt,...Lt,...xt,...Pt,...Nt,...Bt,...St,...Ct,...Ot},IZ=Symbol.for("nodejs.util.inspect.custom"),CZ=Object.values(_Z).map((e=>e.decoder)).reduce(((e,t)=>e.or(t)),_Z.identity.decoder),TZ=114,kZ=36,RZ=37;class xZ{constructor(e){(0,Yo.Z)(this,"type",void 0),(0,Yo.Z)(this,"multihash",void 0),(0,Yo.Z)(this,"privateKey",void 0),(0,Yo.Z)(this,"publicKey",void 0),(0,Yo.Z)(this,"string",void 0),(0,Yo.Z)(this,Bj,!0),this.type=e.type,this.multihash=e.multihash,this.privateKey=e.privateKey,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return"PeerId(".concat(this.toString(),")")}toString(){return null==this.string&&(this.string=uK.encode(this.multihash.bytes).slice(1)),this.string}toCID(){return yZ.createV1(TZ,this.multihash)}toBytes(){return this.multihash.bytes}toJSON(){return this.toString()}equals(e){var t;if(e instanceof Uint8Array)return(0,Ms.f)(this.multihash.bytes,e);if("string"===typeof e)return function(e,t){var n;if(t=null!==(n=t)&&void 0!==n?n:CZ,"1"===e.charAt(0)||"Q"===e.charAt(0)){const t=OK(uK.decode("z".concat(e)));return e.startsWith("12D")?new DZ({multihash:t}):e.startsWith("16U")?new OZ({multihash:t}):new PZ({multihash:t})}return function(e){try{const t=OK(e);if(t.code===LK.code){if(t.digest.length===kZ)return new DZ({multihash:t});if(t.digest.length===RZ)return new OZ({multihash:t})}if(t.code===KK.code)return new PZ({multihash:t})}catch{return function(e){if(null==e||null==e.multihash||null==e.version||1===e.version&&e.code!==TZ)throw new Error("Supplied PeerID CID is invalid");const t=e.multihash;if(t.code===KK.code)return new PZ({multihash:e.multihash});if(t.code===LK.code){if(t.digest.length===kZ)return new DZ({multihash:e.multihash});if(t.digest.length===RZ)return new OZ({multihash:e.multihash})}throw new Error("Supplied PeerID CID is invalid")}(yZ.decode(e))}throw new Error("Supplied PeerID CID is invalid")}(CZ.decode(e))}(e).equals(this);if(null!=(null===e||void 0===e||null===(t=e.multihash)||void 0===t?void 0:t.bytes))return(0,Ms.f)(this.multihash.bytes,e.multihash.bytes);throw new Error("not valid Id")}[IZ](){return"PeerId(".concat(this.toString(),")")}}class PZ extends xZ{constructor(e){super({...e,type:"RSA"}),(0,Yo.Z)(this,"type","RSA"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.publicKey}}class DZ extends xZ{constructor(e){super({...e,type:"Ed25519"}),(0,Yo.Z)(this,"type","Ed25519"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.multihash.digest}}class OZ extends xZ{constructor(e){super({...e,type:"secp256k1"}),(0,Yo.Z)(this,"type","secp256k1"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.multihash.digest}}async function NZ(e,t){return e.length===kZ?new DZ({multihash:DK(LK.code,e),privateKey:t}):e.length===RZ?new OZ({multihash:DK(LK.code,e),privateKey:t}):new PZ({multihash:await KK.digest(e),publicKey:e,privateKey:t})}var BZ,LZ;async function MZ(e,t,n){const r=await async function(e,t){if(null==e.privateKey)throw new Error("PrivateKey was missing from PeerId");return(await Nj(e.privateKey)).sign(t)}(e,KZ(t));if(null==e.publicKey)throw new Error("PublicKey was missing from local PeerId");return function(e,t,n){return LZ.encode({identityKey:e,identitySig:t,extensions:null!==n&&void 0!==n?n:{webtransportCerthashes:[]}}).subarray()}(e.publicKey,r,n)}async function UZ(e){return NZ(e.identityKey)}function FZ(e){return LZ.decode(e)}function KZ(e){const t=(0,yu.m)("noise-libp2p-static-key:");return(0,Ls.z)([t,e],t.length+e.length)}async function jZ(e,t,n){const r=await NZ(t.identityKey);if(!r.equals(n))throw new Error("Payload identity key ".concat(r.toString()," does not match expected remote peer ").concat(n.toString()));const i=KZ(e);if(null==r.publicKey)throw new Error("PublicKey was missing from PeerId");if(null==t.identitySig)throw new Error("Signature was missing from message");const o=function(e){var t,n;const r=tj.decode(e),i=null!==(t=r.Data)&&void 0!==t?t:new Uint8Array;switch(r.Type){case $K.RSA:return Dj.rsa.unmarshalRsaPublicKey(i);case $K.Ed25519:return Dj.ed25519.unmarshalEd25519PublicKey(i);case $K.Secp256k1:return Dj.secp256k1.unmarshalSecp256k1PublicKey(i);default:throw Oj(null!==(n=r.Type)&&void 0!==n?n:"unknown")}}(r.publicKey);if(!await o.verify(i,t.identitySig))throw new Error("Static key doesn't match to peer that signed payload!");return r}function ZZ(e){return e instanceof Uint8Array&&32===e.length}function zZ(e){let t=function(e){const t=()=>{};return t.enabled=!1,t.color="",t.diff=0,t.log=()=>{},t.namespace=e,t.destroy=()=>!0,t.extend=()=>t,t}("".concat(e,":trace"));return sf().enabled("".concat(e,":trace"))&&null!=sf().names.map((e=>e.toString())).find((e=>e.includes(":trace")))&&(t=sf()("".concat(e,":trace"))),Object.assign(sf()(e),{error:sf()("".concat(e,":error")),trace:t})}!function(e){let t;e.codec=()=>(null==t&&(t=ws((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!1!==n.lengthDelimited&&t.fork(),null!=e.webtransportCerthashes)for(const r of e.webtransportCerthashes)t.uint32(10),t.bytes(r);!1!==n.lengthDelimited&&t.ldelim()}),((e,t)=>{const n={webtransportCerthashes:[]},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();if(t>>>3===1)n.webtransportCerthashes.push(e.bytes());else e.skipType(7&t)}return n}))),t),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(BZ||(BZ={})),function(e){let t;e.codec=()=>(null==t&&(t=ws((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==n.lengthDelimited&&t.fork(),null!=e.identityKey&&e.identityKey.byteLength>0&&(t.uint32(10),t.bytes(e.identityKey)),null!=e.identitySig&&e.identitySig.byteLength>0&&(t.uint32(18),t.bytes(e.identitySig)),null!=e.extensions&&(t.uint32(34),BZ.codec().encode(e.extensions,t)),!1!==n.lengthDelimited&&t.ldelim()}),((e,t)=>{const n={identityKey:(0,Us.u)(0),identitySig:(0,Us.u)(0)},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 1:n.identityKey=e.bytes();break;case 2:n.identitySig=e.bytes();break;case 4:n.extensions=BZ.codec().decode(e,e.uint32());break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(LZ||(LZ={})),sf().formatters.b=e=>null==e?"undefined":uK.baseEncode(e),sf().formatters.t=e=>null==e?"undefined":Vj.baseEncode(e),sf().formatters.m=e=>null==e?"undefined":qK.baseEncode(e),sf().formatters.p=e=>null==e?"undefined":e.toString(),sf().formatters.c=e=>null==e?"undefined":e.toString(),sf().formatters.k=e=>null==e?"undefined":e.toString(),sf().formatters.a=e=>null==e?"undefined":e.toString();const VZ=zZ("libp2p:noise");let HZ;function qZ(e){e?(HZ("LOCAL_PUBLIC_EPHEMERAL_KEY ".concat((0,Au.B)(e.publicKey,"hex"))),HZ("LOCAL_PRIVATE_EPHEMERAL_KEY ".concat((0,Au.B)(e.privateKey,"hex")))):HZ("Missing local ephemeral keys.")}function GZ(e){HZ("REMOTE_EPHEMERAL_PUBLIC_KEY ".concat((0,Au.B)(e,"hex")))}HZ=KF?VZ:Object.assign((()=>{}),{enabled:!1,trace:()=>{},error:()=>{}});class WZ{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;(0,Yo.Z)(this,"n",void 0),(0,Yo.Z)(this,"bytes",void 0),(0,Yo.Z)(this,"view",void 0),this.n=e,this.bytes=(0,Us.u)(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,e,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>4294967295)throw new Error("Cipherstate has reached maximum n, a new handshake must be performed")}}class QZ{constructor(e){(0,Yo.Z)(this,"crypto",void 0),this.crypto=e}encryptWithAd(e,t,n){const r=this.encrypt(e.k,e.n,t,n);return e.n.increment(),r}decryptWithAd(e,t,n,r){const{plaintext:i,valid:o}=this.decrypt(e.k,e.n,t,n,r);return o&&e.n.increment(),{plaintext:i,valid:o}}hasKey(e){return!this.isEmptyKey(e.k)}createEmptyKey(){return(0,Us.u)(32)}isEmptyKey(e){const t=this.createEmptyKey();return(0,Ms.f)(t,e)}encrypt(e,t,n,r){return t.assertValue(),this.crypto.chaCha20Poly1305Encrypt(r,t.getBytes(),n,e)}encryptAndHash(e,t){let n;return n=this.hasKey(e.cs)?this.encryptWithAd(e.cs,e.h,t):t,this.mixHash(e,n),n}decrypt(e,t,n,r,i){t.assertValue();const o=this.crypto.chaCha20Poly1305Decrypt(r,t.getBytes(),n,e,i);return o?{plaintext:o,valid:!0}:{plaintext:(0,Us.u)(0),valid:!1}}decryptAndHash(e,t){let n,r=!0;return this.hasKey(e.cs)?({plaintext:n,valid:r}=this.decryptWithAd(e.cs,e.h,t)):n=t,this.mixHash(e,t),{plaintext:n,valid:r}}dh(e,t){try{const n=this.crypto.generateX25519SharedKey(e,t);return 32===n.length?n:n.subarray(0,32)}catch(n){const e=n;return VZ.error(e),(0,Us.u)(32)}}mixHash(e,t){e.h=this.getHash(e.h,t)}getHash(e,t){return this.crypto.hashSHA256((0,Ls.z)([e,t],e.length+t.length))}mixKey(e,t){const[n,r]=this.crypto.getHKDF(e.ck,t);e.cs=this.initializeKey(r),e.ck=n}initializeKey(e){return{k:e,n:new WZ}}initializeSymmetric(e){const t=(0,Xh.mL)(e,"utf-8"),n=this.hashProtocolName(t),r=n,i=this.createEmptyKey();return{cs:this.initializeKey(i),ck:r,h:n}}hashProtocolName(e){if(e.length<=32){const t=(0,Us.u)(32);return t.set(e),t}return this.getHash(e,(0,Us.u)(0))}split(e){const[t,n]=this.crypto.getHKDF(e.ck,(0,Us.u)(0));return{cs1:this.initializeKey(t),cs2:this.initializeKey(n)}}writeMessageRegular(e,t){const n=this.encryptWithAd(e,(0,Us.u)(0),t);return{ne:this.createEmptyKey(),ns:(0,Us.u)(0),ciphertext:n}}readMessageRegular(e,t){return this.decryptWithAd(e,(0,Us.u)(0),t.ciphertext)}}class YZ extends QZ{initializeInitiator(e,t,n,r){const i=this.initializeSymmetric("Noise_XX_25519_ChaChaPoly_SHA256");this.mixHash(i,e);return{ss:i,s:t,rs:n,psk:r,re:(0,Us.u)(32)}}initializeResponder(e,t,n,r){const i=this.initializeSymmetric("Noise_XX_25519_ChaChaPoly_SHA256");this.mixHash(i,e);return{ss:i,s:t,rs:n,psk:r,re:(0,Us.u)(32)}}writeMessageA(e,t,n){const r=(0,Us.u)(0);e.e=void 0!==n?n:this.crypto.generateX25519KeyPair();const i=e.e.publicKey;this.mixHash(e.ss,i);return{ne:i,ns:r,ciphertext:this.encryptAndHash(e.ss,t)}}writeMessageB(e,t){e.e=this.crypto.generateX25519KeyPair();const n=e.e.publicKey;this.mixHash(e.ss,n),this.mixKey(e.ss,this.dh(e.e.privateKey,e.re));const r=e.s.publicKey,i=this.encryptAndHash(e.ss,r);this.mixKey(e.ss,this.dh(e.s.privateKey,e.re));return{ne:n,ns:i,ciphertext:this.encryptAndHash(e.ss,t)}}writeMessageC(e,t){const n=e.s.publicKey,r=this.encryptAndHash(e.ss,n);this.mixKey(e.ss,this.dh(e.s.privateKey,e.re));const i=this.encryptAndHash(e.ss,t),o={ne:this.createEmptyKey(),ns:r,ciphertext:i},{cs1:s,cs2:a}=this.split(e.ss);return{h:e.ss.h,messageBuffer:o,cs1:s,cs2:a}}readMessageA(e,t){return ZZ(t.ne)&&(e.re=t.ne),this.mixHash(e.ss,e.re),this.decryptAndHash(e.ss,t.ciphertext)}readMessageB(e,t){if(ZZ(t.ne)&&(e.re=t.ne),this.mixHash(e.ss,e.re),!e.e)throw new Error("Handshake state `e` param is missing.");this.mixKey(e.ss,this.dh(e.e.privateKey,e.re));const{plaintext:n,valid:r}=this.decryptAndHash(e.ss,t.ns);r&&ZZ(n)&&(e.rs=n),this.mixKey(e.ss,this.dh(e.e.privateKey,e.rs));const{plaintext:i,valid:o}=this.decryptAndHash(e.ss,t.ciphertext);return{plaintext:i,valid:r&&o}}readMessageC(e,t){const{plaintext:n,valid:r}=this.decryptAndHash(e.ss,t.ns);if(r&&ZZ(n)&&(e.rs=n),!e.e)throw new Error("Handshake state `e` param is missing.");this.mixKey(e.ss,this.dh(e.e.privateKey,e.rs));const{plaintext:i,valid:o}=this.decryptAndHash(e.ss,t.ciphertext),{cs1:s,cs2:a}=this.split(e.ss);return{h:e.ss.h,plaintext:i,valid:r&&o,cs1:s,cs2:a}}initSession(e,t,n){const r=this.createEmptyKey(),i=(0,Us.u)(32);let o;return o=e?this.initializeInitiator(t,n,i,r):this.initializeResponder(t,n,i,r),{hs:o,i:e,mc:0}}sendMessage(e,t,n){let r;if(0===e.mc)r=this.writeMessageA(e.hs,t,n);else if(1===e.mc)r=this.writeMessageB(e.hs,t);else if(2===e.mc){const{h:n,messageBuffer:i,cs1:o,cs2:s}=this.writeMessageC(e.hs,t);r=i,e.h=n,e.cs1=o,e.cs2=s}else{if(!(e.mc>2))throw new Error("Session invalid.");if(e.i){if(!e.cs1)throw new Error("CS1 (cipher state) is not defined");r=this.writeMessageRegular(e.cs1,t)}else{if(!e.cs2)throw new Error("CS2 (cipher state) is not defined");r=this.writeMessageRegular(e.cs2,t)}}return e.mc++,r}recvMessage(e,t){let n=(0,Us.u)(0),r=!1;if(0===e.mc)({plaintext:n,valid:r}=this.readMessageA(e.hs,t));else if(1===e.mc)({plaintext:n,valid:r}=this.readMessageB(e.hs,t));else if(2===e.mc){const{h:i,plaintext:o,valid:s,cs1:a,cs2:c}=this.readMessageC(e.hs,t);n=o,r=s,e.h=i,e.cs1=a,e.cs2=c}return e.mc++,{plaintext:n,valid:r}}}class JZ{constructor(e,t,n,r,i,o,s,a){(0,Yo.Z)(this,"isInitiator",void 0),(0,Yo.Z)(this,"session",void 0),(0,Yo.Z)(this,"remotePeer",void 0),(0,Yo.Z)(this,"remoteExtensions",{webtransportCerthashes:[]}),(0,Yo.Z)(this,"payload",void 0),(0,Yo.Z)(this,"connection",void 0),(0,Yo.Z)(this,"xx",void 0),(0,Yo.Z)(this,"staticKeypair",void 0),(0,Yo.Z)(this,"prologue",void 0),this.isInitiator=e,this.payload=t,this.prologue=n,this.staticKeypair=i,this.connection=o,s&&(this.remotePeer=s),this.xx=null!==a&&void 0!==a?a:new YZ(r),this.session=this.xx.initSession(this.isInitiator,this.prologue,this.staticKeypair)}async propose(){var e;if(e=this.session.hs.s,HZ("LOCAL_STATIC_PUBLIC_KEY ".concat((0,Au.B)(e.publicKey,"hex"))),HZ("LOCAL_STATIC_PRIVATE_KEY ".concat((0,Au.B)(e.privateKey,"hex"))),this.isInitiator){VZ.trace("Stage 0 - Initiator starting to send first message.");const e=this.xx.sendMessage(this.session,(0,Us.u)(0));await this.connection.write(function(e){return(0,Ls.z)([e.ne,e.ciphertext],e.ne.length+e.ciphertext.length)}(e)),VZ.trace("Stage 0 - Initiator finished sending first message."),qZ(this.session.hs.e)}else{VZ.trace("Stage 0 - Responder waiting to receive first message...");const e=function(e){if(e.length<32)throw new Error("Cannot decode stage 0 MessageBuffer: length less than 32 bytes.");return{ne:e.subarray(0,32),ciphertext:e.subarray(32,e.length),ns:(0,Us.u)(0)}}((await this.connection.read()).subarray()),{valid:t}=this.xx.recvMessage(this.session,e);if(!t)throw new qF("xx handshake stage 0 validation fail");VZ.trace("Stage 0 - Responder received first message."),GZ(this.session.hs.re)}}async exchange(){if(this.isInitiator){VZ.trace("Stage 1 - Initiator waiting to receive first message from responder...");const n=function(e){if(e.length<80)throw new Error("Cannot decode stage 1 MessageBuffer: length less than 80 bytes.");return{ne:e.subarray(0,32),ns:e.subarray(32,80),ciphertext:e.subarray(80,e.length)}}((await this.connection.read()).subarray()),{plaintext:r,valid:i}=this.xx.recvMessage(this.session,n);if(!i)throw new qF("xx handshake stage 1 validation fail");VZ.trace("Stage 1 - Initiator received the message."),GZ(this.session.hs.re),e=this.session.hs.rs,HZ("REMOTE_STATIC_PUBLIC_KEY ".concat((0,Au.B)(e,"hex"))),VZ.trace("Initiator going to check remote's signature...");try{const e=FZ(r);this.remotePeer=this.remotePeer||await UZ(e),await jZ(this.session.hs.rs,e,this.remotePeer),this.setRemoteNoiseExtension(e.extensions)}catch(t){throw new HF("Error occurred while verifying signed payload: ".concat(t.message))}VZ.trace("All good with the signature!")}else{VZ.trace("Stage 1 - Responder sending out first message with signed payload and static key.");const e=this.xx.sendMessage(this.session,this.payload);await this.connection.write(function(e){return(0,Ls.z)([e.ne,e.ns,e.ciphertext],e.ne.length+e.ns.length+e.ciphertext.length)}(e)),VZ.trace("Stage 1 - Responder sent the second handshake message with signed payload."),qZ(this.session.hs.e)}var e}async finish(){if(this.isInitiator){VZ.trace("Stage 2 - Initiator sending third handshake message.");const e=this.xx.sendMessage(this.session,this.payload);await this.connection.write(function(e){return(0,Ls.z)([e.ns,e.ciphertext],e.ns.length+e.ciphertext.length)}(e)),VZ.trace("Stage 2 - Initiator sent message with signed payload.")}else{VZ.trace("Stage 2 - Responder waiting for third handshake message...");const e=function(e){if(e.length<48)throw new Error("Cannot decode stage 2 MessageBuffer: length less than 48 bytes.");return{ne:(0,Us.u)(0),ns:e.subarray(0,48),ciphertext:e.subarray(48,e.length)}}((await this.connection.read()).subarray()),{plaintext:n,valid:r}=this.xx.recvMessage(this.session,e);if(!r)throw new qF("xx handshake stage 2 validation fail");VZ.trace("Stage 2 - Responder received the message, finished handshake.");try{const e=FZ(n);this.remotePeer=this.remotePeer||await UZ(e),await jZ(this.session.hs.rs,e,this.remotePeer),this.setRemoteNoiseExtension(e.extensions)}catch(t){throw new HF("Error occurred while verifying signed payload: ".concat(t.message))}}var e;(e=this.session).cs1&&e.cs2?(HZ("CIPHER_STATE_1 ".concat(e.cs1.n.getUint64()," ").concat((0,Au.B)(e.cs1.k,"hex"))),HZ("CIPHER_STATE_2 ".concat(e.cs2.n.getUint64()," ").concat((0,Au.B)(e.cs2.k,"hex")))):HZ("Missing cipher state.")}encrypt(e,t){const n=this.getCS(t);return this.xx.encryptWithAd(n,(0,Us.u)(0),e)}decrypt(e,t,n){const r=this.getCS(t,!1);return this.xx.decryptWithAd(r,(0,Us.u)(0),e,n)}getRemoteStaticKey(){return this.session.hs.rs}getCS(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(!e.cs1||!e.cs2)throw new qF("Handshake not completed properly, cipher state does not exist.");return this.isInitiator?t?e.cs1:e.cs2:t?e.cs2:e.cs1}setRemoteNoiseExtension(e){e&&(this.remoteExtensions=e)}}class XZ{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};(0,Yo.Z)(this,"protocol","/noise"),(0,Yo.Z)(this,"crypto",void 0),(0,Yo.Z)(this,"prologue",void 0),(0,Yo.Z)(this,"staticKeys",void 0),(0,Yo.Z)(this,"extensions",void 0),(0,Yo.Z)(this,"metrics",void 0);const{staticNoiseKey:t,extensions:n,crypto:r,prologueBytes:i,metrics:o}=e;this.crypto=null!==r&&void 0!==r?r:jF,this.extensions=n,this.metrics=o?function(e){return{xxHandshakeSuccesses:e.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:e.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:e.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:e.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:e.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}(o):void 0,this.staticKeys=t?this.crypto.generateX25519KeyPairFromSeed(t):this.crypto.generateX25519KeyPair(),this.prologue=null!==i&&void 0!==i?i:(0,Us.u)(0)}async secureOutbound(e,t,n){const r=la(t,{lengthEncoder:ZF,lengthDecoder:zF,maxDataLength:FF}),i=await this.performHandshake({connection:r,isInitiator:!0,localPeer:e,remotePeer:n});return{conn:await this.createSecureConnection(r,i),remoteExtensions:i.remoteExtensions,remotePeer:i.remotePeer}}async secureInbound(e,t,n){const r=la(t,{lengthEncoder:ZF,lengthDecoder:zF,maxDataLength:FF}),i=await this.performHandshake({connection:r,isInitiator:!1,localPeer:e,remotePeer:n});return{conn:await this.createSecureConnection(r,i),remotePeer:i.remotePeer,remoteExtensions:i.remoteExtensions}}async performHandshake(e){const t=await MZ(e.localPeer,this.staticKeys.publicKey,this.extensions);return this.performXXHandshake(e,t)}async performXXHandshake(e,t){const{isInitiator:n,remotePeer:r,connection:i}=e,o=new JZ(n,t,this.prologue,this.crypto,this.staticKeys,i,r);try{var s;await o.propose(),await o.exchange(),await o.finish(),null===(s=this.metrics)||void 0===s||s.xxHandshakeSuccesses.increment()}catch(c){var a;if(null===(a=this.metrics)||void 0===a||a.xxHandshakeErrors.increment(),c instanceof Error)throw c.message="Error occurred during XX handshake: ".concat(c.message),c}return o}async createSecureConnection(e,t){const[n,r]=function(){const e=IF(),t=IF();return[{source:e.source,sink:t.sink},{source:t.source,sink:e.sink}]}(),i=e.unwrap();return await function(e){if(null==e)throw new Error("Empty pipeline");if(BF(e)){const t=e;e=()=>t.source}else if(NF(e)||OF(e)){const t=e;e=()=>t}for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const i=[e,...n];if(i.length>1&&BF(i[i.length-1])&&(i[i.length-1]=i[i.length-1].sink),i.length>2)for(let o=1;o<i.length-1;o++)BF(i[o])&&(i[o]=LF(i[o]));return DF(...i)}(n,function(e,t){return async function*(n){for await(const r of n)for(let n=0;n<r.length;n+=65519){let i=n+65519;i>r.length&&(i=r.length);const o=e.encrypt(r.subarray(n,i),e.session);null===t||void 0===t||t.encryptedPackets.increment(),yield(0,Xh.zo)([ZF(o.byteLength),o],2+o.byteLength)}}}(t,this.metrics),i,(e=>_F(e,{lengthDecoder:zF})),function(e,t){return async function*(n){for await(const r of n)for(let n=0;n<r.length;n+=FF){let i=n+FF;if(i>r.length&&(i=r.length),i-16<n)throw new Error("Invalid chunk");const o=r.subarray(n,i),s=r.subarray(n,i-16),{plaintext:a,valid:c}=e.decrypt(o,e.session,s);if(!c)throw null===t||void 0===t||t.decryptErrors.increment(),new Error("Failed to validate decrypted chunk");null===t||void 0===t||t.decryptedPackets.increment(),yield a}}}(t,this.metrics),n),r}}async function $Z(e,t,n,r,i,o){const s=o.forComponent("libp2p:webtransport:stream:".concat(n,":").concat(t)),a=e.writable.getWriter(),c=e.readable.getReader();function l(){const e=r.findIndex((e=>e===f));-1!==e&&(r.splice(e,1),f.timeline.close=Date.now(),null===i||void 0===i||i(f))}await a.ready;let u=!1,h=!1;(async function(){const e=await a.closed.catch((e=>e));if(null!=e){const n=e.message;n.includes("aborted by the remote server")||n.includes("STOP_SENDING")||s.error("WebTransport writer closed unexpectedly: streamId=".concat(t," err=").concat(e.message))}u=!0,u&&h&&l()})().catch((()=>{s.error("WebTransport failed to cleanup closed stream")})),async function(){const e=await c.closed.catch((e=>e));null!=e&&s.error("WebTransport reader closed unexpectedly: streamId=".concat(t," err=").concat(e.message)),h=!0,u&&h&&l()}().catch((()=>{s.error("WebTransport failed to cleanup closed stream")}));let d=!1;const f={id:t,status:"open",writeStatus:"ready",readStatus:"ready",abort(e){u||(a.abort(e).catch((e=>{s.error("could not abort stream",e)})),u=!0),h=!0,this.status="aborted",this.writeStatus="closed",this.readStatus="closed",this.timeline.reset=this.timeline.close=this.timeline.closeRead=this.timeline.closeWrite=Date.now(),l()},async close(e){this.status="closing",await Promise.all([f.closeRead(e),f.closeWrite(e)]),l(),this.status="closed",this.timeline.close=Date.now()},async closeRead(e){if(!h){this.readStatus="closing";try{await c.cancel()}catch(t){!0===t.toString().includes("RESET_STREAM")&&(u=!0)}this.timeline.closeRead=Date.now(),this.readStatus="closed",h=!0}u&&l()},async closeWrite(e){if(!u){u=!0,this.writeStatus="closing";try{await a.close()}catch(t){!0===t.toString().includes("RESET_STREAM")&&(h=!0)}this.timeline.closeWrite=Date.now(),this.writeStatus="closed"}h&&l()},direction:n,timeline:{open:Date.now()},metadata:{},source:async function*(){for(;;){const e=await c.read();if(e.done)return h=!0,void(u&&l());yield new Zs(e.value)}}(),sink:async function(e){if(d)throw new Error("sink already called on stream");d=!0;try{this.writeStatus="writing";for await(const t of e)if(t instanceof Uint8Array)await a.write(t);else for(const e of t)await a.write(e);this.writeStatus="done"}finally{this.timeline.closeWrite=Date.now(),this.writeStatus="closed",await f.closeWrite()}},log:s};return f}function ez(){return{source:{[Symbol.asyncIterator]:()=>({next:async()=>new Promise((()=>{}))})},sink:async e=>new Promise((()=>{}))}}const tz=Symbol.for("nodejs.util.inspect.custom"),nz=Object.values(_Z).map((e=>e.decoder)).reduce(((e,t)=>e.or(t)),_Z.identity.decoder),rz=114,iz=36,oz=37;class sz{constructor(e){(0,Yo.Z)(this,"type",void 0),(0,Yo.Z)(this,"multihash",void 0),(0,Yo.Z)(this,"privateKey",void 0),(0,Yo.Z)(this,"publicKey",void 0),(0,Yo.Z)(this,"string",void 0),(0,Yo.Z)(this,fu.Cs,!0),this.type=e.type,this.multihash=e.multihash,this.privateKey=e.privateKey,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return"PeerId(".concat(this.toString(),")")}toString(){return null==this.string&&(this.string=uK.encode(this.multihash.bytes).slice(1)),this.string}toCID(){return yZ.createV1(rz,this.multihash)}toBytes(){return this.multihash.bytes}toJSON(){return this.toString()}equals(e){var t;if(e instanceof Uint8Array)return(0,Ms.f)(this.multihash.bytes,e);if("string"===typeof e)return uz(e).equals(this);if(null!=(null===e||void 0===e||null===(t=e.multihash)||void 0===t?void 0:t.bytes))return(0,Ms.f)(this.multihash.bytes,e.multihash.bytes);throw new Error("not valid Id")}[tz](){return"PeerId(".concat(this.toString(),")")}}class az extends sz{constructor(e){super({...e,type:"RSA"}),(0,Yo.Z)(this,"type","RSA"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.publicKey}}class cz extends sz{constructor(e){super({...e,type:"Ed25519"}),(0,Yo.Z)(this,"type","Ed25519"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.multihash.digest}}class lz extends sz{constructor(e){super({...e,type:"secp256k1"}),(0,Yo.Z)(this,"type","secp256k1"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.multihash.digest}}function uz(e,t){var n;if(t=null!==(n=t)&&void 0!==n?n:nz,"1"===e.charAt(0)||"Q"===e.charAt(0)){const t=OK(uK.decode("z".concat(e)));return e.startsWith("12D")?new cz({multihash:t}):e.startsWith("16U")?new lz({multihash:t}):new az({multihash:t})}return function(e){try{const t=OK(e);if(t.code===LK.code){if(t.digest.length===iz)return new cz({multihash:t});if(t.digest.length===oz)return new lz({multihash:t})}if(t.code===KK.code)return new az({multihash:t})}catch{return function(e){if(null==e||null==e.multihash||null==e.version||1===e.version&&e.code!==rz)throw new Error("Supplied PeerID CID is invalid");const t=e.multihash;if(t.code===KK.code)return new az({multihash:e.multihash});if(t.code===LK.code){if(t.digest.length===iz)return new cz({multihash:e.multihash});if(t.digest.length===oz)return new lz({multihash:e.multihash})}throw new Error("Supplied PeerID CID is invalid")}(yZ.decode(e))}throw new Error("Supplied PeerID CID is invalid")}(nz.decode(e))}const hz=Object.values(_Z).map((e=>e.decoder)).reduce(((e,t)=>e.or(t)));function dz(e){var t;if(!tO.Mk.matches(e))throw new fu.sv("Invalid multiaddr, was not a WebTransport address","ERR_INVALID_MULTIADDR");const n=e.stringTuples(),r=n.filter((e=>{let[t,n]=e;return t===(0,ng.a_)("certhash").code})).map((e=>{let[t,n]=e;return r=null!==n&&void 0!==n?n:"",OK(hz.decode(r));var r})),i=n.filter((e=>{let[t,n]=e;return t===(0,ng.a_)("p2p").code})).map((e=>{let[t,n]=e;return uz(null!==n&&void 0!==n?n:"")}))[0],o=e.toOptions();let s=o.host;return 6===o.family&&null!==(t=s)&&void 0!==t&&t.includes(":")&&(s="[".concat(s,"]")),{url:"https://".concat(s,":").concat(o.port),certhashes:r,remotePeer:i}}class fz{constructor(e){var t;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};(0,Yo.Z)(this,"log",void 0),(0,Yo.Z)(this,"components",void 0),(0,Yo.Z)(this,"config",void 0),(0,Yo.Z)(this,"metrics",void 0),(0,Yo.Z)(this,Symbol.toStringTag,"@libp2p/webtransport"),(0,Yo.Z)(this,fu.SF,!0),this.log=e.logger.forComponent("libp2p:webtransport"),this.components=e,this.config={maxInboundStreams:null!==(t=n.maxInboundStreams)&&void 0!==t?t:1e3},null!=e.metrics&&(this.metrics={dialerEvents:e.metrics.registerCounterGroup("libp2p_webtransport_dialer_events_total",{label:"event",help:"Total count of WebTransport dialer events by type"})})}async dial(e,t){var n,r,i;null===(n=t)||void 0===n||null===(r=n.signal)||void 0===r||r.throwIfAborted(),this.log("dialing %s",e);const o=this.components.peerId;if(void 0===o)throw new Error("Need a local peerid");t=null!==(i=t)&&void 0!==i?i:{};const{url:s,certhashes:a,remotePeer:c}=dz(e);if(null==c)throw new Error("Need a target peerid");if(0===a.length)throw new Error("Expected multiaddr to contain certhashes");let l,u,h=()=>{},d=!1,f=!1,p=!1;try{var g,y,m,v;null===(g=this.metrics)||void 0===g||g.dialerEvents.increment({pending:!0});const n=new WebTransport("".concat(s,"/.well-known/libp2p-webtransport?type=noise"),{serverCertificateHashes:a.map((e=>({algorithm:"sha-256",value:e.digest})))});if(h=e=>{if(!d)try{var t;null===(t=this.metrics)||void 0===t||t.dialerEvents.increment({[e]:!0}),n.close()}catch(r){this.log.error("error closing wt session",r)}finally{null!=u&&(u.timeline.close=Date.now()),d=!0}},l=()=>{h(f?"noise_timeout":"ready_timeout")},null===(y=t.signal)||void 0===y||y.addEventListener("abort",l,{once:!0}),await Promise.race([n.closed,n.ready]),f=!0,null===(m=this.metrics)||void 0===m||m.dialerEvents.increment({ready:!0}),n.closed.catch((e=>{this.log.error("error on remote wt session close",e)})).finally((()=>{h("remote_close")})),!await this.authenticateWebTransport(n,o,c,a))throw new Error("Failed to authenticate webtransport");return null===(v=this.metrics)||void 0===v||v.dialerEvents.increment({open:!0}),u={close:async()=>{this.log("Closing webtransport"),h("close")},abort:e=>{this.log("aborting webtransport due to passed err",e),h("abort")},remoteAddr:e,timeline:{open:Date.now()},log:this.components.logger.forComponent("libp2p:webtransport:maconn"),...ez()},p=!0,await t.upgrader.upgradeOutbound(u,{skipEncryption:!0,muxerFactory:this.webtransportMuxer(n),skipProtection:!0})}catch(w){throw this.log.error("caught wt session err",w),h(p?"upgrade_error":f?"noise_error":"ready_error"),w}finally{var b;if(null!=l)null===(b=t.signal)||void 0===b||b.removeEventListener("abort",l)}}async authenticateWebTransport(e,t,n,r){var i;const o=await e.createBidirectionalStream(),s=o.writable.getWriter(),a=o.readable.getReader();await s.ready;const c={source:async function*(){for(;;){const e=await a.read();if(null!=e.value&&(yield e.value),e.done)break}}(),sink:async function(e){for await(const t of e)t instanceof Uint8Array?await s.write(t):await s.write(t.subarray())}},l=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return()=>new XZ(e)}()(),{remoteExtensions:u}=await l.secureOutbound(t,c,n);if(s.close().catch((e=>{this.log.error("Failed to close authentication stream writer: ".concat(e.message))})),a.cancel().catch((e=>{this.log.error("Failed to close authentication stream reader: ".concat(e.message))})),h=null!==(i=null===u||void 0===u?void 0:u.webtransportCerthashes)&&void 0!==i?i:[],(d=r.map((e=>e.bytes))).filter((e=>Boolean(h.find((t=>(0,Ms.f)(e,t)))))).length!==d.length)throw new Error("Our certhashes are not a subset of the remote's reported certhashes");var h,d;return!0}webtransportMuxer(e){let t=0;const n=this.config,r=this;return{protocol:"webtransport",createStreamMuxer:i=>{"function"===typeof i&&(i={onIncomingStream:i});const o=[];(async function(){const s=e.incomingBidirectionalStreams.getReader();for(;;){const{done:e,value:h}=await s.read();if(e)break;if(o.length>=n.maxInboundStreams)h.writable.close().catch((e=>{r.log.error("Failed to close inbound stream that crossed our maxInboundStream limit: ".concat(e.message))})),h.readable.cancel().catch((e=>{r.log.error("Failed to close inbound stream that crossed our maxInboundStream limit: ".concat(e.message))}));else{var a,c,l,u;const e=await $Z(h,String(t++),"inbound",o,null===(a=i)||void 0===a?void 0:a.onStreamEnd,r.components.logger);o.push(e),null===(c=i)||void 0===c||null===(l=(u=c).onIncomingStream)||void 0===l||l.call(u,e)}}})().catch((()=>{this.log.error("WebTransport failed to receive incoming stream")}));return{protocol:"webtransport",streams:o,newStream:async n=>{var s,a,c;const l=await e.createBidirectionalStream(),u=await $Z(l,String(t++),null!==(s=null===(a=i)||void 0===a?void 0:a.direction)&&void 0!==s?s:"outbound",o,null===(c=i)||void 0===c?void 0:c.onStreamEnd,r.components.logger);return o.push(u),u},close:async e=>{this.log("Closing webtransport muxer"),await Promise.all(o.map((async t=>t.close(e))))},abort:e=>{this.log("Aborting webtransport muxer with err:",e);for(const t of o)t.abort(e)},...ez()}}}}createListener(e){throw new Error("Webtransport servers are not supported in Node or the browser")}filter(e){return e.filter(tO.Mk.exactMatch)}}function pz(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t=>new fz(t,e)}function gz(e){var t;return e=null!==(t=e)&&void 0!==t?t:new Error("Open failed"),Xo()(e,"ERR_OPEN_FAILED")}function yz(e){var t;return e=null!==(t=e)&&void 0!==t?t:new Error("Close failed"),Xo()(e,"ERR_CLOSE_FAILED")}function mz(e){var t;return e=null!==(t=e)&&void 0!==t?t:new Error("Put failed"),Xo()(e,"ERR_PUT_FAILED")}function vz(e){var t;return e=null!==(t=e)&&void 0!==t?t:new Error("Get failed"),Xo()(e,"ERR_GET_FAILED")}function bz(e){var t;return e=null!==(t=e)&&void 0!==t?t:new Error("Delete failed"),Xo()(e,"ERR_DELETE_FAILED")}function wz(e){var t;return e=null!==(t=e)&&void 0!==t?t:new Error("Has failed"),Xo()(e,"ERR_HAS_FAILED")}function Ez(e){var t;return e=null!==(t=e)&&void 0!==t?t:new Error("Not Found"),Xo()(e,"ERR_NOT_FOUND")}function Az(e){var t;return e=null!==(t=e)&&void 0!==t?t:new Error("Aborted"),Xo()(e,"ERR_ABORTED")}var Sz=function(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var n=new Uint8Array(256),r=0;r<n.length;r++)n[r]=255;for(var i=0;i<e.length;i++){var o=e.charAt(i),s=o.charCodeAt(0);if(255!==n[s])throw new TypeError(o+" is ambiguous");n[s]=i}var a=e.length,c=e.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function h(e){if("string"!==typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var r=0,i=0;e[t]===c;)r++,t++;for(var o=(e.length-t)*l+1>>>0,s=new Uint8Array(o);e[t];){var u=n[e.charCodeAt(t)];if(255===u)return;for(var h=0,d=o-1;(0!==u||h<i)&&-1!==d;d--,h++)u+=a*s[d]>>>0,s[d]=u%256>>>0,u=u/256>>>0;if(0!==u)throw new Error("Non-zero carry");i=h,t++}if(" "!==e[t]){for(var f=o-i;f!==o&&0===s[f];)f++;for(var p=new Uint8Array(r+(o-f)),g=r;f!==o;)p[g++]=s[f++];return p}}}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var n=0,r=0,i=0,o=t.length;i!==o&&0===t[i];)i++,n++;for(var s=(o-i)*u+1>>>0,l=new Uint8Array(s);i!==o;){for(var h=t[i],d=0,f=s-1;(0!==h||d<r)&&-1!==f;f--,d++)h+=256*l[f]>>>0,l[f]=h%a>>>0,h=h/a>>>0;if(0!==h)throw new Error("Non-zero carry");r=d,i++}for(var p=s-r;p!==s&&0===l[p];)p++;for(var g=c.repeat(n);p<s;++p)g+=e.charAt(l[p]);return g},decodeUnsafe:h,decode:function(e){var n=h(e);if(n)return n;throw new Error("Non-".concat(t," character"))}}};const _z=Sz,Iz=(new Uint8Array(0),e=>{if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")});class Cz{constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return"".concat(this.prefix).concat(this.baseEncode(e));throw Error("Unknown type, must be binary type")}}class Tz{constructor(e,t,n){if(this.name=e,this.prefix=t,void 0===t.codePointAt(0))throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=n}decode(e){if("string"===typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error("Unable to decode multibase string ".concat(JSON.stringify(e),", ").concat(this.name," decoder only supports inputs prefixed with ").concat(this.prefix));return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return Rz(this,e)}}class kz{constructor(e){this.decoders=e}or(e){return Rz(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n)return n.decode(e);throw RangeError("Unable to decode multibase string ".concat(JSON.stringify(e),", only inputs prefixed with ").concat(Object.keys(this.decoders)," are supported"))}}const Rz=(e,t)=>new kz({...e.decoders||{[e.prefix]:e},...t.decoders||{[t.prefix]:t}});class xz{constructor(e,t,n,r){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=r,this.encoder=new Cz(e,t,n),this.decoder=new Tz(e,t,r)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const Pz=e=>{let{name:t,prefix:n,encode:r,decode:i}=e;return new xz(t,n,r,i)},Dz=e=>{let{prefix:t,name:n,alphabet:r}=e;const{encode:i,decode:o}=_z(r,n);return Pz({prefix:t,name:n,encode:i,decode:e=>Iz(o(e))})},Oz=e=>{let{name:t,prefix:n,bitsPerChar:r,alphabet:i}=e;return Pz({prefix:n,name:t,encode:e=>((e,t,n)=>{const r="="===t[t.length-1],i=(1<<n)-1;let o="",s=0,a=0;for(let c=0;c<e.length;++c)for(a=a<<8|e[c],s+=8;s>n;)s-=n,o+=t[i&a>>s];if(s&&(o+=t[i&a<<n-s]),r)for(;o.length*n&7;)o+="=";return o})(e,i,r),decode:e=>((e,t,n,r)=>{const i={};for(let u=0;u<t.length;++u)i[t[u]]=u;let o=e.length;for(;"="===e[o-1];)--o;const s=new Uint8Array(o*n/8|0);let a=0,c=0,l=0;for(let u=0;u<o;++u){const t=i[e[u]];if(void 0===t)throw new SyntaxError("Non-".concat(r," character"));c=c<<n|t,a+=n,a>=8&&(a-=8,s[l++]=255&c>>a)}if(a>=n||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return s})(e,i,r,t)})},Nz=Oz({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Bz=(Oz({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Oz({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Oz({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Oz({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Oz({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Oz({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Oz({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Oz({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),Dz({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}));Dz({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var Lz=function e(t,n,r){n=n||[];var i=r=r||0;for(;t>=Fz;)n[r++]=255&t|Mz,t/=128;for(;t&Uz;)n[r++]=255&t|Mz,t>>>=7;return n[r]=0|t,e.bytes=r-i+1,n},Mz=128,Uz=-128,Fz=Math.pow(2,31);var Kz=function e(t,n){var r,i=0,o=0,s=n=n||0,a=t.length;do{if(s>=a)throw e.bytes=0,new RangeError("Could not decode varint");r=t[s++],i+=o<28?(r&Zz)<<o:(r&Zz)*Math.pow(2,o),o+=7}while(r>=jz);return e.bytes=s-n,i},jz=128,Zz=127;var zz=Math.pow(2,7),Vz=Math.pow(2,14),Hz=Math.pow(2,21),qz=Math.pow(2,28),Gz=Math.pow(2,35),Wz=Math.pow(2,42),Qz=Math.pow(2,49),Yz=Math.pow(2,56),Jz=Math.pow(2,63);const Xz={encode:Lz,decode:Kz,encodingLength:function(e){return e<zz?1:e<Vz?2:e<Hz?3:e<qz?4:e<Gz?5:e<Wz?6:e<Qz?7:e<Yz?8:e<Jz?9:10}},$z=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return[Xz.decode(e,t),Xz.decode.bytes]},eV=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Xz.encode(e,t,n),t},tV=e=>Xz.encodingLength(e),nV=e=>{const t=Iz(e),[n,r]=$z(t),[i,o]=$z(t.subarray(r)),s=t.subarray(r+o);if(s.byteLength!==i)throw new Error("Incorrect length");return new rV(n,i,s,t)};class rV{constructor(e,t,n,r){this.code=e,this.size=t,this.digest=n,this.bytes=r}}const iV=(e,t)=>{const{bytes:n,version:r}=e;return 0===r?lV(n,sV(e),t||Bz.encoder):uV(n,sV(e),t||Nz.encoder)},oV=new WeakMap,sV=e=>{const t=oV.get(e);if(null==t){const t=new Map;return oV.set(e,t),t}return t};class aV{constructor(e,t,n,r){this.code=t,this.version=e,this.multihash=n,this.bytes=r,this["/"]=r}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==hV)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==dV)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return aV.createV0(t)}default:throw Error("Can not convert CID version ".concat(this.version," to version 0. This is a bug please report"))}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=((e,t)=>{const n=t.byteLength,r=tV(e),i=r+tV(n),o=new Uint8Array(i+n);return eV(e,o,0),eV(n,o,r),o.set(t,i),new rV(e,n,t,o)})(e,t);return aV.createV1(this.code,n)}case 1:return this;default:throw Error("Can not convert CID version ".concat(this.version," to version 1. This is a bug please report"))}}equals(e){return aV.equals(this,e)}static equals(e,t){const n=t;return n&&e.code===n.code&&e.version===n.version&&((e,t)=>{if(e===t)return!0;{const n=t;return e.code===n.code&&e.size===n.size&&n.bytes instanceof Uint8Array&&((e,t)=>{if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0})(e.bytes,n.bytes)}})(e.multihash,n.multihash)}toString(e){return iV(this,e)}toJSON(){return{"/":iV(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return"CID(".concat(this.toString(),")")}static asCID(e){if(null==e)return null;const t=e;if(t instanceof aV)return t;if(null!=t["/"]&&t["/"]===t.bytes||t.asCID===t){const{version:e,code:n,multihash:r,bytes:i}=t;return new aV(e,n,r,i||fV(e,n,r.bytes))}if(!0===t[pV]){const{version:e,multihash:n,code:r}=t,i=nV(n);return aV.create(e,r,i)}return null}static create(e,t,n){if("number"!==typeof t)throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:if(t!==hV)throw new Error("Version 0 CID must use dag-pb (code: ".concat(hV,") block encoding"));return new aV(e,t,n,n.bytes);case 1:{const r=fV(e,t,n.bytes);return new aV(e,t,n,r)}default:throw new Error("Invalid version")}}static createV0(e){return aV.create(0,hV,e)}static createV1(e,t){return aV.create(1,e,t)}static decode(e){const[t,n]=aV.decodeFirst(e);if(n.length)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=aV.inspectBytes(e),n=t.size-t.multihashSize,r=Iz(e.subarray(n,n+t.multihashSize));if(r.byteLength!==t.multihashSize)throw new Error("Incorrect length");const i=r.subarray(t.multihashSize-t.digestSize),o=new rV(t.multihashCode,t.digestSize,i,r);return[0===t.version?aV.createV0(o):aV.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[n,r]=$z(e.subarray(t));return t+=r,n};let r=n(),i=hV;if(18===r?(r=0,t=0):i=n(),0!==r&&1!==r)throw new RangeError("Invalid CID version ".concat(r));const o=t,s=n(),a=n(),c=t+a;return{version:r,codec:i,multihashCode:s,digestSize:a,multihashSize:c-o,size:c}}static parse(e,t){const[n,r]=cV(e,t),i=aV.decode(r);if(0===i.version&&"Q"!==e[0])throw Error("Version 0 CID string must not include multibase prefix");return sV(i).set(n,e),i}}const cV=(e,t)=>{switch(e[0]){case"Q":{const n=t||Bz;return[Bz.prefix,n.decode("".concat(Bz.prefix).concat(e))]}case Bz.prefix:{const n=t||Bz;return[Bz.prefix,n.decode(e)]}case Nz.prefix:{const n=t||Nz;return[Nz.prefix,n.decode(e)]}default:if(null==t)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}},lV=(e,t,n)=>{const{prefix:r}=n;if(r!==Bz.prefix)throw Error("Cannot string encode V0 in ".concat(n.name," encoding"));const i=t.get(r);if(null==i){const i=n.encode(e).slice(1);return t.set(r,i),i}return i},uV=(e,t,n)=>{const{prefix:r}=n,i=t.get(r);if(null==i){const i=n.encode(e);return t.set(r,i),i}return i},hV=112,dV=18,fV=(e,t,n)=>{const r=tV(e),i=r+tV(t),o=new Uint8Array(i+n.byteLength);return eV(e,o,0),eV(t,o,r),o.set(n,i),o},pV=Symbol.for("@ipld/js-cid/CID");class gV{has(e,t){return Promise.reject(new Error(".has is not implemented"))}put(e,t,n){return Promise.reject(new Error(".put is not implemented"))}async*putMany(e,t){for await(const{cid:n,block:r}of e)await this.put(n,r,t),yield n}get(e,t){return Promise.reject(new Error(".get is not implemented"))}async*getMany(e,t){for await(const n of e)yield{cid:n,block:await this.get(n,t)}}async delete(e,t){await Promise.reject(new Error(".delete is not implemented"))}async*deleteMany(e,t){for await(const n of e)await this.delete(n,t),yield n}async*getAll(e){throw new Error(".getAll is not implemented")}}class yV extends gV{constructor(){super(),(0,Yo.Z)(this,"data",void 0),this.data=new Map}put(e,t){return this.data.set(Nz.encode(e.multihash.bytes),t),e}get(e){const t=this.data.get(Nz.encode(e.multihash.bytes));if(null==t)throw Ez();return t}has(e){return this.data.has(Nz.encode(e.multihash.bytes))}async delete(e){this.data.delete(Nz.encode(e.multihash.bytes))}async*getAll(){for(const[e,t]of this.data.entries())yield{cid:aV.createV1(85,nV(Nz.decode(e))),block:t}}}const mV=Oz({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6});Oz({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Oz({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Oz({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});function vV(e){let t=function(e){const t=()=>{};return t.enabled=!1,t.color="",t.diff=0,t.log=()=>{},t.namespace=e,t.destroy=()=>!0,t.extend=()=>t,t}("".concat(e,":trace"));return sf().enabled("".concat(e,":trace"))&&null!=sf().names.map((e=>e.toString())).find((e=>e.includes(":trace")))&&(t=sf()("".concat(e,":trace"))),Object.assign(sf()(e),{error:sf()("".concat(e,":error")),trace:t})}sf().formatters.b=e=>null==e?"undefined":Bz.baseEncode(e),sf().formatters.t=e=>null==e?"undefined":Nz.baseEncode(e),sf().formatters.m=e=>null==e?"undefined":mV.baseEncode(e),sf().formatters.p=e=>null==e?"undefined":e.toString(),sf().formatters.c=e=>null==e?"undefined":e.toString(),sf().formatters.k=e=>null==e?"undefined":e.toString(),sf().formatters.a=e=>null==e?"undefined":e.toString();vV("blockstore:core:tiered");const bV="/",wV=(new TextEncoder).encode(bV),EV=wV[0];class AV{constructor(e,t){if((0,Yo.Z)(this,"_buf",void 0),"string"===typeof e)this._buf=(0,yu.m)(e);else{if(!(e instanceof Uint8Array))throw new Error("Invalid key, should be String of Uint8Array");this._buf=e}if(null==t&&(t=!0),t&&this.clean(),0===this._buf.byteLength||this._buf[0]!==EV)throw new Error("Invalid key")}toString(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"utf8";return(0,Au.B)(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return"Key(".concat(this.toString(),")")}static withNamespaces(e){return new AV(e.join(bV))}static random(){return new AV(function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:21;return crypto.getRandomValues(new Uint8Array(e)).reduce(((e,t)=>e+((t&=63)<36?t.toString(36):t<62?(t-26).toString(36).toUpperCase():t>62?"-":"_")),"")}().replace(/-/g,""))}static asKey(e){return e instanceof Uint8Array||"string"===typeof e?new AV(e):"function"===typeof e.uint8Array?new AV(e.uint8Array()):null}clean(){if(null!=this._buf&&0!==this._buf.byteLength||(this._buf=wV),this._buf[0]!==EV){const e=new Uint8Array(this._buf.byteLength+1);e.fill(EV,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===EV;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),n=e.list();for(let r=0;r<t.length;r++){if(n.length<r+1)return!1;const e=t[r],i=n[r];if(e<i)return!0;if(e>i)return!1}return t.length<n.length}reverse(){return AV.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(bV).slice(1)}type(){return function(e){const t=e.split(":");if(t.length<2)return"";return t.slice(0,-1).join(":")}(this.baseNamespace())}name(){return function(e){const t=e.split(":");return t[t.length-1]}(this.baseNamespace())}instance(e){return new AV(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(bV)||(e+=bV),e+=this.type(),new AV(e)}parent(){const e=this.list();return 1===e.length?new AV(bV):new AV(e.slice(0,-1).join(bV))}child(e){return this.toString()===bV?e:e.toString()===bV?this:new AV(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()!==this.toString()&&e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()!==this.toString()&&this.toString().startsWith(e.toString())}isTopLevel(){return 1===this.list().length}concat(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return AV.withNamespaces([...this.namespaces(),...(r=t.map((e=>e.namespaces())),[].concat(...r))]);var r}}const SV="SHARDING";const _V=function(e){if(null!=e[Symbol.asyncIterator])return(async()=>{for await(const t of e);})();for(const t of e);};const IV=function(e){const[t,n]=null!=e[Symbol.asyncIterator]?[e[Symbol.asyncIterator](),Symbol.asyncIterator]:[e[Symbol.iterator](),Symbol.iterator],r=[];return{peek:()=>t.next(),push:e=>{r.push(e)},next:()=>r.length>0?{done:!1,value:r.shift()}:t.next(),[n](){return this}}};const CV=function(e,t){if(null!=e[Symbol.asyncIterator])return async function*(){for await(const n of e)await t(n)&&(yield n)}();const n=IV(e),{value:r,done:i}=n.next();if(!0===i)return function*(){}();const o=t(r);if("function"===typeof o.then)return async function*(){await o&&(yield r);for await(const e of n)await t(e)&&(yield e)}();const s=t;return function*(){!0===o&&(yield r);for(const e of n)s(e)&&(yield e)}()};const TV=function(e){if(null!=e[Symbol.asyncIterator])return(async()=>{const t=[];for await(const n of e)t.push(n);return t})();const t=[];for(const n of e)t.push(n);return t};const kV=function(e,t){return null!=e[Symbol.asyncIterator]?async function*(){const n=await TV(e);yield*n.sort(t)}():function*(){const n=TV(e);yield*n.sort(t)}()};const RV=function(e,t){return null!=e[Symbol.asyncIterator]?async function*(){let n=0;if(!(t<1))for await(const r of e)if(yield r,n++,n===t)return}():function*(){let n=0;if(!(t<1))for(const r of e)if(yield r,n++,n===t)return}()};class xV{put(e,t,n){return Promise.reject(new Error(".put is not implemented"))}get(e,t){return Promise.reject(new Error(".get is not implemented"))}has(e,t){return Promise.reject(new Error(".has is not implemented"))}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}putMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){for await(const{key:r,value:i}of e)await t.put(r,i,n),yield r}()}catch(n){return Promise.reject(n)}}getMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){for await(const r of e)yield{key:r,value:await t.get(r,n)}}()}catch(n){return Promise.reject(n)}}deleteMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){for await(const r of e)await t.delete(r,n),yield r}()}catch(n){return Promise.reject(n)}}batch(){let e=[],t=[];return{put(t,n){e.push({key:t,value:n})},delete(e){t.push(e)},commit:async n=>{await _V(this.putMany(e,n)),e=[],await _V(this.deleteMany(t,n)),t=[]}}}async*_all(e,t){throw new Error("._all is not implemented")}async*_allKeys(e,t){throw new Error("._allKeys is not implemented")}query(e,t){let n=this._all(e,t);if(null!=e.prefix){const t=e.prefix;n=CV(n,(e=>e.key.toString().startsWith(t)))}if(Array.isArray(e.filters)&&(n=e.filters.reduce(((e,t)=>CV(e,t)),n)),Array.isArray(e.orders)&&(n=e.orders.reduce(((e,t)=>kV(e,t)),n)),null!=e.offset){let t=0;const r=e.offset;n=CV(n,(()=>t++>=r))}return null!=e.limit&&(n=RV(n,e.limit)),n}queryKeys(e,t){let n=this._allKeys(e,t);if(null!=e.prefix){const t=e.prefix;n=CV(n,(e=>e.toString().startsWith(t)))}if(Array.isArray(e.filters)&&(n=e.filters.reduce(((e,t)=>CV(e,t)),n)),Array.isArray(e.orders)&&(n=e.orders.reduce(((e,t)=>kV(e,t)),n)),null!=e.offset){const t=e.offset;let r=0;n=CV(n,(()=>r++>=t))}return null!=e.limit&&(n=RV(n,e.limit)),n}}class PV extends xV{constructor(){super(),(0,Yo.Z)(this,"data",void 0),this.data=new Map}put(e,t){return this.data.set(e.toString(),t),e}get(e){const t=this.data.get(e.toString());if(null==t)throw function(e){var t;return e=null!==(t=e)&&void 0!==t?t:new Error("Not Found"),Xo()(e,"ERR_NOT_FOUND")}();return t}has(e){return this.data.has(e.toString())}delete(e){this.data.delete(e.toString())}*_all(){for(const[e,t]of this.data.entries())yield{key:new AV(e),value:t}}*_allKeys(){for(const e of this.data.keys())yield new AV(e)}}new AV(SV);var DV=n(85970);function OV(e){let t=function(e){const t=()=>{};return t.enabled=!1,t.color="",t.diff=0,t.log=()=>{},t.namespace=e,t.destroy=()=>!0,t.extend=()=>t,t}("".concat(e,":trace"));return sf().enabled("".concat(e,":trace"))&&null!=sf().names.map((e=>e.toString())).find((e=>e.includes(":trace")))&&(t=sf()("".concat(e,":trace"))),Object.assign(sf()(e),{error:sf()("".concat(e,":error")),trace:t})}sf().formatters.b=e=>null==e?"undefined":mu.base58btc.baseEncode(e),sf().formatters.t=e=>null==e?"undefined":DV.base32.baseEncode(e),sf().formatters.m=e=>null==e?"undefined":xu.base64.baseEncode(e),sf().formatters.p=e=>null==e?"undefined":e.toString(),sf().formatters.c=e=>null==e?"undefined":e.toString(),sf().formatters.k=e=>null==e?"undefined":e.toString(),sf().formatters.a=e=>null==e?"undefined":e.toString();OV("datastore:core:tiered");var NV=function(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var n=new Uint8Array(256),r=0;r<n.length;r++)n[r]=255;for(var i=0;i<e.length;i++){var o=e.charAt(i),s=o.charCodeAt(0);if(255!==n[s])throw new TypeError(o+" is ambiguous");n[s]=i}var a=e.length,c=e.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function h(e){if("string"!==typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var r=0,i=0;e[t]===c;)r++,t++;for(var o=(e.length-t)*l+1>>>0,s=new Uint8Array(o);e[t];){var u=n[e.charCodeAt(t)];if(255===u)return;for(var h=0,d=o-1;(0!==u||h<i)&&-1!==d;d--,h++)u+=a*s[d]>>>0,s[d]=u%256>>>0,u=u/256>>>0;if(0!==u)throw new Error("Non-zero carry");i=h,t++}if(" "!==e[t]){for(var f=o-i;f!==o&&0===s[f];)f++;for(var p=new Uint8Array(r+(o-f)),g=r;f!==o;)p[g++]=s[f++];return p}}}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var n=0,r=0,i=0,o=t.length;i!==o&&0===t[i];)i++,n++;for(var s=(o-i)*u+1>>>0,l=new Uint8Array(s);i!==o;){for(var h=t[i],d=0,f=s-1;(0!==h||d<r)&&-1!==f;f--,d++)h+=256*l[f]>>>0,l[f]=h%a>>>0,h=h/a>>>0;if(0!==h)throw new Error("Non-zero carry");r=d,i++}for(var p=s-r;p!==s&&0===l[p];)p++;for(var g=c.repeat(n);p<s;++p)g+=e.charAt(l[p]);return g},decodeUnsafe:h,decode:function(e){var n=h(e);if(n)return n;throw new Error("Non-".concat(t," character"))}}};const BV=NV,LV=(new Uint8Array(0),e=>{if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")});class MV{constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return"".concat(this.prefix).concat(this.baseEncode(e));throw Error("Unknown type, must be binary type")}}class UV{constructor(e,t,n){if(this.name=e,this.prefix=t,void 0===t.codePointAt(0))throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=n}decode(e){if("string"===typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error("Unable to decode multibase string ".concat(JSON.stringify(e),", ").concat(this.name," decoder only supports inputs prefixed with ").concat(this.prefix));return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return KV(this,e)}}class FV{constructor(e){this.decoders=e}or(e){return KV(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n)return n.decode(e);throw RangeError("Unable to decode multibase string ".concat(JSON.stringify(e),", only inputs prefixed with ").concat(Object.keys(this.decoders)," are supported"))}}const KV=(e,t)=>new FV({...e.decoders||{[e.prefix]:e},...t.decoders||{[t.prefix]:t}});class jV{constructor(e,t,n,r){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=r,this.encoder=new MV(e,t,n),this.decoder=new UV(e,t,r)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const ZV=e=>{let{name:t,prefix:n,encode:r,decode:i}=e;return new jV(t,n,r,i)},zV=e=>{let{prefix:t,name:n,alphabet:r}=e;const{encode:i,decode:o}=BV(r,n);return ZV({prefix:t,name:n,encode:i,decode:e=>LV(o(e))})},VV=e=>{let{name:t,prefix:n,bitsPerChar:r,alphabet:i}=e;return ZV({prefix:n,name:t,encode:e=>((e,t,n)=>{const r="="===t[t.length-1],i=(1<<n)-1;let o="",s=0,a=0;for(let c=0;c<e.length;++c)for(a=a<<8|e[c],s+=8;s>n;)s-=n,o+=t[i&a>>s];if(s&&(o+=t[i&a<<n-s]),r)for(;o.length*n&7;)o+="=";return o})(e,i,r),decode:e=>((e,t,n,r)=>{const i={};for(let u=0;u<t.length;++u)i[t[u]]=u;let o=e.length;for(;"="===e[o-1];)--o;const s=new Uint8Array(o*n/8|0);let a=0,c=0,l=0;for(let u=0;u<o;++u){const t=i[e[u]];if(void 0===t)throw new SyntaxError("Non-".concat(r," character"));c=c<<n|t,a+=n,a>=8&&(a-=8,s[l++]=255&c>>a)}if(a>=n||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return s})(e,i,r,t)})},HV=VV({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),qV=VV({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),GV=VV({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),WV=VV({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),QV=VV({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),YV=VV({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),JV=VV({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),XV=VV({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),$V=VV({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),eH=zV({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),tH=zV({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),nH=VV({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),rH=VV({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),iH=VV({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),oH=VV({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});function sH(){return{forComponent:e=>aH(e)}}function aH(e){let t=function(e){const t=()=>{};return t.enabled=!1,t.color="",t.diff=0,t.log=()=>{},t.namespace=e,t.destroy=()=>!0,t.extend=()=>t,t}("".concat(e,":trace"));return sf().enabled("".concat(e,":trace"))&&null!=sf().names.map((e=>e.toString())).find((e=>e.includes(":trace")))&&(t=sf()("".concat(e,":trace"))),Object.assign(sf()(e),{error:sf()("".concat(e,":error")),trace:t})}sf().formatters.b=e=>null==e?"undefined":eH.baseEncode(e),sf().formatters.t=e=>null==e?"undefined":HV.baseEncode(e),sf().formatters.m=e=>null==e?"undefined":nH.baseEncode(e),sf().formatters.p=e=>null==e?"undefined":e.toString(),sf().formatters.c=e=>null==e?"undefined":e.toString(),sf().formatters.k=e=>null==e?"undefined":e.toString(),sf().formatters.a=e=>null==e?"undefined":e.toString();const cH="/",lH=(new TextEncoder).encode(cH),uH=lH[0];class hH{constructor(e,t){if((0,Yo.Z)(this,"_buf",void 0),"string"===typeof e)this._buf=(0,yu.m)(e);else{if(!(e instanceof Uint8Array))throw new Error("Invalid key, should be String of Uint8Array");this._buf=e}if(null==t&&(t=!0),t&&this.clean(),0===this._buf.byteLength||this._buf[0]!==uH)throw new Error("Invalid key")}toString(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"utf8";return(0,Au.B)(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return"Key(".concat(this.toString(),")")}static withNamespaces(e){return new hH(e.join(cH))}static random(){return new hH(function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:21;return crypto.getRandomValues(new Uint8Array(e)).reduce(((e,t)=>e+((t&=63)<36?t.toString(36):t<62?(t-26).toString(36).toUpperCase():t>62?"-":"_")),"")}().replace(/-/g,""))}static asKey(e){return e instanceof Uint8Array||"string"===typeof e?new hH(e):"function"===typeof e.uint8Array?new hH(e.uint8Array()):null}clean(){if(null!=this._buf&&0!==this._buf.byteLength||(this._buf=lH),this._buf[0]!==uH){const e=new Uint8Array(this._buf.byteLength+1);e.fill(uH,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===uH;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),n=e.list();for(let r=0;r<t.length;r++){if(n.length<r+1)return!1;const e=t[r],i=n[r];if(e<i)return!0;if(e>i)return!1}return t.length<n.length}reverse(){return hH.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(cH).slice(1)}type(){return function(e){const t=e.split(":");if(t.length<2)return"";return t.slice(0,-1).join(":")}(this.baseNamespace())}name(){return function(e){const t=e.split(":");return t[t.length-1]}(this.baseNamespace())}instance(e){return new hH(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(cH)||(e+=cH),e+=this.type(),new hH(e)}parent(){const e=this.list();return 1===e.length?new hH(cH):new hH(e.slice(0,-1).join(cH))}child(e){return this.toString()===cH?e:e.toString()===cH?this:new hH(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()!==this.toString()&&e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()!==this.toString()&&this.toString().startsWith(e.toString())}isTopLevel(){return 1===this.list().length}concat(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return hH.withNamespaces([...this.namespaces(),...(r=t.map((e=>e.namespaces())),[].concat(...r))]);var r}}const dH="SHARDING";const fH=function(e){if(null!=e[Symbol.asyncIterator])return(async()=>{for await(const t of e);})();for(const t of e);};const pH=function(e){const[t,n]=null!=e[Symbol.asyncIterator]?[e[Symbol.asyncIterator](),Symbol.asyncIterator]:[e[Symbol.iterator](),Symbol.iterator],r=[];return{peek:()=>t.next(),push:e=>{r.push(e)},next:()=>r.length>0?{done:!1,value:r.shift()}:t.next(),[n](){return this}}};const gH=function(e,t){if(null!=e[Symbol.asyncIterator])return async function*(){for await(const n of e)await t(n)&&(yield n)}();const n=pH(e),{value:r,done:i}=n.next();if(!0===i)return function*(){}();const o=t(r);if("function"===typeof o.then)return async function*(){await o&&(yield r);for await(const e of n)await t(e)&&(yield e)}();const s=t;return function*(){!0===o&&(yield r);for(const e of n)s(e)&&(yield e)}()};const yH=function(e,t){return null!=e[Symbol.asyncIterator]?async function*(){let n=0;if(!(t<1))for await(const r of e)if(yield r,n++,n===t)return}():function*(){let n=0;if(!(t<1))for(const r of e)if(yield r,n++,n===t)return}()};class mH{put(e,t,n){return Promise.reject(new Error(".put is not implemented"))}get(e,t){return Promise.reject(new Error(".get is not implemented"))}has(e,t){return Promise.reject(new Error(".has is not implemented"))}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}putMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){for await(const{key:r,value:i}of e)await t.put(r,i,n),yield r}()}catch(n){return Promise.reject(n)}}getMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){for await(const r of e)yield{key:r,value:await t.get(r,n)}}()}catch(n){return Promise.reject(n)}}deleteMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){for await(const r of e)await t.delete(r,n),yield r}()}catch(n){return Promise.reject(n)}}batch(){let e=[],t=[];return{put(t,n){e.push({key:t,value:n})},delete(e){t.push(e)},commit:async n=>{await fH(this.putMany(e,n)),e=[],await fH(this.deleteMany(t,n)),t=[]}}}async*_all(e,t){throw new Error("._all is not implemented")}async*_allKeys(e,t){throw new Error("._allKeys is not implemented")}query(e,t){let n=this._all(e,t);if(null!=e.prefix){const t=e.prefix;n=gH(n,(e=>e.key.toString().startsWith(t)))}if(Array.isArray(e.filters)&&(n=e.filters.reduce(((e,t)=>gH(e,t)),n)),Array.isArray(e.orders)&&(n=e.orders.reduce(((e,t)=>kV(e,t)),n)),null!=e.offset){let t=0;const r=e.offset;n=gH(n,(()=>t++>=r))}return null!=e.limit&&(n=yH(n,e.limit)),n}queryKeys(e,t){let n=this._allKeys(e,t);if(null!=e.prefix){const t=e.prefix;n=gH(n,(e=>e.toString().startsWith(t)))}if(Array.isArray(e.filters)&&(n=e.filters.reduce(((e,t)=>gH(e,t)),n)),Array.isArray(e.orders)&&(n=e.orders.reduce(((e,t)=>kV(e,t)),n)),null!=e.offset){const t=e.offset;let r=0;n=gH(n,(()=>r++>=t))}return null!=e.limit&&(n=yH(n,e.limit)),n}}class vH extends mH{constructor(){super(),(0,Yo.Z)(this,"data",void 0),this.data=new Map}put(e,t){return this.data.set(e.toString(),t),e}get(e){const t=this.data.get(e.toString());if(null==t)throw function(e){var t;return e=null!==(t=e)&&void 0!==t?t:new Error("Not Found"),Xo()(e,"ERR_NOT_FOUND")}();return t}has(e){return this.data.has(e.toString())}delete(e){this.data.delete(e.toString())}*_all(){for(const[e,t]of this.data.entries())yield{key:new hH(e),value:t}}*_allKeys(){for(const e of this.data.keys())yield new hH(e)}}new hH(dH);aH("datastore:core:tiered");function bH(e){return null!=e&&"function"===typeof e.start&&"function"===typeof e.stop}async function wH(){const e=[];for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];for(const i of n)bH(i)&&e.push(i);await Promise.all(e.map((async e=>{null!=e.beforeStart&&await e.beforeStart()}))),await Promise.all(e.map((async e=>{await e.start()}))),await Promise.all(e.map((async e=>{null!=e.afterStart&&await e.afterStart()})))}async function EH(){const e=[];for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];for(const i of n)bH(i)&&e.push(i);await Promise.all(e.map((async e=>{null!=e.beforeStop&&await e.beforeStop()}))),await Promise.all(e.map((async e=>{await e.stop()}))),await Promise.all(e.map((async e=>{null!=e.afterStop&&await e.afterStop()})))}class AH extends Event{constructor(e,t){super(e),this.detail=t}}function SH(e){const t=new globalThis.AbortController;function n(){t.abort();for(const t of e)null!=(null===t||void 0===t?void 0:t.removeEventListener)&&t.removeEventListener("abort",n)}for(const i of e){if(!0===(null===i||void 0===i?void 0:i.aborted)){n();break}null!=(null===i||void 0===i?void 0:i.addEventListener)&&i.addEventListener("abort",n)}const r=t.signal;return r.clear=function(){for(const t of e)null!=(null===t||void 0===t?void 0:t.removeEventListener)&&t.removeEventListener("abort",n)},r}var _H=function e(t,n,r){n=n||[];var i=r=r||0;for(;t>=TH;)n[r++]=255&t|IH,t/=128;for(;t&CH;)n[r++]=255&t|IH,t>>>=7;return n[r]=0|t,e.bytes=r-i+1,n},IH=128,CH=-128,TH=Math.pow(2,31);var kH=function e(t,n){var r,i=0,o=0,s=n=n||0,a=t.length;do{if(s>=a)throw e.bytes=0,new RangeError("Could not decode varint");r=t[s++],i+=o<28?(r&xH)<<o:(r&xH)*Math.pow(2,o),o+=7}while(r>=RH);return e.bytes=s-n,i},RH=128,xH=127;var PH=Math.pow(2,7),DH=Math.pow(2,14),OH=Math.pow(2,21),NH=Math.pow(2,28),BH=Math.pow(2,35),LH=Math.pow(2,42),MH=Math.pow(2,49),UH=Math.pow(2,56),FH=Math.pow(2,63);const KH={encode:_H,decode:kH,encodingLength:function(e){return e<PH?1:e<DH?2:e<OH?3:e<NH?4:e<BH?5:e<LH?6:e<MH?7:e<UH?8:e<FH?9:10}},jH=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return[KH.decode(e,t),KH.decode.bytes]},ZH=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return KH.encode(e,t,n),t},zH=e=>KH.encodingLength(e),VH=(e,t)=>{const n=t.byteLength,r=zH(e),i=r+zH(n),o=new Uint8Array(i+n);return ZH(e,o,0),ZH(n,o,r),o.set(t,i),new qH(e,n,t,o)},HH=e=>{const t=LV(e),[n,r]=jH(t),[i,o]=jH(t.subarray(r)),s=t.subarray(r+o);if(s.byteLength!==i)throw new Error("Incorrect length");return new qH(n,i,s,t)};class qH{constructor(e,t,n,r){this.code=e,this.size=t,this.digest=n,this.bytes=r}}const GH=(e,t)=>{const{bytes:n,version:r}=e;return 0===r?XH(n,QH(e),t||eH.encoder):$H(n,QH(e),t||HV.encoder)},WH=new WeakMap,QH=e=>{const t=WH.get(e);if(null==t){const t=new Map;return WH.set(e,t),t}return t};class YH{constructor(e,t,n,r){this.code=t,this.version=e,this.multihash=n,this.bytes=r,this["/"]=r}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==eq)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==tq)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return YH.createV0(t)}default:throw Error("Can not convert CID version ".concat(this.version," to version 0. This is a bug please report"))}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=VH(e,t);return YH.createV1(this.code,n)}case 1:return this;default:throw Error("Can not convert CID version ".concat(this.version," to version 1. This is a bug please report"))}}equals(e){return YH.equals(this,e)}static equals(e,t){const n=t;return n&&e.code===n.code&&e.version===n.version&&((e,t)=>{if(e===t)return!0;{const n=t;return e.code===n.code&&e.size===n.size&&n.bytes instanceof Uint8Array&&((e,t)=>{if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0})(e.bytes,n.bytes)}})(e.multihash,n.multihash)}toString(e){return GH(this,e)}toJSON(){return{"/":GH(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return"CID(".concat(this.toString(),")")}static asCID(e){if(null==e)return null;const t=e;if(t instanceof YH)return t;if(null!=t["/"]&&t["/"]===t.bytes||t.asCID===t){const{version:e,code:n,multihash:r,bytes:i}=t;return new YH(e,n,r,i||nq(e,n,r.bytes))}if(!0===t[rq]){const{version:e,multihash:n,code:r}=t,i=HH(n);return YH.create(e,r,i)}return null}static create(e,t,n){if("number"!==typeof t)throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:if(t!==eq)throw new Error("Version 0 CID must use dag-pb (code: ".concat(eq,") block encoding"));return new YH(e,t,n,n.bytes);case 1:{const r=nq(e,t,n.bytes);return new YH(e,t,n,r)}default:throw new Error("Invalid version")}}static createV0(e){return YH.create(0,eq,e)}static createV1(e,t){return YH.create(1,e,t)}static decode(e){const[t,n]=YH.decodeFirst(e);if(n.length)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=YH.inspectBytes(e),n=t.size-t.multihashSize,r=LV(e.subarray(n,n+t.multihashSize));if(r.byteLength!==t.multihashSize)throw new Error("Incorrect length");const i=r.subarray(t.multihashSize-t.digestSize),o=new qH(t.multihashCode,t.digestSize,i,r);return[0===t.version?YH.createV0(o):YH.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[n,r]=jH(e.subarray(t));return t+=r,n};let r=n(),i=eq;if(18===r?(r=0,t=0):i=n(),0!==r&&1!==r)throw new RangeError("Invalid CID version ".concat(r));const o=t,s=n(),a=n(),c=t+a;return{version:r,codec:i,multihashCode:s,digestSize:a,multihashSize:c-o,size:c}}static parse(e,t){const[n,r]=JH(e,t),i=YH.decode(r);if(0===i.version&&"Q"!==e[0])throw Error("Version 0 CID string must not include multibase prefix");return QH(i).set(n,e),i}}const JH=(e,t)=>{switch(e[0]){case"Q":{const n=t||eH;return[eH.prefix,n.decode("".concat(eH.prefix).concat(e))]}case eH.prefix:{const n=t||eH;return[eH.prefix,n.decode(e)]}case HV.prefix:{const n=t||HV;return[HV.prefix,n.decode(e)]}default:if(null==t)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}},XH=(e,t,n)=>{const{prefix:r}=n;if(r!==eH.prefix)throw Error("Cannot string encode V0 in ".concat(n.name," encoding"));const i=t.get(r);if(null==i){const i=n.encode(e).slice(1);return t.set(r,i),i}return i},$H=(e,t,n)=>{const{prefix:r}=n,i=t.get(r);if(null==i){const i=n.encode(e);return t.set(r,i),i}return i},eq=112,tq=18,nq=(e,t,n)=>{const r=zH(e),i=r+zH(t),o=new Uint8Array(i+n.byteLength);return ZH(e,o,0),ZH(t,o,r),o.set(n,i),o},rq=Symbol.for("@ipld/js-cid/CID");class iq extends Map{constructor(e){super(),(0,Yo.Z)(this,"metric",void 0);const{name:t,metrics:n}=e;this.metric=n.registerMetric(t),this.updateComponentMetric()}set(e,t){return super.set(e,t),this.updateComponentMetric(),this}delete(e){const t=super.delete(e);return this.updateComponentMetric(),t}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function oq(e){const{name:t,metrics:n}=e;let r;return r=null!=n?new iq({name:t,metrics:n}):new Map,r}class sq extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"The operation was aborted"),(0,Yo.Z)(this,"code",void 0),(0,Yo.Z)(this,"type",void 0),this.code=sq.code,this.type=sq.type}}(0,Yo.Z)(sq,"code","ABORT_ERR"),(0,Yo.Z)(sq,"type","aborted");class aq extends Error{constructor(e,t,n){var r;super(e),(0,Yo.Z)(this,"code",void 0),(0,Yo.Z)(this,"props",void 0),this.code=t,this.name=null!==(r=null===n||void 0===n?void 0:n.name)&&void 0!==r?r:"CodeError",this.props=null!==n&&void 0!==n?n:{}}}class cq extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"Unexpected Peer"),(0,Yo.Z)(this,"code",void 0),this.code=cq.code}}(0,Yo.Z)(cq,"code","ERR_UNEXPECTED_PEER");class lq extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"Invalid crypto exchange"),(0,Yo.Z)(this,"code",void 0),this.code=lq.code}}(0,Yo.Z)(lq,"code","ERR_INVALID_CRYPTO_EXCHANGE");class uq extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"Invalid crypto transmission"),(0,Yo.Z)(this,"code",void 0),this.code=uq.code}}(0,Yo.Z)(uq,"code","ERR_INVALID_CRYPTO_TRANSMISSION");const hq=e=>{let{name:t,code:n,encode:r}=e;return new dq(t,n,r)};class dq{constructor(e,t,n){this.name=e,this.code=t,this.encode=n}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?VH(this.code,t):t.then((e=>VH(this.code,e)))}throw Error("Unknown type, must be binary type")}}const fq=e=>async t=>new Uint8Array(await crypto.subtle.digest(e,t)),pq=hq({name:"sha2-256",code:18,encode:fq("SHA-256")}),gq=hq({name:"sha2-512",code:19,encode:fq("SHA-512")});var yq=n(29806),mq=n.n(yq);class vq{constructor(e,t,n){(0,Yo.Z)(this,"_refCounter",void 0),(0,Yo.Z)(this,"cid",void 0),(0,Yo.Z)(this,"priority",void 0),(0,Yo.Z)(this,"wantType",void 0),this._refCounter=1,this.cid=e,this.priority=null!==t&&void 0!==t?t:1,this.wantType=n}inc(){this._refCounter+=1}dec(){this._refCounter=Math.max(0,this._refCounter-1)}hasRefs(){return this._refCounter>0}get[Symbol.toStringTag](){const e=this.cid.toString(eH);return"WantlistEntry <key: ".concat(e,", priority: ").concat(this.priority,", refs: ").concat(this._refCounter,">")}equals(e){return this._refCounter===e._refCounter&&this.cid.equals(e.cid)&&this.priority===e.priority&&this.wantType===e.wantType}}class bq{constructor(e,t,n,r,i){(0,Yo.Z)(this,"entry",void 0),(0,Yo.Z)(this,"cancel",void 0),(0,Yo.Z)(this,"sendDontHave",void 0),this.entry=new vq(e,t,n),this.cancel=Boolean(r),this.sendDontHave=Boolean(i)}get cid(){return this.entry.cid}set cid(e){this.entry.cid=e}get priority(){return this.entry.priority}set priority(e){this.entry.priority=e}get wantType(){return this.entry.wantType}set wantType(e){this.entry.wantType=e}get[Symbol.toStringTag](){const e=this.cid.toString(eH);return"BitswapMessageEntry ".concat(e," <cancel: ").concat(this.cancel,", priority: ").concat(this.priority,">")}equals(e){return this.cancel===e.cancel&&this.sendDontHave===e.sendDontHave&&this.wantType===e.wantType&&this.entry.equals(e.entry)}}const wq=(e,t)=>{const n=["bitswap"];return null!=t&&n.push(t),null!=e&&n.push("".concat(e.toString().slice(0,8))),aH(n.join(":"))},Eq=(e,t)=>{if(e.size!==t.size)return!1;for(const[n,r]of e){const e=t.get(n);if(void 0===e)return!1;if(r instanceof Uint8Array&&e instanceof Uint8Array&&!(0,Ms.f)(r,e))return!1;if(r instanceof bq&&e instanceof bq&&!r.equals(e))return!1}return!0};const Aq=function(e){let t=new Uint8Array(e.reduce(((e,t)=>e+ii().encodingLength(t)),0)),n=0;for(const r of e)t=ri.encode(r,t,n),n+=ii().encodingLength(r);return t};var Sq;!function(e){let t,n,r,i,o,s;!function(t){let n,r,i,o;!function(e){e.Block="Block",e.Have="Have"}(n=t.WantType||(t.WantType={})),function(e){e[e.Block=0]="Block",e[e.Have=1]="Have"}(r||(r={})),function(e){e.codec=()=>bs(r)}(n=t.WantType||(t.WantType={})),function(t){let i;t.codec=()=>(null==i&&(i=ws((function(t,n){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==i.lengthDelimited&&n.fork(),null!=t.block&&t.block.byteLength>0&&(n.uint32(10),n.bytes(t.block)),null!=t.priority&&0!==t.priority&&(n.uint32(16),n.int32(t.priority)),null!=t.cancel&&!1!==t.cancel&&(n.uint32(24),n.bool(t.cancel)),null!=t.wantType&&0!==r[t.wantType]&&(n.uint32(32),e.Wantlist.WantType.codec().encode(t.wantType,n)),null!=t.sendDontHave&&!1!==t.sendDontHave&&(n.uint32(40),n.bool(t.sendDontHave)),!1!==i.lengthDelimited&&n.ldelim()}),((t,r)=>{const i={block:new Uint8Array(0),priority:0,cancel:!1,wantType:n.Block,sendDontHave:!1},o=null==r?t.len:t.pos+r;for(;t.pos<o;){const n=t.uint32();switch(n>>>3){case 1:i.block=t.bytes();break;case 2:i.priority=t.int32();break;case 3:i.cancel=t.bool();break;case 4:i.wantType=e.Wantlist.WantType.codec().decode(t);break;case 5:i.sendDontHave=t.bool();break;default:t.skipType(7&n)}}return i}))),i),t.encode=e=>fs(e,t.codec()),t.decode=e=>ds(e,t.codec())}(i=t.Entry||(t.Entry={})),t.codec=()=>(null==o&&(o=ws((function(t,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!1!==r.lengthDelimited&&n.fork(),null!=t.entries)for(const i of t.entries)n.uint32(10),e.Wantlist.Entry.codec().encode(i,n);null!=t.full&&!1!==t.full&&(n.uint32(16),n.bool(t.full)),!1!==r.lengthDelimited&&n.ldelim()}),((t,n)=>{const r={entries:[],full:!1},i=null==n?t.len:t.pos+n;for(;t.pos<i;){const n=t.uint32();switch(n>>>3){case 1:r.entries.push(e.Wantlist.Entry.codec().decode(t,t.uint32()));break;case 2:r.full=t.bool();break;default:t.skipType(7&n)}}return r}))),o),t.encode=e=>fs(e,t.codec()),t.decode=e=>ds(e,t.codec())}(t=e.Wantlist||(e.Wantlist={})),function(e){let t;e.codec=()=>(null==t&&(t=ws((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==n.lengthDelimited&&t.fork(),null!=e.prefix&&e.prefix.byteLength>0&&(t.uint32(10),t.bytes(e.prefix)),null!=e.data&&e.data.byteLength>0&&(t.uint32(18),t.bytes(e.data)),!1!==n.lengthDelimited&&t.ldelim()}),((e,t)=>{const n={prefix:new Uint8Array(0),data:new Uint8Array(0)},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 1:n.prefix=e.bytes();break;case 2:n.data=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(n=e.Block||(e.Block={})),function(e){e.Have="Have",e.DontHave="DontHave"}(r=e.BlockPresenceType||(e.BlockPresenceType={})),function(e){e[e.Have=0]="Have",e[e.DontHave=1]="DontHave"}(i||(i={})),function(e){e.codec=()=>bs(i)}(r=e.BlockPresenceType||(e.BlockPresenceType={})),function(t){let n;t.codec=()=>(null==n&&(n=ws((function(t,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==r.lengthDelimited&&n.fork(),null!=t.cid&&t.cid.byteLength>0&&(n.uint32(10),n.bytes(t.cid)),null!=t.type&&0!==i[t.type]&&(n.uint32(16),e.BlockPresenceType.codec().encode(t.type,n)),!1!==r.lengthDelimited&&n.ldelim()}),((t,n)=>{const i={cid:new Uint8Array(0),type:r.Have},o=null==n?t.len:t.pos+n;for(;t.pos<o;){const n=t.uint32();switch(n>>>3){case 1:i.cid=t.bytes();break;case 2:i.type=e.BlockPresenceType.codec().decode(t);break;default:t.skipType(7&n)}}return i}))),n),t.encode=e=>fs(e,t.codec()),t.decode=e=>ds(e,t.codec())}(o=e.BlockPresence||(e.BlockPresence={})),e.codec=()=>(null==s&&(s=ws((function(t,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!1!==r.lengthDelimited&&n.fork(),null!=t.wantlist&&(n.uint32(10),e.Wantlist.codec().encode(t.wantlist,n)),null!=t.blocks)for(const e of t.blocks)n.uint32(18),n.bytes(e);if(null!=t.payload)for(const i of t.payload)n.uint32(26),e.Block.codec().encode(i,n);if(null!=t.blockPresences)for(const i of t.blockPresences)n.uint32(34),e.BlockPresence.codec().encode(i,n);null!=t.pendingBytes&&0!==t.pendingBytes&&(n.uint32(40),n.int32(t.pendingBytes)),!1!==r.lengthDelimited&&n.ldelim()}),((t,n)=>{const r={blocks:[],payload:[],blockPresences:[],pendingBytes:0},i=null==n?t.len:t.pos+n;for(;t.pos<i;){const n=t.uint32();switch(n>>>3){case 1:r.wantlist=e.Wantlist.codec().decode(t,t.uint32());break;case 2:r.blocks.push(t.bytes());break;case 3:r.payload.push(e.Block.codec().decode(t,t.uint32()));break;case 4:r.blockPresences.push(e.BlockPresence.codec().decode(t,t.uint32()));break;case 5:r.pendingBytes=t.int32();break;default:t.skipType(7&n)}}return r}))),s),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(Sq||(Sq={}));class _q{constructor(e){(0,Yo.Z)(this,"full",void 0),(0,Yo.Z)(this,"wantlist",void 0),(0,Yo.Z)(this,"blocks",void 0),(0,Yo.Z)(this,"blockPresences",void 0),(0,Yo.Z)(this,"pendingBytes",void 0),this.full=e,this.wantlist=new Map,this.blocks=new Map,this.blockPresences=new Map,this.pendingBytes=0}get empty(){return 0===this.blocks.size&&0===this.wantlist.size&&0===this.blockPresences.size}addEntry(e,t,n,r,i){null==n&&(n=_q.WantType.Block);const o=e.toString(eH),s=this.wantlist.get(o);null!=s?(s.wantType===n&&(s.priority=t),!0===r&&(s.cancel=Boolean(r)),!0===i&&(s.sendDontHave=Boolean(i)),n===_q.WantType.Block&&s.wantType===_q.WantType.Have&&(s.wantType=n)):this.wantlist.set(o,new bq(e,t,n,r,i))}addBlock(e,t){const n=e.toString(eH);this.blocks.set(n,t)}addHave(e){const t=e.toString(eH);this.blockPresences.has(t)||this.blockPresences.set(t,_q.BlockPresenceType.Have)}addDontHave(e){const t=e.toString(eH);this.blockPresences.has(t)||this.blockPresences.set(t,_q.BlockPresenceType.DontHave)}cancel(e){const t=e.toString(eH);this.wantlist.delete(t),this.addEntry(e,0,_q.WantType.Block,!0,!1)}setPendingBytes(e){this.pendingBytes=e}serializeToBitswap100(){return Sq.encode({wantlist:{entries:Array.from(this.wantlist.values()).map((e=>({block:e.cid.bytes,priority:Number(e.priority),cancel:Boolean(e.cancel),wantType:Sq.Wantlist.WantType.Block,sendDontHave:!1}))),full:Boolean(this.full)},blocks:Array.from(this.blocks.values())})}serializeToBitswap110(){const e={wantlist:{entries:Array.from(this.wantlist.values()).map((e=>({block:e.cid.bytes,priority:Number(e.priority),wantType:e.wantType,cancel:Boolean(e.cancel),sendDontHave:Boolean(e.sendDontHave)}))),full:Boolean(this.full)},blockPresences:[],payload:[],pendingBytes:this.pendingBytes,blocks:[]};for(const[t,n]of this.blocks.entries()){const r=YH.parse(t),i=r.version,o=r.code,s=r.multihash.code,a=r.multihash.digest.length,c=Aq([i,o,s,a]);e.payload.push({prefix:c,data:n})}for(const[t,n]of this.blockPresences)e.blockPresences.push({cid:YH.parse(t).bytes,type:n});return this.pendingBytes>0&&(e.pendingBytes=this.pendingBytes),Sq.encode(e)}equals(e){return!!(this.full===e.full&&this.pendingBytes===e.pendingBytes&&Eq(this.wantlist,e.wantlist)&&Eq(this.blocks,e.blocks)&&Eq(this.blockPresences,e.blockPresences))}get[Symbol.toStringTag](){const e=Array.from(this.wantlist.keys()),t=Array.from(this.blocks.keys());return"BitswapMessage <full: ".concat(this.full,", list: ").concat(e,", blocks: ").concat(t,">")}}(0,Yo.Z)(_q,"Entry",bq),(0,Yo.Z)(_q,"WantType",{Block:Sq.Wantlist.WantType.Block,Have:Sq.Wantlist.WantType.Have}),(0,Yo.Z)(_q,"BlockPresenceType",{Have:Sq.BlockPresenceType.Have,DontHave:Sq.BlockPresenceType.DontHave}),(0,Yo.Z)(_q,"deserialize",(async(e,t)=>{var n,r;const i=Sq.decode(e),o=!0===(null===(n=i.wantlist)||void 0===n?void 0:n.full),s=new _q(o);return null===(r=i.wantlist)||void 0===r||r.entries.forEach((e=>{var t;if(null==e.block)return;const n=YH.decode(e.block);s.addEntry(n,null!==(t=e.priority)&&void 0!==t?t:0,e.wantType,Boolean(e.cancel),Boolean(e.sendDontHave))})),i.blockPresences.forEach((e=>{if(null==e.cid)return;const t=YH.decode(e.cid);e.type===_q.BlockPresenceType.Have?s.addHave(t):s.addDontHave(t)})),i.blocks.length>0?(await Promise.all(i.blocks.map((async e=>{const t=await pq.digest(e),n=YH.createV0(t);s.addBlock(n,e)}))),s):i.payload.length>0?(await Promise.all(i.payload.map((async e=>{if(null==e.prefix||null==e.data)return;const n=mq()(e.prefix),r=n[0],i=n[1],o=n[2],a=o===pq.code?pq:await(null===t||void 0===t?void 0:t.getHasher(o));if(null==a)throw new aq("Unknown hash algorithm","ERR_UNKNOWN_HASH_ALG");const c=await a.digest(e.data),l=YH.create(r,i,c);s.addBlock(l,e.data)}))),s.setPendingBytes(i.pendingBytes),s):s})),(0,Yo.Z)(_q,"blockPresenceSize",(e=>e.bytes.length+1));const Iq=Sq.Wantlist.WantType.Block,Cq=Sq.Wantlist.WantType.Have;class Tq{constructor(e,t){(0,Yo.Z)(this,"set",void 0),(0,Yo.Z)(this,"_stats",void 0),this.set=null!=t?oq({name:"ipfs_bitswap_wantlist",metrics:t.metrics}):new Map,this._stats=e}get length(){return this.set.size}add(e,t,n){const r=e.toString(eH),i=this.set.get(r);null!=i?(i.inc(),i.priority=t,i.wantType===Cq&&n===Iq&&(i.wantType=n)):(this.set.set(r,new vq(e,t,n)),null!=this._stats&&this._stats.push(void 0,"wantListSize",1))}remove(e){const t=e.toString(eH),n=this.set.get(t);null!=n&&(n.dec(),n.hasRefs()||(this.set.delete(t),null!=this._stats&&this._stats.push(void 0,"wantListSize",-1)))}removeForce(e){this.set.has(e)&&this.set.delete(e)}forEach(e){this.set.forEach(e)}entries(){return this.set.entries()}sortedEntries(){return new Map((e=e=>e[1].key,t=Array.from(this.set.entries()),Array.prototype.slice.call(t,0).sort(((t,n)=>{const r=e(t),i=e(n);return r<i?-1:r>i?1:0}))));var e,t}contains(e){const t=e.toString(eH);return this.set.has(t)}get(e){const t=e.toString(eH);return this.set.get(t)}}(0,Yo.Z)(Tq,"Entry",vq);class kq{constructor(e){(0,Yo.Z)(this,"partner",void 0),(0,Yo.Z)(this,"wantlist",void 0),(0,Yo.Z)(this,"exchangeCount",void 0),(0,Yo.Z)(this,"accounting",void 0),(0,Yo.Z)(this,"lastExchange",void 0),this.partner=e,this.wantlist=new Tq,this.exchangeCount=0,this.accounting={bytesSent:0,bytesRecv:0}}sentBytes(e){this.exchangeCount++,this.lastExchange=(new Date).getTime(),this.accounting.bytesSent+=e}receivedBytes(e){this.exchangeCount++,this.lastExchange=(new Date).getTime(),this.accounting.bytesRecv+=e}wants(e,t,n){this.wantlist.add(e,t,n)}cancelWant(e){this.wantlist.remove(e)}wantlistContains(e){return this.wantlist.get(e)}debtRatio(){return this.accounting.bytesSent/(this.accounting.bytesRecv+1)}}class Rq extends Map{constructor(e,t){super(),(0,Yo.Z)(this,"_cmp",void 0),(0,Yo.Z)(this,"_keys",void 0),this._cmp=null!==t&&void 0!==t?t:this._defaultSort,this._keys=[];for(const[n,r]of null!==e&&void 0!==e?e:[])this.set(n,r)}update(e){if(e<0||e>=this._keys.length)return;const t=this._keys[e];this._keys.splice(e,1);const n=this._find(t);this._keys.splice(n,0,t)}set(e,t){if(this.has(e)){const t=this.indexOf(e);this._keys.splice(t,1)}super.set(e,t);const n=this._find(e);return this._keys.splice(n,0,e),this}clear(){super.clear(),this._keys=[]}delete(e){if(!this.has(e))return!1;const t=this.indexOf(e);return this._keys.splice(t,1),super.delete(e)}indexOf(e){if(!this.has(e))return-1;const t=this._find(e);if(this._keys[t]===e)return t;for(let n=1;n<this._keys.length;n++){if(this._keys[t+n]===e)return t+n;if(this._keys[t-n]===e)return t-n}return-1}_find(e){let t=0,n=this._keys.length;for(;t<n;){const r=t+n>>>1,i=this._kCmp(this._keys[r],e);if(i<0)t=r+1;else{if(!(i>0))return r;n=r}}return t}*keys(){for(const e of this._keys)yield e}*values(){for(const e of this._keys)yield this.get(e)}*entries(){for(const e of this._keys)yield[e,this.get(e)]}*[Symbol.iterator](){yield*this.entries()}forEach(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this;if(null!=e)for(const n of this._keys){const r=this.get(n);if(null==r)throw new Error("Value cannot be undefined");e.apply(t,[[n,r]])}}_defaultSort(e,t){return e[0]<t[0]?-1:t[0]<e[0]?1:0}_kCmp(e,t){return this._cmp([e,this.get(e)],[t,this.get(t)])}}const xq={hasNewInfo:()=>!1,merge(){}};class Pq{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:xq;(0,Yo.Z)(this,"_taskMerger",void 0),(0,Yo.Z)(this,"_byPeer",void 0),this._taskMerger=e,this._byPeer=new Rq([],Dq.compare)}pushTasks(e,t){let n=this._byPeer.get(e.toString());null==n&&(n=new Dq(e,this._taskMerger)),n.pushTasks(t),this._byPeer.set(e.toString(),n)}popTasks(e){const t=this._head();if(void 0===t)return{tasks:[],pendingSize:0};const{tasks:n,pendingSize:r}=t.popTasks(e);if(0===n.length)return{tasks:n,pendingSize:r};const i=t.peerId;return t.isIdle()?this._byPeer.delete(i.toString()):this._byPeer.update(0),{peerId:i,tasks:n,pendingSize:r}}_head(){if(0!==this._byPeer.size)for(const[,e]of this._byPeer)return e}remove(e,t){const n=this._byPeer.get(t.toString());null===n||void 0===n||n.remove(e)}tasksDone(e,t){const n=this._byPeer.get(e.toString());if(null==n)return;const r=this._byPeer.indexOf(e.toString());for(const i of t)n.taskDone(i);this._byPeer.update(r)}}class Dq{constructor(e,t){(0,Yo.Z)(this,"peerId",void 0),(0,Yo.Z)(this,"_taskMerger",void 0),(0,Yo.Z)(this,"_activeTotalSize",void 0),(0,Yo.Z)(this,"_pending",void 0),(0,Yo.Z)(this,"_active",void 0),this.peerId=e,this._taskMerger=t,this._activeTotalSize=0,this._pending=new Oq,this._active=new Set}pushTasks(e){for(const t of e)this._pushTask(t)}_pushTask(e){if(!this._taskHasMoreInfoThanActiveTasks(e))return;const t=this._pending.get(e.topic);if(null!=t)return e.priority>t.priority&&this._pending.updatePriority(e.topic,e.priority),void this._taskMerger.merge(e,t);this._pending.add(e)}_taskHasMoreInfoThanActiveTasks(e){const t=[];for(const n of this._active)n.topic===e.topic&&t.push(n);return 0===t.length||this._taskMerger.hasNewInfo(e,t)}popTasks(e){let t=0;const n=[],r=this._pending.tasks();for(let i=0;i<r.length&&t<e;i++){const e=r[i];n.push(e),t+=e.size,this._pending.delete(e.topic),this._activeTotalSize+=e.size,this._active.add(e)}return{tasks:n,pendingSize:this._pending.totalSize}}taskDone(e){this._active.has(e)&&(this._activeTotalSize-=e.size,this._active.delete(e))}remove(e){this._pending.delete(e)}isIdle(){return 0===this._pending.length&&0===this._active.size}static compare(e,t){return 0===e[1]._pending.length?1:0===t[1]._pending.length?-1:e[1]._activeTotalSize===t[1]._activeTotalSize?t[1]._pending.length-e[1]._pending.length:e[1]._activeTotalSize-t[1]._activeTotalSize}}class Oq{constructor(){(0,Yo.Z)(this,"_tasks",void 0),this._tasks=new Rq([],this._compare)}get length(){return this._tasks.size}get totalSize(){return[...this._tasks.values()].reduce(((e,t)=>e+t.task.size),0)}get(e){var t,n;return null===(t=this._tasks)||void 0===t||null===(n=t.get(e))||void 0===n?void 0:n.task}add(e){this._tasks.set(e.topic,{created:Date.now(),task:e})}delete(e){this._tasks.delete(e)}tasks(){return[...this._tasks.values()].map((e=>e.task))}updatePriority(e,t){const n=this._tasks.get(e);if(null==n)return;const r=this._tasks.indexOf(e);n.task.priority=t,this._tasks.update(r)}_compare(e,t){return e[1].task.priority===t[1].task.priority?e[1].created-t[1].created:t[1].task.priority-e[1].task.priority}}const Nq={hasNewInfo(e,t){let n=!1,r=!1;for(const i of t)i.data.haveBlock&&(n=!0),i.data.isWantBlock&&(r=!0);return!(r||!e.data.isWantBlock)||!(n||!e.data.haveBlock)},merge(e,t){const n=e.data,r=t.data;!r.haveBlock&&n.haveBlock&&(r.haveBlock=n.haveBlock,r.blockSize=n.blockSize),!r.isWantBlock&&n.isWantBlock&&(r.isWantBlock=!0,r.haveBlock&&!n.haveBlock||(r.haveBlock=n.haveBlock,t.size=e.size)),r.isWantBlock&&r.haveBlock&&(t.size=r.blockSize)}},Bq=_q.WantType;class Lq{constructor(e,t,n,r,i){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};(0,Yo.Z)(this,"_log",void 0),(0,Yo.Z)(this,"blockstore",void 0),(0,Yo.Z)(this,"network",void 0),(0,Yo.Z)(this,"_stats",void 0),(0,Yo.Z)(this,"_opts",void 0),(0,Yo.Z)(this,"ledgerMap",void 0),(0,Yo.Z)(this,"_running",void 0),(0,Yo.Z)(this,"_requestQueue",void 0),this._log=wq(e,"engine"),this.blockstore=t,this.network=n,this._stats=r,this._opts=this._processOpts(o),this.ledgerMap=oq({name:"ipfs_bitswap_ledger_map",metrics:i.metrics}),this._running=!1,this._requestQueue=new Pq(Nq)}_processOpts(e){return{maxSizeReplaceHasWithBlock:1024,targetMessageSize:16384,...e}}_scheduleProcessTasks(){setTimeout((()=>{this._processTasks().catch((e=>{this._log.error("error processing stats",e)}))}))}async _processTasks(){if(!this._running)return;const{peerId:e,tasks:t,pendingSize:n}=this._requestQueue.popTasks(this._opts.targetMessageSize);if(0===t.length)return;const r=new _q(!1);r.setPendingBytes(n);const i=[],o=new Map;for(const c of t){const e=YH.parse(c.topic);c.data.haveBlock?c.data.isWantBlock?(i.push(e),o.set(c.topic,c.data)):r.addHave(e):r.addDontHave(e)}const s=await this._getBlocks(i);for(const[c,l]of o){const e=YH.parse(c),t=s.get(c);null!=t?r.addBlock(e,t):l.sendDontHave&&r.addDontHave(e)}if(r.empty)return null!=e&&this._requestQueue.tasksDone(e,t),void this._scheduleProcessTasks();try{null!=e&&await this.network.sendMessage(e,r);for(const[t,n]of s.entries())null!=e&&this.messageSent(e,YH.parse(t),n)}catch(a){this._log.error(a)}null!=e&&this._requestQueue.tasksDone(e,t),this._scheduleProcessTasks()}wantlistForPeer(e){const t=e.toString(),n=this.ledgerMap.get(t);return null!=n?n.wantlist.sortedEntries():new Map}ledgerForPeer(e){const t=e.toString(),n=this.ledgerMap.get(t);if(null!=n)return{peer:n.partner,value:n.debtRatio(),sent:n.accounting.bytesSent,recv:n.accounting.bytesRecv,exchanged:n.exchangeCount}}peers(){return Array.from(this.ledgerMap.values()).map((e=>e.partner))}receivedBlocks(e){if(0!==e.length){for(const t of this.ledgerMap.values())for(const{cid:n,block:r}of e){const e=t.wantlistContains(n);if(null==e)continue;const i=r.length,o=this._sendAsBlock(e.wantType,i);let s=i;o||(s=_q.blockPresenceSize(e.cid)),this._requestQueue.pushTasks(t.partner,[{topic:e.cid.toString(eH),priority:e.priority,size:s,data:{blockSize:i,isWantBlock:o,haveBlock:!0,sendDontHave:!1}}])}this._scheduleProcessTasks()}}async messageReceived(e,t){const n=this._findOrCreate(e);if(t.empty)return;if(t.full&&(n.wantlist=new Tq),this._updateBlockAccounting(t.blocks,n),0===t.wantlist.size)return void this._scheduleProcessTasks();const r=[],i=[];t.wantlist.forEach((e=>{e.cancel?(n.cancelWant(e.cid),r.push(e.cid)):(n.wants(e.cid,e.priority,e.wantType),i.push(e))})),this._cancelWants(e,r),await this._addWants(e,i),this._scheduleProcessTasks()}_cancelWants(e,t){for(const n of t)this._requestQueue.remove(n.toString(eH),e)}async _addWants(e,t){const n=await this._getBlockSizes(t.map((e=>e.cid))),r=[];for(const i of t){const t=i.cid.toString(eH),o=n.get(t);if(null==o)i.sendDontHave&&r.push({topic:t,priority:i.priority,size:_q.blockPresenceSize(i.cid),data:{isWantBlock:i.wantType===Bq.Block,blockSize:0,haveBlock:!1,sendDontHave:i.sendDontHave}});else{const e=this._sendAsBlock(i.wantType,o);let n=o;e||(n=_q.blockPresenceSize(i.cid)),r.push({topic:t,priority:i.priority,size:n,data:{isWantBlock:e,blockSize:o,haveBlock:!0,sendDontHave:i.sendDontHave}})}this._requestQueue.pushTasks(e,r)}}_sendAsBlock(e,t){return e===Bq.Block||t<=this._opts.maxSizeReplaceHasWithBlock}async _getBlockSizes(e){const t=await this._getBlocks(e);return new Map([...t].map((e=>{let[t,n]=e;return[t,n.length]})))}async _getBlocks(e){const t=new Map;return await Promise.all(e.map((async e=>{try{const n=await this.blockstore.get(e);t.set(e.toString(eH),n)}catch(n){"ERR_NOT_FOUND"!==n.code&&this._log.error("failed to query blockstore for %s: %s",e,n)}}))),t}_updateBlockAccounting(e,t){for(const n of e.values())this._log("got block (%s bytes)",n.length),t.receivedBytes(n.length)}messageSent(e,t,n){const r=this._findOrCreate(e);r.sentBytes(n.length),r.wantlist.remove(t)}numBytesSentTo(e){return this._findOrCreate(e).accounting.bytesSent}numBytesReceivedFrom(e){return this._findOrCreate(e).accounting.bytesRecv}peerDisconnected(e){this.ledgerMap.delete(e.toString())}_findOrCreate(e){const t=e.toString(),n=this.ledgerMap.get(t);if(null!=n)return n;const r=new kq(e);return this.ledgerMap.set(t,r),null!=this._stats&&this._stats.push(t,"peerCount",1),r}start(){this._running=!0}stop(){this._running=!1}}function Mq(e){return null!=e[Symbol.asyncIterator]}const Uq=e=>{const t=Bs.P$(e),n=(0,Us.E)(t);return Bs.cv(e,n),Uq.bytes=t,n};function Fq(e,t){var n,r;const i=null!==(r=(t=null!==(n=t)&&void 0!==n?n:{}).lengthEncoder)&&void 0!==r?r:Uq;function*o(e){const t=i(e.byteLength);t instanceof Uint8Array?yield t:yield*t,e instanceof Uint8Array?yield e:yield*e}return Mq(e)?async function*(){for await(const t of e)yield*o(t)}():function*(){for(const t of e)yield*o(t)}()}Uq.bytes=0,Fq.single=(e,t)=>{var n,r;const i=null!==(r=(t=null!==(n=t)&&void 0!==n?n:{}).lengthEncoder)&&void 0!==r?r:Uq;return new Zs(i(e.byteLength),e)};var Kq;!function(e){e[e.LENGTH=0]="LENGTH",e[e.DATA=1]="DATA"}(Kq||(Kq={}));const jq=e=>{const t=Bs.Jx(e);return jq.bytes=Bs.P$(t),t};function Zq(e,t){var n,r,i;const o=new Zs;let s=Kq.LENGTH,a=-1;const c=null!==(n=null===t||void 0===t?void 0:t.lengthDecoder)&&void 0!==n?n:jq,l=null!==(r=null===t||void 0===t?void 0:t.maxLengthLength)&&void 0!==r?r:8,u=null!==(i=null===t||void 0===t?void 0:t.maxDataLength)&&void 0!==i?i:4194304;function*h(){for(;o.byteLength>0;){if(s===Kq.LENGTH)try{if(a=c(o),a<0)throw Xo()(new Error("invalid message length"),"ERR_INVALID_MSG_LENGTH");if(a>u)throw Xo()(new Error("message length too long"),"ERR_MSG_DATA_TOO_LONG");const e=c.bytes;o.consume(e),null!=(null===t||void 0===t?void 0:t.onLength)&&t.onLength(a),s=Kq.DATA}catch(e){if(e instanceof RangeError){if(o.byteLength>l)throw Xo()(new Error("message length length too long"),"ERR_MSG_LENGTH_TOO_LONG");break}throw e}if(s===Kq.DATA){if(o.byteLength<a)break;const e=o.sublist(0,a);o.consume(a),null!=(null===t||void 0===t?void 0:t.onData)&&t.onData(e),yield e,s=Kq.LENGTH}}}return Mq(e)?async function*(){for await(const t of e)o.append(t),yield*h();if(o.byteLength>0)throw Xo()(new Error("unexpected end of input"),"ERR_UNEXPECTED_EOF")}():function*(){for(const t of e)o.append(t),yield*h();if(o.byteLength>0)throw Xo()(new Error("unexpected end of input"),"ERR_UNEXPECTED_EOF")}()}jq.bytes=0,Zq.fromReader=(e,t)=>{let n=1;return Zq(async function*(){for(;;)try{const{done:t,value:r}=await e.next(n);if(!0===t)return;null!=r&&(yield r)}catch(t){if("ERR_UNDER_READ"===t.code)return{done:!0,value:null};throw t}finally{n=1}}(),{...null!==t&&void 0!==t?t:{},onLength:e=>{n=e}})};const zq=function(e,t){if(null!=e[Symbol.asyncIterator])return async function*(){for await(const n of e)yield t(n)}();const n=pH(e),{value:r,done:i}=n.next();if(!0===i)return function*(){}();const o=t(r);if("function"===typeof o.then)return async function*(){yield await o;for await(const e of n)yield t(e)}();const s=t;return function*(){yield o;for(const e of n)yield s(e)}()};class Vq{constructor(e){if((0,Yo.Z)(this,"buffer",void 0),(0,Yo.Z)(this,"mask",void 0),(0,Yo.Z)(this,"top",void 0),(0,Yo.Z)(this,"btm",void 0),(0,Yo.Z)(this,"next",void 0),!(e>0)||0!==(e-1&e))throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return void 0===this.buffer[this.top]&&(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){const e=this.buffer[this.btm];if(void 0!==e)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return void 0===this.buffer[this.btm]}}class Hq{constructor(){var e;let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};(0,Yo.Z)(this,"size",void 0),(0,Yo.Z)(this,"hwm",void 0),(0,Yo.Z)(this,"head",void 0),(0,Yo.Z)(this,"tail",void 0),this.hwm=null!==(e=t.splitLimit)&&void 0!==e?e:16,this.head=new Vq(this.hwm),this.tail=this.head,this.size=0}calculateSize(e){return null!=(null===e||void 0===e?void 0:e.byteLength)?e.byteLength:1}push(e){if(null!=(null===e||void 0===e?void 0:e.value)&&(this.size+=this.calculateSize(e.value)),!this.head.push(e)){const t=this.head;this.head=t.next=new Vq(2*this.head.buffer.length),this.head.push(e)}}shift(){var e;let t=this.tail.shift();if(void 0===t&&null!=this.tail.next){const e=this.tail.next;this.tail.next=null,this.tail=e,t=this.tail.shift()}return null!=(null===(e=t)||void 0===e?void 0:e.value)&&(this.size-=this.calculateSize(t.value)),t}isEmpty(){return this.head.isEmpty()}}class qq extends Error{constructor(e,t){super(null!==e&&void 0!==e?e:"The operation was aborted"),(0,Yo.Z)(this,"type",void 0),(0,Yo.Z)(this,"code",void 0),this.type="aborted",this.code=null!==t&&void 0!==t?t:"ABORT_ERR"}}function Gq(){return Wq((e=>{const t=e.shift();if(null==t)return{done:!0};if(null!=t.error)throw t.error;return{done:!0===t.done,value:t.value}}),arguments.length>0&&void 0!==arguments[0]?arguments[0]:{})}function Wq(e,t){var n;let r,i,o,s=(t=null!==(n=t)&&void 0!==n?n:{}).onEnd,a=new Hq,c=Ws();const l=e=>null!=i?i(e):(a.push(e),r),u=e=>{var n;if(o)return r;if(!0!==(null===(n=t)||void 0===n?void 0:n.objectMode)&&null==(null===e||void 0===e?void 0:e.byteLength))throw new Error("objectMode was not true but tried to push non-Uint8Array value");return l({done:!1,value:e})},h=e=>o?r:(o=!0,null!=e?(e=>(a=new Hq,null!=i?i({error:e}):(a.push({error:e}),r)))(e):l({done:!0}));if(r={[Symbol.asyncIterator](){return this},next:async()=>{try{return a.isEmpty()?o?{done:!0}:await new Promise(((t,n)=>{i=o=>{i=null,a.push(o);try{t(e(a))}catch(s){n(s)}return r}})):e(a)}finally{a.isEmpty()&&queueMicrotask((()=>{c.resolve(),c=Ws()}))}},return:()=>(a=new Hq,h(),{done:!0}),throw:e=>(h(e),{done:!0}),push:u,end:h,get readableLength(){return a.size},onEmpty:async e=>{const t=null===e||void 0===e?void 0:e.signal;if(null===t||void 0===t||t.throwIfAborted(),a.isEmpty())return;let n,r;null!=t&&(n=new Promise(((e,n)=>{r=()=>{n(new qq)},t.addEventListener("abort",r)})));try{await Promise.race([c.promise,n])}finally{null!=r&&null!=t&&(null===t||void 0===t||t.removeEventListener("abort",r))}}},null==s)return r;const d=r;return r={[Symbol.asyncIterator](){return this},next:()=>d.next(),throw:e=>(d.throw(e),null!=s&&(s(e),s=void 0),{done:!0}),return:()=>(d.return(),null!=s&&(s(),s=void 0),{done:!0}),push:u,end:e=>(d.end(e),null!=s&&(s(e),s=void 0),r),get readableLength(){return d.readableLength},onEmpty:e=>d.onEmpty(e)},r}const Qq=function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];const r=[];for(const i of t)null==i[Symbol.asyncIterator]&&r.push(i);return r.length===t.length?function*(){for(const e of r)yield*e}():async function*(){const e=Gq({objectMode:!0});Promise.resolve().then((async()=>{try{await Promise.all(t.map((async t=>{for await(const n of t)e.push(n)}))),e.end()}catch(n){e.end(n)}})),yield*e}()};function Yq(e){if(null==e)throw new Error("Empty pipeline");if(eG(e)){const t=e;e=()=>t.source}else if($q(e)||Xq(e)){const t=e;e=()=>t}for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const i=[e,...n];if(i.length>1&&eG(i[i.length-1])&&(i[i.length-1]=i[i.length-1].sink),i.length>2)for(let o=1;o<i.length-1;o++)eG(i[o])&&(i[o]=tG(i[o]));return Jq(...i)}const Jq=function(){let e;for(var t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];for(;n.length>0;)e=n.shift()(e);return e},Xq=e=>null!=(null===e||void 0===e?void 0:e[Symbol.asyncIterator]),$q=e=>null!=(null===e||void 0===e?void 0:e[Symbol.iterator]),eG=e=>null!=e&&(null!=e.sink&&null!=e.source),tG=e=>t=>{const n=e.sink(t);if(null!=(null===n||void 0===n?void 0:n.then)){const t=Gq({objectMode:!0});let r;n.then((()=>{t.end()}),(e=>{t.end(e)}));const i=e.source;if(Xq(i))r=async function*(){yield*i,t.end()};else{if(!$q(i))throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");r=function*(){yield*i,t.end()}}return Qq(t,r())}return e.source};var nG=n(68363);const rG=Math.pow(2,31)-1,iG="/ipfs/bitswap/1.0.0",oG="/ipfs/bitswap/1.1.0",sG="/ipfs/bitswap/1.2.0";class aG{constructor(e,t,n){var r,i,o,s;let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};(0,Yo.Z)(this,"_log",void 0),(0,Yo.Z)(this,"_libp2p",void 0),(0,Yo.Z)(this,"_bitswap",void 0),(0,Yo.Z)(this,"_protocols",void 0),(0,Yo.Z)(this,"_stats",void 0),(0,Yo.Z)(this,"_running",void 0),(0,Yo.Z)(this,"_hashLoader",void 0),(0,Yo.Z)(this,"_maxInboundStreams",void 0),(0,Yo.Z)(this,"_maxOutboundStreams",void 0),(0,Yo.Z)(this,"_incomingStreamTimeout",void 0),(0,Yo.Z)(this,"_registrarIds",void 0),this._log=wq(e.peerId,"network"),this._libp2p=e,this._bitswap=t,this._protocols=[iG],!0!==a.b100Only&&(this._protocols.unshift(oG),this._protocols.unshift(sG)),this._stats=n,this._running=!1,this._onPeerConnect=this._onPeerConnect.bind(this),this._onPeerDisconnect=this._onPeerDisconnect.bind(this),this._onConnection=this._onConnection.bind(this),this._hashLoader=null!==(r=a.hashLoader)&&void 0!==r?r:{async getHasher(){throw new Error("Not implemented")}},this._maxInboundStreams=null!==(i=a.maxInboundStreams)&&void 0!==i?i:1024,this._maxOutboundStreams=null!==(o=a.maxOutboundStreams)&&void 0!==o?o:1024,this._incomingStreamTimeout=null!==(s=a.incomingStreamTimeout)&&void 0!==s?s:3e4}async start(){this._running=!0,await this._libp2p.handle(this._protocols,this._onConnection,{maxInboundStreams:this._maxInboundStreams,maxOutboundStreams:this._maxOutboundStreams});const e={onConnect:this._onPeerConnect,onDisconnect:this._onPeerDisconnect};this._registrarIds=[];for(const t of this._protocols)this._registrarIds.push(await this._libp2p.register(t,e));this._libp2p.getConnections().forEach((e=>{this._onPeerConnect(e.remotePeer)}))}async stop(){if(this._running=!1,await this._libp2p.unhandle(this._protocols),null!=this._registrarIds){for(const e of this._registrarIds)this._libp2p.unregister(e);this._registrarIds=[]}}_onConnection(e){if(!this._running)return;const{stream:t,connection:n}=e,r=new nG.TimeoutController(this._incomingStreamTimeout);Promise.resolve().then((async()=>{this._log("incoming new bitswap %s connection from %p",t.protocol,n.remotePeer);const e=()=>{t.abort(new aq("Incoming Bitswap stream timed out","ERR_TIMEOUT"))};let r=AbortSignal.timeout(this._incomingStreamTimeout);r.addEventListener("abort",e),await Yq(t,(e=>Zq(e)),(async t=>{for await(const o of t){try{const e=await _q.deserialize(o.subarray(),this._hashLoader);await this._bitswap._receiveMessage(n.remotePeer,e)}catch(i){this._bitswap._receiveError(i);break}r.removeEventListener("abort",e),r=AbortSignal.timeout(this._incomingStreamTimeout),r.addEventListener("abort",e)}})),await t.close({signal:r})})).catch((e=>{this._log(e),t.abort(e)})).finally((()=>{r.clear()}))}_onPeerConnect(e){this._bitswap._onPeerConnected(e)}_onPeerDisconnect(e){this._bitswap._onPeerDisconnected(e)}findProviders(e){var t;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null===(t=n.onProgress)||void 0===t||t.call(n,new AH("bitswap:network:find-providers",e)),this._libp2p.contentRouting.findProviders(e,n)}async findAndConnect(e,t){await fH(yH(zq(this.findProviders(e,t),(async e=>this.connectTo(e.id,t).catch((e=>{this._log.error(e)})))),3)).catch((e=>{this._log.error(e)}))}async provide(e){var t;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};null===(t=n.onProgress)||void 0===t||t.call(n,new AH("bitswap:network:provide",e)),await this._libp2p.contentRouting.provide(e,n)}async sendMessage(e,t){var n;let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this._running)throw new Error("network isn't running");const i=e.toString();this._log("sendMessage to %s",i,t),null===(n=r.onProgress)||void 0===n||n.call(r,new AH("bitswap:network:send-wantlist",e)),await this._writeMessage(e,t,r),this._updateSentStats(e,t.blocks)}async connectTo(e){var t;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!this._running)throw new Error("network isn't running");return null===(t=n.onProgress)||void 0===t||t.call(n,new AH("bitswap:network:dial",e)),this._libp2p.dial(e,n)}_updateSentStats(e,t){const n=e.toString();if(null!=this._stats){for(const e of t.values())this._stats.push(n,"dataSent",e.length);this._stats.push(n,"blocksSent",t.size)}}async _writeMessage(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=await this._libp2p.dialProtocol(e,[sG,oG,iG]);try{let e;switch(r.protocol){case iG:e=t.serializeToBitswap100();break;case oG:case sG:e=t.serializeToBitswap110();break;default:throw new Error("Unknown protocol: ".concat(r.protocol))}await Yq([e],(e=>Fq(e)),r),await r.close()}catch(o){var i;null===(i=n.onProgress)||void 0===i||i.call(n,new AH("bitswap:network:send-wantlist:error",{peer:e,error:o})),this._log(o),r.abort(o)}}}var cG=n(47465);const lG=e=>"unwant:".concat((0,Au.B)(e.multihash.bytes,"base64")),uG=e=>"block:".concat((0,Au.B)(e.multihash.bytes,"base64"));class hG extends cG.EventEmitter{constructor(e){super(),(0,Yo.Z)(this,"_log",void 0),this.setMaxListeners(1e3),this._log=wq(e,"notif")}hasBlock(e,t){const n=uG(e);this._log(n),this.emit(n,t)}async wantBlock(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(null==e)throw new Error("Not a valid cid");const n=uG(e),r=lG(e);return this._log("wantBlock:".concat(e)),new Promise(((i,o)=>{var s;const a=()=>{var r;this.removeListener(n,c),null===(r=t.onProgress)||void 0===r||r.call(t,new AH("bitswap:want-block:unwant",e)),o(new Error("Block for ".concat(e," unwanted")))},c=n=>{var o;this.removeListener(r,a),null===(o=t.onProgress)||void 0===o||o.call(t,new AH("bitswap:want-block:block",e)),i(n)};this.once(r,a),this.once(n,c),null===(s=t.signal)||void 0===s||s.addEventListener("abort",(()=>{this.removeListener(n,c),this.removeListener(r,a),o(new Error("Want for ".concat(e," aborted")))}))}))}unwantBlock(e){const t=lG(e);this._log(t),this.emit(t)}}var dG=n(56755),fG=n.n(dG);class pG extends cG.EventEmitter{constructor(e,t){super(),(0,Yo.Z)(this,"_options",void 0),(0,Yo.Z)(this,"_queue",void 0),(0,Yo.Z)(this,"_stats",void 0),(0,Yo.Z)(this,"_frequencyLastTime",void 0),(0,Yo.Z)(this,"_frequencyAccumulators",void 0),(0,Yo.Z)(this,"_movingAverages",void 0),(0,Yo.Z)(this,"_enabled",void 0),(0,Yo.Z)(this,"_timeout",void 0),this._options=t,this._queue=[],this._stats={},this._frequencyLastTime=Date.now(),this._frequencyAccumulators={},this._movingAverages={},this._update=this._update.bind(this),e.forEach((e=>{this._stats[e]=BigInt(0),this._movingAverages[e]={},this._options.movingAverageIntervals.forEach((t=>{(this._movingAverages[e][t]=fG()(t)).push(this._frequencyLastTime,0)}))})),this._enabled=this._options.enabled}enable(){this._enabled=!0}disable(){this._enabled=!1}stop(){null!=this._timeout&&clearTimeout(this._timeout)}get snapshot(){return Object.assign({},this._stats)}get movingAverages(){return Object.assign({},this._movingAverages)}push(e,t){this._enabled&&(this._queue.push([e,t,Date.now()]),this._resetComputeTimeout())}_resetComputeTimeout(){null!=this._timeout&&clearTimeout(this._timeout),this._timeout=setTimeout(this._update,this._nextTimeout())}_nextTimeout(){const e=this._queue.length/this._options.computeThrottleMaxQueueSize;return Math.max(this._options.computeThrottleTimeout*(1-e),0)}_update(){if(this._timeout=void 0,this._queue.length>0){let e;for(;this._queue.length>0;){const t=e=this._queue.shift();null!=t&&this._applyOp(t)}null!=e&&this._updateFrequency(e[2]),this.emit("update",this._stats)}}_updateFrequency(e){const t=e-this._frequencyLastTime;t>0&&Object.keys(this._stats).forEach((n=>{this._updateFrequencyFor(n,t,e)})),this._frequencyLastTime=e}_updateFrequencyFor(e,t,n){var r;const i=null!==(r=this._frequencyAccumulators[e])&&void 0!==r?r:0;this._frequencyAccumulators[e]=0;const o=i/t*1e3;let s=this._movingAverages[e];null==s&&(s=this._movingAverages[e]={}),this._options.movingAverageIntervals.forEach((e=>{let t=s[e];null==t&&(t=s[e]=fG()(e)),t.push(n,o)}))}_applyOp(e){const t=e[0],n=e[1];if("number"!==typeof n)throw new Error("invalid increment number: ".concat(n));Object.prototype.hasOwnProperty.call(this._stats,t)||(this._stats[t]=BigInt(0)),this._stats[t]=BigInt(this._stats[t])+BigInt(n),null==this._frequencyAccumulators[t]&&(this._frequencyAccumulators[t]=0),this._frequencyAccumulators[t]+=n}}const gG={enabled:!1,computeThrottleTimeout:1e3,computeThrottleMaxQueueSize:1e3,movingAverageIntervals:[6e4,3e5,9e5]};class yG extends cG.EventEmitter{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:gG;super(),(0,Yo.Z)(this,"_initialCounters",void 0),(0,Yo.Z)(this,"_options",void 0),(0,Yo.Z)(this,"_enabled",void 0),(0,Yo.Z)(this,"_global",void 0),(0,Yo.Z)(this,"_peers",void 0);const r=Object.assign({},gG,n);if("number"!==typeof r.computeThrottleTimeout)throw new Error("need computeThrottleTimeout");if("number"!==typeof r.computeThrottleMaxQueueSize)throw new Error("need computeThrottleMaxQueueSize");this._initialCounters=t,this._options=r,this._enabled=this._options.enabled,this._global=new pG(t,r),this._global.on("update",(e=>this.emit("update",e))),this._peers=oq({name:"ipfs_bitswap_stats_peers",metrics:e.metrics})}enable(){this._enabled=!0,this._options.enabled=!0,this._global.enable()}disable(){this._enabled=!1,this._options.enabled=!1,this._global.disable()}stop(){this._enabled=!1,this._global.stop();for(const e of this._peers)e[1].stop()}get snapshot(){return this._global.snapshot}get movingAverages(){return this._global.movingAverages}forPeer(e){const t=e.toString();return this._peers.get(t)}push(e,t,n){if(this._enabled&&(this._global.push(t,n),null!=e)){let r=this._peers.get(e);null==r&&(r=new pG(this._initialCounters,this._options),this._peers.set(e,r)),r.push(t,n)}}disconnected(e){const t=e.toString(),n=this._peers.get(t);null!=n&&(n.stop(),this._peers.delete(t))}}var mG=function(e,t,n){var r=null,i=null,o=function(){r&&(clearTimeout(r),i=null,r=null)},s=function(){if(!t)return e.apply(this,arguments);var s=this,a=arguments,c=n&&!r;return o(),i=function(){e.apply(s,a)},r=setTimeout((function(){if(r=null,!c){var e=i;return i=null,e()}}),t),c?i():void 0};return s.cancel=o,s.flush=function(){var e=i;o(),e&&e()},s};class vG{constructor(e,t,n){(0,Yo.Z)(this,"peerId",void 0),(0,Yo.Z)(this,"refcnt",void 0),(0,Yo.Z)(this,"network",void 0),(0,Yo.Z)(this,"_entries",void 0),(0,Yo.Z)(this,"_log",void 0),this.peerId=t,this.network=n,this.refcnt=1,this._entries=[],this._log=wq(e,"msgqueue"),this.sendEntries=mG(this.sendEntries.bind(this),1)}addMessage(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};e.empty||this.send(e,t)}addEntries(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this._entries=this._entries.concat(e),this.sendEntries(t)}sendEntries(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(0===this._entries.length)return;const t=new _q(!1);this._entries.forEach((e=>{!0===e.cancel?t.cancel(e.cid):t.addEntry(e.cid,e.priority)})),this._entries=[],this.addMessage(t,e)}async send(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};try{await this.network.connectTo(this.peerId,t)}catch(n){return void this._log.error("cant connect to peer %p: %s",this.peerId,n.message)}this._log("sending message to peer %p",this.peerId),this.network.sendMessage(this.peerId,e,t).catch((e=>{this._log.error("send error",e)}))}}class bG{constructor(e,t,n,r){(0,Yo.Z)(this,"peers",void 0),(0,Yo.Z)(this,"wantlist",void 0),(0,Yo.Z)(this,"network",void 0),(0,Yo.Z)(this,"_peerId",void 0),(0,Yo.Z)(this,"_log",void 0),this.peers=oq({name:"ipfs_bitswap_want_manager_peers",metrics:r.metrics}),this.wantlist=new Tq(n,r),this.network=t,this._peerId=e,this._log=wq(e,"want")}_addEntries(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const i=e.map(((e,n)=>new _q.Entry(e,rG-n,_q.WantType.Block,t)));i.forEach((e=>{e.cancel?!0===n?this.wantlist.removeForce(e.cid.toString(eH)):this.wantlist.remove(e.cid):(this._log("adding to wantlist"),this.wantlist.add(e.cid,e.priority))}));for(const o of this.peers.values())o.addEntries(i,r)}_startPeerHandler(e){let t=this.peers.get(e.toString());if(null!=t)return void t.refcnt++;t=new vG(this._peerId,e,this.network);const n=new _q(!0);for(const r of this.wantlist.entries())n.addEntry(r[1].cid,r[1].priority);return t.addMessage(n),this.peers.set(e.toString(),t),t}_stopPeerHandler(e){const t=this.peers.get(e.toString());null!=t&&(t.refcnt--,t.refcnt>0||this.peers.delete(e.toString()))}wantBlocks(e){var t;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this._addEntries(e,!1,!1,n),null===(t=n.signal)||void 0===t||t.addEventListener("abort",(()=>{this.cancelWants(e)}))}unwantBlocks(e){this._log("unwant blocks: %s",e.length),this._addEntries(e,!0,!0)}cancelWants(e){this._log("cancel wants: %s",e.length),this._addEntries(e,!0)}connectedPeers(){return Array.from(this.peers.keys())}connected(e){this._startPeerHandler(e)}disconnected(e){this._stopPeerHandler(e)}start(){}stop(){this.peers.forEach((e=>{this.disconnected(e.peerId)}))}}const wG={maxInboundStreams:1024,maxOutboundStreams:1024,incomingStreamTimeout:3e4,hashLoader:{async getHasher(){throw new Error("Not implemented")}},statsEnabled:!1,statsComputeThrottleTimeout:1e3,statsComputeThrottleMaxQueueSize:1e3},EG=["blocksReceived","dataReceived","dupBlksReceived","dupDataReceived","blocksSent","dataSent","providesBufferLength","wantListLength","peerCount"];class AG{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};(0,Yo.Z)(this,"_libp2p",void 0),(0,Yo.Z)(this,"_log",void 0),(0,Yo.Z)(this,"stats",void 0),(0,Yo.Z)(this,"network",void 0),(0,Yo.Z)(this,"blockstore",void 0),(0,Yo.Z)(this,"engine",void 0),(0,Yo.Z)(this,"wm",void 0),(0,Yo.Z)(this,"notifications",void 0),(0,Yo.Z)(this,"started",void 0),this._libp2p=e,this._log=wq(this.peerId),n=Object.assign({},wG,n),this.stats=new yG(e,EG,{enabled:n.statsEnabled,computeThrottleTimeout:n.statsComputeThrottleTimeout,computeThrottleMaxQueueSize:n.statsComputeThrottleMaxQueueSize}),this.network=new aG(e,this,this.stats,{hashLoader:n.hashLoader,maxInboundStreams:n.maxInboundStreams,maxOutboundStreams:n.maxOutboundStreams,incomingStreamTimeout:n.incomingStreamTimeout}),this.blockstore=t,this.engine=new Lq(this.peerId,t,this.network,this.stats,e),this.wm=new bG(this.peerId,this.network,this.stats,e),this.notifications=new hG(this.peerId),this.started=!1}isStarted(){return this.started}get peerId(){return this._libp2p.peerId}async _receiveMessage(e,t){try{await this.engine.messageReceived(e,t)}catch(r){this._log("failed to receive message",t)}if(0===t.blocks.size)return;const n=[];for(const[i,o]of t.blocks.entries()){const e=YH.parse(i);n.push({wasWanted:this.wm.wantlist.contains(e),cid:e,data:o})}this.wm.cancelWants(n.filter((e=>{let{wasWanted:t}=e;return t})).map((e=>{let{cid:t}=e;return t}))),await Promise.all(n.map((async t=>{let{cid:n,wasWanted:r,data:i}=t;await this._handleReceivedBlock(e,n,i,r)})))}async _handleReceivedBlock(e,t,n,r){this._log("received block");const i=await this.blockstore.has(t);this._updateReceiveCounters(e.toString(),t,n,i),r&&await this.put(t,n)}_updateReceiveCounters(e,t,n,r){this.stats.push(e,"blocksReceived",1),this.stats.push(e,"dataReceived",n.length),r&&(this.stats.push(e,"dupBlksReceived",1),this.stats.push(e,"dupDataReceived",n.length))}_receiveError(e){this._log.error("ReceiveError",e)}_onPeerConnected(e){this.wm.connected(e)}_onPeerDisconnected(e){this.wm.disconnected(e),this.engine.peerDisconnected(e),this.stats.disconnected(e)}enableStats(){this.stats.enable()}disableStats(){this.stats.disable()}wantlistForPeer(e,t){return this.engine.wantlistForPeer(e)}ledgerForPeer(e){return this.engine.ledgerForPeer(e)}async want(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=async(e,t)=>(this.wm.wantBlocks([e],t),this.notifications.wantBlock(e,t));let r=!1;const i=async(e,t)=>{try{return await this.blockstore.get(e,t)}catch(i){if("ERR_NOT_FOUND"!==i.code)throw i;return r||(r=!0,this.network.findAndConnect(e,t).catch((e=>{this._log.error(e)}))),await n(e,t)}},o=new AbortController,s=SH([o.signal,t.signal]);try{return await Promise.race([this.notifications.wantBlock(e,{...t,signal:s}),i(e,{...t,signal:s})])}finally{o.abort(),s.clear()}}unwant(e){const t=Array.isArray(e)?e:[e];this.wm.unwantBlocks(t),t.forEach((e=>{this.notifications.unwantBlock(e)}))}cancelWants(e){this.wm.cancelWants(Array.isArray(e)?e:[e])}async put(e,t,n){await this.blockstore.put(e,t),this.notify(e,t)}async*putMany(e,t){yield*this.blockstore.putMany(jd(e,(e=>{let{cid:t,block:n}=e;this.notify(t,n)})),t)}notify(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};this.notifications.hasBlock(e,t),this.engine.receivedBlocks([{cid:e,block:t}]),this.network.provide(e,n).catch((e=>{this._log.error("Failed to provide: %s",e.message)}))}getWantlist(){return this.wm.wantlist.entries()}get peers(){return this.engine.peers()}async start(){this.wm.start(),await this.network.start(),this.engine.start(),this.started=!0}async stop(){this.stats.stop(),this.wm.stop(),await this.network.stop(),this.engine.stop(),this.started=!1}}class SG{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};(0,Yo.Z)(this,"bitswap",void 0),(0,Yo.Z)(this,"started",void 0);const{libp2p:n,blockstore:r,hashers:i}=e;this.bitswap=function(e,t){return new AG(e,t,arguments.length>2&&void 0!==arguments[2]?arguments[2]:{})}(n,r,{hashLoader:{getHasher:async e=>{const t=i.find((t=>t.code===e||t.name===e));if(null!=t)return t;throw new Error('Could not load hasher for code/name "'.concat(e,'"'))}},...t}),this.started=!1}isStarted(){return this.started}async start(){await this.bitswap.start(),this.started=!0}async stop(){await this.bitswap.stop(),this.started=!1}announce(e,t,n){this.bitswap.notify(e,t,n)}async retrieve(e){let{validateFn:t,...n}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.bitswap.want(e,n)}}function _G(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t=>new SG(t,e)}var IG=n(63914);function CG(e,t,n){return function(e,t,n){if(t.set)t.set.call(e,n);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=n}}(e,(0,IG.Z)(e,t,"set"),n),n}var TG=new WeakMap,kG=new WeakMap,RG=new WeakMap,xG=new WeakMap;class PG{constructor(e){(0,Yo.Z)(this,"url",void 0),(0,dx.Z)(this,TG,{writable:!0,value:0}),(0,dx.Z)(this,kG,{writable:!0,value:0}),(0,dx.Z)(this,RG,{writable:!0,value:0}),(0,dx.Z)(this,xG,{writable:!0,value:0}),this.url=e instanceof URL?e:new URL(e)}async getRawBlock(e,t){const n=this.url;if(n.pathname="/ipfs/".concat(e.toString()),n.search="?format=raw",!0===(null===t||void 0===t?void 0:t.aborted))throw new Error("Signal to fetch raw block for CID ".concat(e," from gateway ").concat(this.url," was aborted prior to fetch"));try{var r,i;CG(this,TG,(r=(0,fx.Z)(this,TG),r++,r));const s=await fetch(n.toString(),{signal:t,headers:{Accept:"application/vnd.ipld.raw"},cache:"force-cache"});var o;if(!s.ok)throw CG(this,kG,(o=(0,fx.Z)(this,kG),o++,o)),new Error("unable to fetch raw block for CID ".concat(e," from gateway ").concat(this.url));return CG(this,xG,(i=(0,fx.Z)(this,xG),i++,i)),new Uint8Array(await s.arrayBuffer())}catch(a){var s;if(!0===(null===t||void 0===t?void 0:t.aborted))throw new Error("fetching raw block for CID ".concat(e," from gateway ").concat(this.url," was aborted"));throw CG(this,kG,(s=(0,fx.Z)(this,kG),s++,s)),new Error("unable to fetch raw block for CID ".concat(e))}}reliability(){return 0===(0,fx.Z)(this,TG)?1:(0,fx.Z)(this,RG)>0?-1/0:(0,fx.Z)(this,xG)/((0,fx.Z)(this,TG)+3*(0,fx.Z)(this,kG))}incrementInvalidBlocks(){var e;CG(this,RG,(e=(0,fx.Z)(this,RG),e++,e))}}const DG=aH("helia:trustless-gateway-block-broker");class OG{constructor(){var e;let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};(0,Yo.Z)(this,"gateways",void 0),this.gateways=(null!==(e=t.gateways)&&void 0!==e?e:NG).map((e=>new PG(e)))}async retrieve(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.gateways.sort(((e,t)=>t.reliability()-e.reliability())),r=[];for(const a of n){DG("getting block for %c from %s",e,a.url);try{const n=await a.getRawBlock(e,t.signal);DG.trace("got block for %c from %s",e,a.url);try{var i;await(null===(i=t.validateFn)||void 0===i?void 0:i.call(t,n))}catch(s){throw DG.error("failed to validate block for %c from %s",e,a.url,s),a.incrementInvalidBlocks(),new Error("unable to validate block for CID ".concat(e," from gateway ").concat(a.url))}return n}catch(s){var o;if(DG.error("failed to get block for %c from %s",e,a.url,s),s instanceof Error?r.push(s):r.push(new Error("unable to fetch raw block for CID ".concat(e," from gateway ").concat(a.url))),!0===(null===(o=t.signal)||void 0===o?void 0:o.aborted)){DG.trace("request aborted while fetching raw block for CID %c from gateway %s",e,a.url);break}}}throw new AggregateError(r,"unable to fetch raw block for CID ".concat(e," from any gateway"))}}const NG=["https://dweb.link","https://cf-ipfs.com","https://4everland.io","https://w3s.link"];function BG(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return()=>new OG(e)}const LG=["string","number","bigint","symbol"],MG=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];function UG(e){if(null===e)return"null";if(void 0===e)return"undefined";if(!0===e||!1===e)return"boolean";const t=typeof e;if(LG.includes(t))return t;if("function"===t)return"Function";if(Array.isArray(e))return"Array";if(function(e){return e&&e.constructor&&e.constructor.isBuffer&&e.constructor.isBuffer.call(null,e)}(e))return"Buffer";const n=function(e){const t=Object.prototype.toString.call(e).slice(8,-1);if(MG.includes(t))return t;return}(e);return n||"Object"}class FG{constructor(e,t,n){this.major=e,this.majorEncoded=e<<5,this.name=t,this.terminal=n}toString(){return"Type[".concat(this.major,"].").concat(this.name)}compare(e){return this.major<e.major?-1:this.major>e.major?1:0}}FG.uint=new FG(0,"uint",!0),FG.negint=new FG(1,"negint",!0),FG.bytes=new FG(2,"bytes",!0),FG.string=new FG(3,"string",!0),FG.array=new FG(4,"array",!1),FG.map=new FG(5,"map",!1),FG.tag=new FG(6,"tag",!1),FG.float=new FG(7,"float",!0),FG.false=new FG(7,"false",!0),FG.true=new FG(7,"true",!0),FG.null=new FG(7,"null",!0),FG.undefined=new FG(7,"undefined",!0),FG.break=new FG(7,"break",!0);class KG{constructor(e,t,n){this.type=e,this.value=t,this.encodedLength=n,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return"Token[".concat(this.type,"].").concat(this.value)}}const jG=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&"function"===typeof globalThis.Buffer.isBuffer,ZG=new TextDecoder,zG=new TextEncoder;function VG(e){return jG&&globalThis.Buffer.isBuffer(e)}function HG(e){return e instanceof Uint8Array?VG(e)?new Uint8Array(e.buffer,e.byteOffset,e.byteLength):e:Uint8Array.from(e)}const qG=jG?(e,t,n)=>n-t>64?globalThis.Buffer.from(e.subarray(t,n)).toString("utf8"):$G(e,t,n):(e,t,n)=>n-t>64?ZG.decode(e.subarray(t,n)):$G(e,t,n),GG=jG?e=>e.length>64?globalThis.Buffer.from(e):XG(e):e=>e.length>64?zG.encode(e):XG(e),WG=e=>Uint8Array.from(e),QG=jG?(e,t,n)=>VG(e)?new Uint8Array(e.subarray(t,n)):e.slice(t,n):(e,t,n)=>e.slice(t,n),YG=jG?(e,t)=>(e=e.map((e=>e instanceof Uint8Array?e:globalThis.Buffer.from(e))),HG(globalThis.Buffer.concat(e,t))):(e,t)=>{const n=new Uint8Array(t);let r=0;for(let i of e)r+i.length>n.length&&(i=i.subarray(0,n.length-r)),n.set(i,r),r+=i.length;return n},JG=jG?e=>globalThis.Buffer.allocUnsafe(e):e=>new Uint8Array(e);function XG(e){const t=[];let n=0;for(let r=0;r<e.length;r++){let i=e.charCodeAt(r);i<128?t[n++]=i:i<2048?(t[n++]=i>>6|192,t[n++]=63&i|128):55296===(64512&i)&&r+1<e.length&&56320===(64512&e.charCodeAt(r+1))?(i=65536+((1023&i)<<10)+(1023&e.charCodeAt(++r)),t[n++]=i>>18|240,t[n++]=i>>12&63|128,t[n++]=i>>6&63|128,t[n++]=63&i|128):(t[n++]=i>>12|224,t[n++]=i>>6&63|128,t[n++]=63&i|128)}return t}function $G(e,t,n){const r=[];for(;t<n;){const i=e[t];let o=null,s=i>239?4:i>223?3:i>191?2:1;if(t+s<=n){let n,r,a,c;switch(s){case 1:i<128&&(o=i);break;case 2:n=e[t+1],128===(192&n)&&(c=(31&i)<<6|63&n,c>127&&(o=c));break;case 3:n=e[t+1],r=e[t+2],128===(192&n)&&128===(192&r)&&(c=(15&i)<<12|(63&n)<<6|63&r,c>2047&&(c<55296||c>57343)&&(o=c));break;case 4:n=e[t+1],r=e[t+2],a=e[t+3],128===(192&n)&&128===(192&r)&&128===(192&a)&&(c=(15&i)<<18|(63&n)<<12|(63&r)<<6|63&a,c>65535&&c<1114112&&(o=c))}}null===o?(o=65533,s=1):o>65535&&(o-=65536,r.push(o>>>10&1023|55296),o=56320|1023&o),r.push(o),t+=s}return tW(r)}const eW=4096;function tW(e){const t=e.length;if(t<=eW)return String.fromCharCode.apply(String,e);let n="",r=0;for(;r<t;)n+=String.fromCharCode.apply(String,e.slice(r,r+=eW));return n}class nW{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:256;this.chunkSize=e,this.cursor=0,this.maxCursor=-1,this.chunks=[],this._initReuseChunk=null}reset(){this.cursor=0,this.maxCursor=-1,this.chunks.length&&(this.chunks=[]),null!==this._initReuseChunk&&(this.chunks.push(this._initReuseChunk),this.maxCursor=this._initReuseChunk.length-1)}push(e){let t=this.chunks[this.chunks.length-1];if(this.cursor+e.length<=this.maxCursor+1){const n=t.length-(this.maxCursor-this.cursor)-1;t.set(e,n)}else{if(t){const e=t.length-(this.maxCursor-this.cursor)-1;e<t.length&&(this.chunks[this.chunks.length-1]=t.subarray(0,e),this.maxCursor=this.cursor-1)}e.length<64&&e.length<this.chunkSize?(t=JG(this.chunkSize),this.chunks.push(t),this.maxCursor+=t.length,null===this._initReuseChunk&&(this._initReuseChunk=t),t.set(e,0)):(this.chunks.push(e),this.maxCursor+=e.length)}this.cursor+=e.length}toBytes(){let e,t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(1===this.chunks.length){const n=this.chunks[0];t&&this.cursor>n.length/2?(e=this.cursor===n.length?n:n.subarray(0,this.cursor),this._initReuseChunk=null,this.chunks=[]):e=QG(n,0,this.cursor)}else e=YG(this.chunks,this.cursor);return t&&this.reset(),e}}const rW="CBOR decode error:",iW="CBOR encode error:",oW=[];function sW(e,t,n){if(e.length-t<n)throw new Error("".concat(rW," not enough data for type"))}oW[23]=1,oW[24]=2,oW[25]=3,oW[26]=5,oW[27]=9;const aW=[24,256,65536,4294967296,BigInt("18446744073709551616")];function cW(e,t,n){sW(e,t,1);const r=e[t];if(!0===n.strict&&r<aW[0])throw new Error("".concat(rW," integer encoded in more bytes than necessary (strict decode)"));return r}function lW(e,t,n){sW(e,t,2);const r=e[t]<<8|e[t+1];if(!0===n.strict&&r<aW[1])throw new Error("".concat(rW," integer encoded in more bytes than necessary (strict decode)"));return r}function uW(e,t,n){sW(e,t,4);const r=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3];if(!0===n.strict&&r<aW[2])throw new Error("".concat(rW," integer encoded in more bytes than necessary (strict decode)"));return r}function hW(e,t,n){sW(e,t,8);const r=16777216*e[t]+(e[t+1]<<16)+(e[t+2]<<8)+e[t+3],i=16777216*e[t+4]+(e[t+5]<<16)+(e[t+6]<<8)+e[t+7],o=(BigInt(r)<<BigInt(32))+BigInt(i);if(!0===n.strict&&o<aW[3])throw new Error("".concat(rW," integer encoded in more bytes than necessary (strict decode)"));if(o<=Number.MAX_SAFE_INTEGER)return Number(o);if(!0===n.allowBigInt)return o;throw new Error("".concat(rW," integers outside of the safe integer range are not supported"))}function dW(e,t){return fW(e,0,t.value)}function fW(e,t,n){if(n<aW[0]){const r=Number(n);e.push([t|r])}else if(n<aW[1]){const r=Number(n);e.push([24|t,r])}else if(n<aW[2]){const r=Number(n);e.push([25|t,r>>>8,255&r])}else if(n<aW[3]){const r=Number(n);e.push([26|t,r>>>24&255,r>>>16&255,r>>>8&255,255&r])}else{const r=BigInt(n);if(!(r<aW[4]))throw new Error("".concat(rW," encountered BigInt larger than allowable range"));{const n=[27|t,0,0,0,0,0,0,0];let i=Number(r&BigInt(4294967295)),o=Number(r>>BigInt(32)&BigInt(4294967295));n[8]=255&i,i>>=8,n[7]=255&i,i>>=8,n[6]=255&i,i>>=8,n[5]=255&i,n[4]=255&o,o>>=8,n[3]=255&o,o>>=8,n[2]=255&o,o>>=8,n[1]=255&o,e.push(n)}}}dW.encodedSize=function(e){return fW.encodedSize(e.value)},fW.encodedSize=function(e){return e<aW[0]?1:e<aW[1]?2:e<aW[2]?3:e<aW[3]?5:9},dW.compareTokens=function(e,t){return e.value<t.value?-1:e.value>t.value?1:0};const pW=BigInt(-1),gW=BigInt(1);function yW(e,t){const n=t.value,r="bigint"===typeof n?n*pW-gW:-1*n-1;fW(e,t.type.majorEncoded,r)}function mW(e,t,n,r){sW(e,t,n+r);const i=QG(e,t+n,t+n+r);return new KG(FG.bytes,i,n+r)}function vW(e,t,n,r){return mW(e,t,1,n)}function bW(e){return void 0===e.encodedBytes&&(e.encodedBytes=e.type===FG.string?GG(e.value):e.value),e.encodedBytes}function wW(e,t){const n=bW(t);fW(e,t.type.majorEncoded,n.length),e.push(n)}function EW(e,t,n,r,i){const o=n+r;sW(e,t,o);const s=new KG(FG.string,qG(e,t+n,t+o),o);return!0===i.retainStringBytes&&(s.byteValue=QG(e,t+n,t+o)),s}function AW(e,t,n,r){return EW(e,t,1,n,r)}yW.encodedSize=function(e){const t=e.value,n="bigint"===typeof t?t*pW-gW:-1*t-1;return n<aW[0]?1:n<aW[1]?2:n<aW[2]?3:n<aW[3]?5:9},yW.compareTokens=function(e,t){return e.value<t.value?1:e.value>t.value?-1:0},wW.encodedSize=function(e){const t=bW(e);return fW.encodedSize(t.length)+t.length},wW.compareTokens=function(e,t){return n=bW(e),r=bW(t),n.length<r.length?-1:n.length>r.length?1:function(e,t){if(VG(e)&&VG(t))return e.compare(t);for(let n=0;n<e.length;n++)if(e[n]!==t[n])return e[n]<t[n]?-1:1;return 0}(n,r);var n,r};const SW=wW;function _W(e,t,n,r){return new KG(FG.array,r,n)}function IW(e,t,n,r){return _W(0,0,1,n)}function CW(e,t){fW(e,FG.array.majorEncoded,t.value)}function TW(e,t,n,r){return new KG(FG.map,r,n)}function kW(e,t,n,r){return TW(0,0,1,n)}function RW(e,t){fW(e,FG.map.majorEncoded,t.value)}function xW(e,t,n,r){return new KG(FG.tag,n,1)}function PW(e,t){fW(e,FG.tag.majorEncoded,t.value)}CW.compareTokens=dW.compareTokens,CW.encodedSize=function(e){return fW.encodedSize(e.value)},RW.compareTokens=dW.compareTokens,RW.encodedSize=function(e){return fW.encodedSize(e.value)},PW.compareTokens=dW.compareTokens,PW.encodedSize=function(e){return fW.encodedSize(e.value)};const DW=20,OW=21,NW=22,BW=23;function LW(e,t,n){if(n){if(!1===n.allowNaN&&Number.isNaN(e))throw new Error("".concat(rW," NaN values are not supported"));if(!1===n.allowInfinity&&(e===1/0||e===-1/0))throw new Error("".concat(rW," Infinity values are not supported"))}return new KG(FG.float,e,t)}function MW(e,t,n){const r=t.value;if(!1===r)e.push([FG.float.majorEncoded|DW]);else if(!0===r)e.push([FG.float.majorEncoded|OW]);else if(null===r)e.push([FG.float.majorEncoded|NW]);else if(void 0===r)e.push([FG.float.majorEncoded|BW]);else{let t,o=!1;n&&!0===n.float64||(jW(r),t=ZW(KW,1),r===t||Number.isNaN(r)?(KW[0]=249,e.push(KW.slice(0,3)),o=!0):(zW(r),t=VW(KW,1),r===t&&(KW[0]=250,e.push(KW.slice(0,5)),o=!0))),o||(i=r,FW.setFloat64(0,i,!1),t=HW(KW,1),KW[0]=251,e.push(KW.slice(0,9)))}var i}MW.encodedSize=function(e,t){const n=e.value;if(!1===n||!0===n||null===n||void 0===n)return 1;if(!t||!0!==t.float64){jW(n);let e=ZW(KW,1);if(n===e||Number.isNaN(n))return 3;if(zW(n),e=VW(KW,1),n===e)return 5}return 9};const UW=new ArrayBuffer(9),FW=new DataView(UW,1),KW=new Uint8Array(UW,0);function jW(e){if(e===1/0)FW.setUint16(0,31744,!1);else if(e===-1/0)FW.setUint16(0,64512,!1);else if(Number.isNaN(e))FW.setUint16(0,32256,!1);else{FW.setFloat32(0,e);const t=FW.getUint32(0),n=(2139095040&t)>>23,r=8388607&t;if(255===n)FW.setUint16(0,31744,!1);else if(0===n)FW.setUint16(0,(2147483648&e)>>16|r>>13,!1);else{const e=n-127;e<-24?FW.setUint16(0,0):e<-14?FW.setUint16(0,(2147483648&t)>>16|1<<24+e,!1):FW.setUint16(0,(2147483648&t)>>16|e+15<<10|r>>13,!1)}}}function ZW(e,t){if(e.length-t<2)throw new Error("".concat(rW," not enough data for float16"));const n=(e[t]<<8)+e[t+1];if(31744===n)return 1/0;if(64512===n)return-1/0;if(32256===n)return NaN;const r=n>>10&31,i=1023&n;let o;return o=0===r?i*2**-24:31!==r?(i+1024)*2**(r-25):0===i?1/0:NaN,32768&n?-o:o}function zW(e){FW.setFloat32(0,e,!1)}function VW(e,t){if(e.length-t<4)throw new Error("".concat(rW," not enough data for float32"));const n=(e.byteOffset||0)+t;return new DataView(e.buffer,n,4).getFloat32(0,!1)}function HW(e,t){if(e.length-t<8)throw new Error("".concat(rW," not enough data for float64"));const n=(e.byteOffset||0)+t;return new DataView(e.buffer,n,8).getFloat64(0,!1)}function qW(e,t,n){throw new Error("".concat(rW," encountered invalid minor (").concat(n,") for major ").concat(e[t]>>>5))}function GW(e){return()=>{throw new Error("".concat(rW," ").concat(e))}}MW.compareTokens=dW.compareTokens;const WW=[];for(let Ige=0;Ige<=23;Ige++)WW[Ige]=qW;WW[24]=function(e,t,n,r){return new KG(FG.uint,cW(e,t+1,r),2)},WW[25]=function(e,t,n,r){return new KG(FG.uint,lW(e,t+1,r),3)},WW[26]=function(e,t,n,r){return new KG(FG.uint,uW(e,t+1,r),5)},WW[27]=function(e,t,n,r){return new KG(FG.uint,hW(e,t+1,r),9)},WW[28]=qW,WW[29]=qW,WW[30]=qW,WW[31]=qW;for(let Ige=32;Ige<=55;Ige++)WW[Ige]=qW;WW[56]=function(e,t,n,r){return new KG(FG.negint,-1-cW(e,t+1,r),2)},WW[57]=function(e,t,n,r){return new KG(FG.negint,-1-lW(e,t+1,r),3)},WW[58]=function(e,t,n,r){return new KG(FG.negint,-1-uW(e,t+1,r),5)},WW[59]=function(e,t,n,r){const i=hW(e,t+1,r);if("bigint"!==typeof i){const e=-1-i;if(e>=Number.MIN_SAFE_INTEGER)return new KG(FG.negint,e,9)}if(!0!==r.allowBigInt)throw new Error("".concat(rW," integers outside of the safe integer range are not supported"));return new KG(FG.negint,pW-BigInt(i),9)},WW[60]=qW,WW[61]=qW,WW[62]=qW,WW[63]=qW;for(let Ige=64;Ige<=87;Ige++)WW[Ige]=vW;WW[88]=function(e,t,n,r){return mW(e,t,2,cW(e,t+1,r))},WW[89]=function(e,t,n,r){return mW(e,t,3,lW(e,t+1,r))},WW[90]=function(e,t,n,r){return mW(e,t,5,uW(e,t+1,r))},WW[91]=function(e,t,n,r){const i=hW(e,t+1,r);if("bigint"===typeof i)throw new Error("".concat(rW," 64-bit integer bytes lengths not supported"));return mW(e,t,9,i)},WW[92]=qW,WW[93]=qW,WW[94]=qW,WW[95]=GW("indefinite length bytes/strings are not supported");for(let Ige=96;Ige<=119;Ige++)WW[Ige]=AW;WW[120]=function(e,t,n,r){return EW(e,t,2,cW(e,t+1,r),r)},WW[121]=function(e,t,n,r){return EW(e,t,3,lW(e,t+1,r),r)},WW[122]=function(e,t,n,r){return EW(e,t,5,uW(e,t+1,r),r)},WW[123]=function(e,t,n,r){const i=hW(e,t+1,r);if("bigint"===typeof i)throw new Error("".concat(rW," 64-bit integer string lengths not supported"));return EW(e,t,9,i,r)},WW[124]=qW,WW[125]=qW,WW[126]=qW,WW[127]=GW("indefinite length bytes/strings are not supported");for(let Ige=128;Ige<=151;Ige++)WW[Ige]=IW;WW[152]=function(e,t,n,r){return _W(0,0,2,cW(e,t+1,r))},WW[153]=function(e,t,n,r){return _W(0,0,3,lW(e,t+1,r))},WW[154]=function(e,t,n,r){return _W(0,0,5,uW(e,t+1,r))},WW[155]=function(e,t,n,r){const i=hW(e,t+1,r);if("bigint"===typeof i)throw new Error("".concat(rW," 64-bit integer array lengths not supported"));return _W(0,0,9,i)},WW[156]=qW,WW[157]=qW,WW[158]=qW,WW[159]=function(e,t,n,r){if(!1===r.allowIndefinite)throw new Error("".concat(rW," indefinite length items not allowed"));return _W(0,0,1,1/0)};for(let Ige=160;Ige<=183;Ige++)WW[Ige]=kW;WW[184]=function(e,t,n,r){return TW(0,0,2,cW(e,t+1,r))},WW[185]=function(e,t,n,r){return TW(0,0,3,lW(e,t+1,r))},WW[186]=function(e,t,n,r){return TW(0,0,5,uW(e,t+1,r))},WW[187]=function(e,t,n,r){const i=hW(e,t+1,r);if("bigint"===typeof i)throw new Error("".concat(rW," 64-bit integer map lengths not supported"));return TW(0,0,9,i)},WW[188]=qW,WW[189]=qW,WW[190]=qW,WW[191]=function(e,t,n,r){if(!1===r.allowIndefinite)throw new Error("".concat(rW," indefinite length items not allowed"));return TW(0,0,1,1/0)};for(let Ige=192;Ige<=215;Ige++)WW[Ige]=xW;WW[216]=function(e,t,n,r){return new KG(FG.tag,cW(e,t+1,r),2)},WW[217]=function(e,t,n,r){return new KG(FG.tag,lW(e,t+1,r),3)},WW[218]=function(e,t,n,r){return new KG(FG.tag,uW(e,t+1,r),5)},WW[219]=function(e,t,n,r){return new KG(FG.tag,hW(e,t+1,r),9)},WW[220]=qW,WW[221]=qW,WW[222]=qW,WW[223]=qW;for(let Ige=224;Ige<=243;Ige++)WW[Ige]=GW("simple values are not supported");WW[244]=qW,WW[245]=qW,WW[246]=qW,WW[247]=function(e,t,n,r){if(!1===r.allowUndefined)throw new Error("".concat(rW," undefined values are not supported"));return!0===r.coerceUndefinedToNull?new KG(FG.null,null,1):new KG(FG.undefined,void 0,1)},WW[248]=GW("simple values are not supported"),WW[249]=function(e,t,n,r){return LW(ZW(e,t+1),3,r)},WW[250]=function(e,t,n,r){return LW(VW(e,t+1),5,r)},WW[251]=function(e,t,n,r){return LW(HW(e,t+1),9,r)},WW[252]=qW,WW[253]=qW,WW[254]=qW,WW[255]=function(e,t,n,r){if(!1===r.allowIndefinite)throw new Error("".concat(rW," indefinite length items not allowed"));return new KG(FG.break,void 0,1)};const QW=[];for(let Ige=0;Ige<24;Ige++)QW[Ige]=new KG(FG.uint,Ige,1);for(let Ige=-1;Ige>=-24;Ige--)QW[31-Ige]=new KG(FG.negint,Ige,1);QW[64]=new KG(FG.bytes,new Uint8Array(0),1),QW[96]=new KG(FG.string,"",1),QW[128]=new KG(FG.array,0,1),QW[160]=new KG(FG.map,0,1),QW[244]=new KG(FG.false,!1,1),QW[245]=new KG(FG.true,!0,1),QW[246]=new KG(FG.null,null,1);const YW={float64:!1,mapSorter:function(e,t){const n=Array.isArray(e[0])?e[0][0]:e[0],r=Array.isArray(t[0])?t[0][0]:t[0];if(n.type!==r.type)return n.type.compare(r.type);const i=n.type.major,o=JW[i].compareTokens(n,r);0===o&&console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");return o},quickEncodeToken:function(e){switch(e.type){case FG.false:return WG([244]);case FG.true:return WG([245]);case FG.null:return WG([246]);case FG.bytes:return e.value.length?void 0:WG([64]);case FG.string:return""===e.value?WG([96]):void 0;case FG.array:return 0===e.value?WG([128]):void 0;case FG.map:return 0===e.value?WG([160]):void 0;case FG.uint:return e.value<24?WG([Number(e.value)]):void 0;case FG.negint:if(e.value>=-24)return WG([31-Number(e.value)])}}};const JW=function(){const e=[];return e[FG.uint.major]=dW,e[FG.negint.major]=yW,e[FG.bytes.major]=wW,e[FG.string.major]=SW,e[FG.array.major]=CW,e[FG.map.major]=RW,e[FG.tag.major]=PW,e[FG.float.major]=MW,e}(),XW=new nW;class $W{constructor(e,t){this.obj=e,this.parent=t}includes(e){let t=this;do{if(t.obj===e)return!0}while(t=t.parent);return!1}static createCheck(e,t){if(e&&e.includes(t))throw new Error("".concat(iW," object contains circular references"));return new $W(t,e)}}const eQ={null:new KG(FG.null,null),undefined:new KG(FG.undefined,void 0),true:new KG(FG.true,!0),false:new KG(FG.false,!1),emptyArray:new KG(FG.array,0),emptyMap:new KG(FG.map,0)},tQ={number:(e,t,n,r)=>Number.isInteger(e)&&Number.isSafeInteger(e)?new KG(e>=0?FG.uint:FG.negint,e):new KG(FG.float,e),bigint:(e,t,n,r)=>e>=BigInt(0)?new KG(FG.uint,e):new KG(FG.negint,e),Uint8Array:(e,t,n,r)=>new KG(FG.bytes,e),string:(e,t,n,r)=>new KG(FG.string,e),boolean:(e,t,n,r)=>e?eQ.true:eQ.false,null:(e,t,n,r)=>eQ.null,undefined:(e,t,n,r)=>eQ.undefined,ArrayBuffer:(e,t,n,r)=>new KG(FG.bytes,new Uint8Array(e)),DataView:(e,t,n,r)=>new KG(FG.bytes,new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),Array(e,t,n,r){if(!e.length)return!0===n.addBreakTokens?[eQ.emptyArray,new KG(FG.break)]:eQ.emptyArray;r=$W.createCheck(r,e);const i=[];let o=0;for(const s of e)i[o++]=nQ(s,n,r);return n.addBreakTokens?[new KG(FG.array,e.length),i,new KG(FG.break)]:[new KG(FG.array,e.length),i]},Object(e,t,n,r){const i="Object"!==t,o=i?e.keys():Object.keys(e),s=i?e.size:o.length;if(!s)return!0===n.addBreakTokens?[eQ.emptyMap,new KG(FG.break)]:eQ.emptyMap;r=$W.createCheck(r,e);const a=[];let c=0;for(const l of o)a[c++]=[nQ(l,n,r),nQ(i?e.get(l):e[l],n,r)];return function(e,t){t.mapSorter&&e.sort(t.mapSorter)}(a,n),n.addBreakTokens?[new KG(FG.map,s),a,new KG(FG.break)]:[new KG(FG.map,s),a]}};tQ.Map=tQ.Object,tQ.Buffer=tQ.Uint8Array;for(const Ige of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))tQ["".concat(Ige,"Array")]=tQ.DataView;function nQ(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2?arguments[2]:void 0;const r=UG(e),i=t&&t.typeEncoders&&t.typeEncoders[r]||tQ[r];if("function"===typeof i){const o=i(e,r,t,n);if(null!=o)return o}const o=tQ[r];if(!o)throw new Error("".concat(iW," unsupported type: ").concat(r));return o(e,r,t,n)}function rQ(e,t,n,r){if(Array.isArray(t))for(const i of t)rQ(e,i,n,r);else n[t.type.major](e,t,r)}function iQ(e,t,n){const r=nQ(e,n);if(!Array.isArray(r)&&n.quickEncodeToken){const e=n.quickEncodeToken(r);if(e)return e;const i=t[r.type.major];if(i.encodedSize){const e=i.encodedSize(r,n),t=new nW(e);if(i(t,r,n),1!==t.chunks.length)throw new Error("Unexpected error: pre-calculated length for ".concat(r," was wrong"));return HG(t.chunks[0])}}return XW.reset(),rQ(XW,r,t,n),XW.toBytes(!0)}function oQ(e,t){return t=Object.assign({},YW,t),iQ(e,JW,t)}const sQ={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0};class aQ{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this._pos=0,this.data=e,this.options=t}pos(){return this._pos}done(){return this._pos>=this.data.length}next(){const e=this.data[this._pos];let t=QW[e];if(void 0===t){const n=WW[e];if(!n)throw new Error("".concat(rW," no decoder for major type ").concat(e>>>5," (byte 0x").concat(e.toString(16).padStart(2,"0"),")"));const r=31&e;t=n(this.data,this._pos,r,this.options)}return this._pos+=t.encodedLength,t}}const cQ=Symbol.for("DONE"),lQ=Symbol.for("BREAK");function uQ(e,t){if(e.done())return cQ;const n=e.next();if(n.type===FG.break)return lQ;if(n.type.terminal)return n.value;if(n.type===FG.array)return function(e,t,n){const r=[];for(let i=0;i<e.value;i++){const o=uQ(t,n);if(o===lQ){if(e.value===1/0)break;throw new Error("".concat(rW," got unexpected break to lengthed array"))}if(o===cQ)throw new Error("".concat(rW," found array but not enough entries (got ").concat(i,", expected ").concat(e.value,")"));r[i]=o}return r}(n,e,t);if(n.type===FG.map)return function(e,t,n){const r=!0===n.useMaps,i=r?void 0:{},o=r?new Map:void 0;for(let s=0;s<e.value;s++){const a=uQ(t,n);if(a===lQ){if(e.value===1/0)break;throw new Error("".concat(rW," got unexpected break to lengthed map"))}if(a===cQ)throw new Error("".concat(rW," found map but not enough entries (got ").concat(s," [no key], expected ").concat(e.value,")"));if(!0!==r&&"string"!==typeof a)throw new Error("".concat(rW," non-string keys not supported (got ").concat(typeof a,")"));if(!0===n.rejectDuplicateMapKeys&&(r&&o.has(a)||!r&&a in i))throw new Error("".concat(rW,' found repeat map key "').concat(a,'"'));const c=uQ(t,n);if(c===cQ)throw new Error("".concat(rW," found map but not enough entries (got ").concat(s," [no value], expected ").concat(e.value,")"));r?o.set(a,c):i[a]=c}return r?o:i}(n,e,t);if(n.type===FG.tag){if(t.tags&&"function"===typeof t.tags[n.value]){const r=uQ(e,t);return t.tags[n.value](r)}throw new Error("".concat(rW," tag not supported (").concat(n.value,")"))}throw new Error("unsupported")}function hQ(e,t){const[n,r]=function(e,t){if(!(e instanceof Uint8Array))throw new Error("".concat(rW," data to decode must be a Uint8Array"));const n=(t=Object.assign({},sQ,t)).tokenizer||new aQ(e,t),r=uQ(n,t);if(r===cQ)throw new Error("".concat(rW," did not find any content to decode"));if(r===lQ)throw new Error("".concat(rW," got unexpected break"));return[r,e.subarray(n.pos())]}(e,t);if(r.length>0)throw new Error("".concat(rW," too many terminals, data makes no sense"));return n}const dQ=zV({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),fQ=zV({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var pQ=n(1315);FG.uint.major,FG.negint.major,FG.bytes.major,FG.string.major,FG.array.major,FG.map.major,FG.tag.major,FG.float.major;class gQ{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this._pos=0,this.data=e,this.options=t,this.modeStack=["value"],this.lastToken=""}pos(){return this._pos}done(){return this._pos>=this.data.length}ch(){return this.data[this._pos]}currentMode(){return this.modeStack[this.modeStack.length-1]}skipWhitespace(){let e=this.ch();for(;32===e||9===e||13===e||10===e;)e=this.data[++this._pos]}expect(e){if(this.data.length-this._pos<e.length)throw new Error("".concat(rW," unexpected end of input at position ").concat(this._pos));for(let t=0;t<e.length;t++)if(this.data[this._pos++]!==e[t])throw new Error("".concat(rW," unexpected token at position ").concat(this._pos,", expected to find '").concat(String.fromCharCode(...e),"'"))}parseNumber(){const e=this._pos;let t=!1,n=!1;const r=e=>{for(;!this.done();){const t=this.ch();if(!e.includes(t))break;this._pos++}};if(45===this.ch()&&(t=!0,this._pos++),48===this.ch()){if(this._pos++,46!==this.ch())return new KG(FG.uint,0,this._pos-e);this._pos++,n=!0}if(r([48,49,50,51,52,53,54,55,56,57]),t&&this._pos===e+1)throw new Error("".concat(rW," unexpected token at position ").concat(this._pos));if(!this.done()&&46===this.ch()){if(n)throw new Error("".concat(rW," unexpected token at position ").concat(this._pos));n=!0,this._pos++,r([48,49,50,51,52,53,54,55,56,57])}this.done()||101!==this.ch()&&69!==this.ch()||(n=!0,this._pos++,this.done()||43!==this.ch()&&45!==this.ch()||this._pos++,r([48,49,50,51,52,53,54,55,56,57]));const i=String.fromCharCode.apply(null,this.data.subarray(e,this._pos)),o=parseFloat(i);return n?new KG(FG.float,o,this._pos-e):!0!==this.options.allowBigInt||Number.isSafeInteger(o)?new KG(o>=0?FG.uint:FG.negint,o,this._pos-e):new KG(o>=0?FG.uint:FG.negint,BigInt(i),this._pos-e)}parseString(){if(34!==this.ch())throw new Error("".concat(rW," unexpected character at position ").concat(this._pos,"; this shouldn't happen"));this._pos++;for(let i=this._pos,o=0;i<this.data.length&&o<65536;i++,o++){const e=this.data[i];if(92===e||e<32||e>=128)break;if(34===e){const e=String.fromCharCode.apply(null,this.data.subarray(this._pos,i));return this._pos=i+1,new KG(FG.string,e,o)}}const e=this._pos,t=[],n=()=>{if(this._pos+4>=this.data.length)throw new Error("".concat(rW," unexpected end of unicode escape sequence at position ").concat(this._pos));let e=0;for(let t=0;t<4;t++){let t=this.ch();if(t>=48&&t<=57)t-=48;else if(t>=97&&t<=102)t=t-97+10;else{if(!(t>=65&&t<=70))throw new Error("".concat(rW," unexpected unicode escape character at position ").concat(this._pos));t=t-65+10}e=16*e+t,this._pos++}return e},r=()=>{const e=this.ch();let n,r,i,o,s=null,a=e>239?4:e>223?3:e>191?2:1;if(this._pos+a>this.data.length)throw new Error("".concat(rW," unexpected unicode sequence at position ").concat(this._pos));switch(a){case 1:e<128&&(s=e);break;case 2:n=this.data[this._pos+1],128===(192&n)&&(o=(31&e)<<6|63&n,o>127&&(s=o));break;case 3:n=this.data[this._pos+1],r=this.data[this._pos+2],128===(192&n)&&128===(192&r)&&(o=(15&e)<<12|(63&n)<<6|63&r,o>2047&&(o<55296||o>57343)&&(s=o));break;case 4:n=this.data[this._pos+1],r=this.data[this._pos+2],i=this.data[this._pos+3],128===(192&n)&&128===(192&r)&&128===(192&i)&&(o=(15&e)<<18|(63&n)<<12|(63&r)<<6|63&i,o>65535&&o<1114112&&(s=o))}null===s?(s=65533,a=1):s>65535&&(s-=65536,t.push(s>>>10&1023|55296),s=56320|1023&s),t.push(s),this._pos+=a};for(;!this.done();){const i=this.ch();let o;switch(i){case 92:if(this._pos++,this.done())throw new Error("".concat(rW," unexpected string termination at position ").concat(this._pos));switch(o=this.ch(),this._pos++,o){case 34:case 39:case 92:case 47:t.push(o);break;case 98:t.push(8);break;case 116:t.push(9);break;case 110:t.push(10);break;case 102:t.push(12);break;case 114:t.push(13);break;case 117:t.push(n());break;default:throw new Error("".concat(rW," unexpected string escape character at position ").concat(this._pos))}break;case 34:return this._pos++,new KG(FG.string,tW(t),this._pos-e);default:if(i<32)throw new Error("".concat(rW," invalid control character at position ").concat(this._pos));i<128?(t.push(i),this._pos++):r()}}throw new Error("".concat(rW," unexpected end of string at position ").concat(this._pos))}parseValue(){switch(this.ch()){case 123:return this.modeStack.push("obj-start"),this._pos++,new KG(FG.map,1/0,1);case 91:return this.modeStack.push("array-start"),this._pos++,new KG(FG.array,1/0,1);case 34:return this.parseString();case 110:return this.expect([110,117,108,108]),new KG(FG.null,null,4);case 102:return this.expect([102,97,108,115,101]),new KG(FG.false,!1,5);case 116:return this.expect([116,114,117,101]),new KG(FG.true,!0,4);case 45:case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.parseNumber();default:throw new Error("".concat(rW," unexpected character at position ").concat(this._pos))}}next(){switch(this.skipWhitespace(),this.currentMode()){case"value":return this.modeStack.pop(),this.parseValue();case"array-value":if(this.modeStack.pop(),93===this.ch())return this._pos++,this.skipWhitespace(),new KG(FG.break,void 0,1);if(44!==this.ch())throw new Error("".concat(rW," unexpected character at position ").concat(this._pos,", was expecting array delimiter but found '").concat(String.fromCharCode(this.ch()),"'"));return this._pos++,this.modeStack.push("array-value"),this.skipWhitespace(),this.parseValue();case"array-start":return this.modeStack.pop(),93===this.ch()?(this._pos++,this.skipWhitespace(),new KG(FG.break,void 0,1)):(this.modeStack.push("array-value"),this.skipWhitespace(),this.parseValue());case"obj-key":if(125===this.ch())return this.modeStack.pop(),this._pos++,this.skipWhitespace(),new KG(FG.break,void 0,1);if(44!==this.ch())throw new Error("".concat(rW," unexpected character at position ").concat(this._pos,", was expecting object delimiter but found '").concat(String.fromCharCode(this.ch()),"'"));this._pos++,this.skipWhitespace();case"obj-start":{if(this.modeStack.pop(),125===this.ch())return this._pos++,this.skipWhitespace(),new KG(FG.break,void 0,1);const e=this.parseString();if(this.skipWhitespace(),58!==this.ch())throw new Error("".concat(rW," unexpected character at position ").concat(this._pos,", was expecting key/value delimiter ':' but found '").concat(String.fromCharCode(this.ch()),"'"));return this._pos++,this.modeStack.push("obj-value"),e}case"obj-value":return this.modeStack.pop(),this.modeStack.push("obj-key"),this.skipWhitespace(),this.parseValue();default:throw new Error("".concat(rW," unexpected parse state at position ").concat(this._pos,"; this shouldn't happen"))}}}const yQ=new TextEncoder,mQ=new TextDecoder,vQ="json",bQ=512,wQ=e=>yQ.encode(JSON.stringify(e)),EQ=e=>JSON.parse(mQ.decode(e)),AQ="raw",SQ=85,_Q=e=>LV(e),IQ=e=>LV(e),CQ={codec:Qo.code,async*walk(e){const t=Qo.decode(e);yield*t.Links.map((e=>e.Hash))}},TQ={codec:SQ,async*walk(){}},kQ={codec:ti.code,async*walk(e){const t=[],n=[];n[42]=e=>{if(0!==e[0])throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");const n=YH.decode(e.subarray(1));return t.push(n),n},hQ(e,{tags:n}),yield*t}};class RQ extends gQ{constructor(e,t){super(e,t),(0,Yo.Z)(this,"tokenBuffer",void 0),this.tokenBuffer=[]}done(){return 0===this.tokenBuffer.length&&super.done()}_next(){return this.tokenBuffer.length>0?this.tokenBuffer.pop():super.next()}next(){const e=this._next();if(e.type===FG.map){const e=this._next();if(e.type===FG.string&&"/"===e.value){const e=this._next();if(e.type===FG.string){if(this._next().type!==FG.break)throw new Error("Invalid encoded CID form");return this.tokenBuffer.push(e),new KG(FG.tag,42,0)}if(e.type===FG.map){const e=this._next();if(e.type===FG.string&&"bytes"===e.value){const e=this._next();if(e.type===FG.string){for(let e=0;e<2;e++){if(this._next().type!==FG.break)throw new Error("Invalid encoded Bytes form")}const t=nH.decode("m".concat(e.value));return new KG(FG.bytes,t,e.value.length)}this.tokenBuffer.push(e)}this.tokenBuffer.push(e)}this.tokenBuffer.push(e)}this.tokenBuffer.push(e)}return e}}const xQ=[TQ,CQ,kQ,{codec:pQ.code,async*walk(e){const t=[],n=[];var r,i;n[42]=e=>{const n=YH.parse(e);return t.push(n),n},r=e,i={tags:n,tokenizer:new RQ(e,{tags:n,allowIndefinite:!0,allowUndefined:!0,allowNaN:!0,allowInfinity:!0,allowBigInt:!0,strict:!1,rejectDuplicateMapKeys:!1})},hQ(r,i=Object.assign({tokenizer:new gQ(r,i)},i)),yield*t}},{codec:bQ,async*walk(){}}],PQ="/pin/",DQ="/pinned-block/",OQ=dQ;function NQ(e){return 0===e.version&&(e=e.toV1()),new hH("".concat(PQ).concat(e.toString(OQ)))}var BQ=new WeakSet,LQ=new WeakSet;class MQ{constructor(e,t,n){Qd(this,LQ),Qd(this,BQ),(0,Yo.Z)(this,"datastore",void 0),(0,Yo.Z)(this,"blockstore",void 0),(0,Yo.Z)(this,"dagWalkers",void 0),this.datastore=e,this.blockstore=t,this.dagWalkers={},[...xQ,...n].forEach((e=>{this.dagWalkers[e.codec]=e}))}async add(e){var t,n;let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const i=NQ(e);if(await this.datastore.has(i))throw new Error("Already pinned");const o=Math.round(null!==(t=r.depth)&&void 0!==t?t:1/0);if(o<0)throw new Error("Depth must be greater than or equal to 0");const s=new Bm.Z({concurrency:1});s.add((async()=>{await Yd(this,BQ,UQ).call(this,e,s,(t=>{null==t.pinnedBy.find((t=>(0,Ms.f)(t,e.bytes)))&&(t.pinCount++,t.pinnedBy.push(e.bytes))}),{...r,depth:o})}));const a=Ws();s.on("error",(e=>{s.clear(),a.reject(e)})),await Promise.race([s.onIdle(),a.promise]);const c={depth:o,metadata:null!==(n=r.metadata)&&void 0!==n?n:{}};return await this.datastore.put(i,oQ(c),r),{cid:e,...c}}async rm(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=NQ(e),r=hQ(await this.datastore.get(n,t));await this.datastore.delete(n,t);const i=new Bm.Z({concurrency:1});return i.add((async()=>{await Yd(this,BQ,UQ).call(this,e,i,(t=>{t.pinCount--,t.pinnedBy=t.pinnedBy.filter((t=>(0,Ms.f)(t,e.bytes)))}),{...t,depth:r.depth})})),await i.onIdle(),{cid:e,...r}}ls(){try{var e=this;let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return async function*(){for await(const{key:n,value:r}of e.datastore.query({prefix:PQ+(null!=t.cid?"".concat(t.cid.toString(dQ)):"")},t)){const e=YH.parse(n.toString().substring(5),dQ),t=hQ(r);yield{cid:e,...t}}}()}catch(t){return Promise.reject(t)}}async isPinned(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=new hH("".concat(DQ).concat(OQ.encode(e.multihash.bytes)));return this.datastore.has(n,t)}}async function UQ(e,t,n,r){if(-1===r.depth)return;const i=this.dagWalkers[e.code];if(null==i)throw new Error("No dag walker found for cid codec ".concat(e.code));const o=await this.blockstore.get(e,r);await Yd(this,LQ,FQ).call(this,e,n,r);for await(const s of i.walk(o))t.add((async()=>{await Yd(this,BQ,UQ).call(this,s,t,n,{...r,depth:r.depth-1})}))}async function FQ(e,t,n){var r;const i=new hH("".concat(DQ).concat(OQ.encode(e.multihash.bytes)));let o={pinCount:0,pinnedBy:[]};try{o=hQ(await this.datastore.get(i,n))}catch(s){if("ERR_NOT_FOUND"!==s.code)throw s}t(o),0===o.pinCount&&await this.datastore.has(i)?await this.datastore.delete(i):(await this.datastore.put(i,oQ(o),n),null===(r=n.onProgress)||void 0===r||r.call(n,new AH("helia:pin:add",{detail:e})))}const KQ="lock:worker:request-read",jQ="lock:worker:release-read",ZQ="lock:master:grant-read",zQ="lock:worker:request-write",VQ="lock:worker:release-write",HQ="lock:master:grant-write",qQ={},GQ=e=>{e.addEventListener("message",(t=>{GQ.dispatchEvent("message",e,t)})),null!=e.port&&e.port.addEventListener("message",(t=>{GQ.dispatchEvent("message",e,t)}))};GQ.addEventListener=(e,t)=>{null==qQ[e]&&(qQ[e]=[]),qQ[e].push(t)},GQ.removeEventListener=(e,t)=>{null!=qQ[e]&&(qQ[e]=qQ[e].filter((e=>e===t)))},GQ.dispatchEvent=function(e,t,n){null!=qQ[e]&&qQ[e].forEach((e=>e(t,n)))};const WQ=GQ,QQ=(e,t,n,r,i)=>(o,s)=>{if(s.data.type!==n)return;const a={type:s.data.type,name:s.data.name,identifier:s.data.identifier};e.dispatchEvent(new MessageEvent(t,{data:{name:a.name,handler:async()=>(o.postMessage({type:i,name:a.name,identifier:a.identifier}),await new Promise((e=>{const t=n=>{if(null==n||null==n.data)return;const i=n.data.type,s=(n.data.name,n.data.identifier);i===r&&s===a.identifier&&(o.removeEventListener("message",t),e())};o.addEventListener("message",t)})))}}))},YQ=(e,t,n,r)=>async()=>{const i=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:21;return crypto.getRandomValues(new Uint8Array(e)).reduce(((e,t)=>e+((t&=63)<36?t.toString(36):t<62?(t-26).toString(36).toUpperCase():t>62?"-":"_")),"")}();return globalThis.postMessage({type:t,identifier:i,name:e}),await new Promise((t=>{const o=s=>{if(null==s||null==s.data)return;const a=s.data.type,c=s.data.identifier;a===n&&c===i&&(globalThis.removeEventListener("message",o),t((()=>{globalThis.postMessage({type:r,identifier:i,name:e})})))};globalThis.addEventListener("message",o)}))},JQ={singleProcess:!1},XQ={};let $Q;async function eY(e,t){let n;const r=new Promise((e=>{n=e}));return e.add((async()=>await YB((async()=>await new Promise((e=>{n((()=>{e()}))})))(),{milliseconds:t.timeout}))),await r}const tY={name:"lock",concurrency:1/0,timeout:846e5,singleProcess:!1};function nY(e){const t=Object.assign({},tY,e);return null==$Q&&($Q=(e=>{if(e=Object.assign({},JQ,e),Boolean(globalThis.document)||e.singleProcess){const e=new EventTarget;return WQ.addEventListener("message",QQ(e,"requestReadLock",KQ,jQ,ZQ)),WQ.addEventListener("message",QQ(e,"requestWriteLock",zQ,VQ,HQ)),e}return{isWorker:!0,readLock:e=>YQ(e,KQ,ZQ,jQ),writeLock:e=>YQ(e,zQ,HQ,VQ)}})(t),!0!==$Q.isWorker&&($Q.addEventListener("requestReadLock",(e=>{null!=XQ[e.data.name]&&XQ[e.data.name].readLock().then((async t=>await e.data.handler().finally((()=>t()))))})),$Q.addEventListener("requestWriteLock",(async e=>{null!=XQ[e.data.name]&&XQ[e.data.name].writeLock().then((async t=>await e.data.handler().finally((()=>t()))))})))),null==XQ[t.name]&&(XQ[t.name]=((e,t)=>{if(!0===$Q.isWorker)return{readLock:$Q.readLock(e,t),writeLock:$Q.writeLock(e,t)};const n=new Bm.Z({concurrency:1});let r;return{async readLock(){if(null!=r)return await eY(r,t);r=new Bm.Z({concurrency:t.concurrency,autoStart:!1});const e=r,i=eY(r,t);return n.add((async()=>(e.start(),await e.onIdle().then((()=>{r===e&&(r=null)}))))),await i},writeLock:async()=>(r=null,await eY(n,t))}})(t.name,t)),XQ[t.name]}class rY{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};(0,Yo.Z)(this,"lock",void 0),(0,Yo.Z)(this,"child",void 0),(0,Yo.Z)(this,"pins",void 0),(0,Yo.Z)(this,"started",void 0),this.child=e,this.pins=t,this.lock=nY({singleProcess:n.holdGcLock}),this.started=!1}isStarted(){return this.started}async start(){await wH(this.child),this.started=!0}async stop(){await EH(this.child),this.started=!1}unwrap(){return this.child}async put(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=await this.lock.readLock();try{return await this.child.put(e,t,n)}finally{r()}}putMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){const r=await t.lock.readLock();try{yield*t.child.putMany(e,n)}finally{r()}}()}catch(n){return Promise.reject(n)}}async get(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await this.lock.readLock();try{return await this.child.get(e,t)}finally{n()}}getMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){const r=await t.lock.readLock();try{yield*t.child.getMany(e,n)}finally{r()}}()}catch(n){return Promise.reject(n)}}async delete(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await this.lock.writeLock();try{if(await this.pins.isPinned(e))throw new Error("CID was pinned");await this.child.delete(e,t)}finally{n()}}deleteMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(){const r=await t.lock.writeLock();try{const r=t;yield*t.child.deleteMany(async function*(){for await(const t of e){if(await r.pins.isPinned(t))throw new Error("CID was pinned");yield t}}(),n)}finally{r()}}()}catch(n){return Promise.reject(n)}}async has(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=await this.lock.readLock();try{return await this.child.has(e,t)}finally{n()}}getAll(){try{var e=this;let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return async function*(){const n=await e.lock.readLock();try{yield*e.child.getAll(t)}finally{n()}}()}catch(t){return Promise.reject(t)}}}const iY=new hH("/version");const oY=LV,sY={code:0,name:"identity",encode:oY,digest:e=>VH(0,oY(e))};const aY=aH("helia:networked-storage");function cY(e){return"function"===typeof e.retrieve}function lY(e){return"function"===typeof e.announce}class uY{constructor(e,t){var n,r,i;(0,Yo.Z)(this,"child",void 0),(0,Yo.Z)(this,"blockRetrievers",void 0),(0,Yo.Z)(this,"blockAnnouncers",void 0),(0,Yo.Z)(this,"hashers",void 0),(0,Yo.Z)(this,"started",void 0),this.child=e,this.blockRetrievers=(null!==(n=t.blockBrokers)&&void 0!==n?n:[]).filter(cY),this.blockAnnouncers=(null!==(r=t.blockBrokers)&&void 0!==r?r:[]).filter(lY),this.hashers=null!==(i=t.hashers)&&void 0!==i?i:[],this.started=!1}isStarted(){return this.started}async start(){await wH(this.child,...new Set([...this.blockRetrievers,...this.blockAnnouncers])),this.started=!0}async stop(){await EH(this.child,...new Set([...this.blockRetrievers,...this.blockAnnouncers])),this.started=!1}unwrap(){return this.child}async put(e,t){var n,r;let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};var o;return await this.child.has(e)?(null===(o=i.onProgress)||void 0===o||o.call(i,new AH("blocks:put:duplicate",e)),e):(null===(n=i.onProgress)||void 0===n||n.call(i,new AH("blocks:put:providers:notify",e)),this.blockAnnouncers.forEach((n=>{n.announce(e,t,i)})),null===(r=i.onProgress)||void 0===r||r.call(i,new AH("blocks:put:blockstore:put",e)),this.child.put(e,t,i))}putMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(r){const i=gH(e,(async e=>{let{cid:r}=e;const i=await t.child.has(r);var o;i&&(null===(o=n.onProgress)||void 0===o||o.call(n,new AH("blocks:put-many:duplicate",r)));return!i})),o=jd(i,(e=>{var r;let{cid:i,block:o}=e;null===(r=n.onProgress)||void 0===r||r.call(n,new AH("blocks:put-many:providers:notify",i)),t.blockAnnouncers.forEach((e=>{e.announce(i,o,n)}))}));null===(r=n.onProgress)||void 0===r||r.call(n,new AH("blocks:put-many:blockstore:put-many")),yield*t.child.putMany(o,n)}()}catch(n){return Promise.reject(n)}}async get(e){var t;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!0!==n.offline&&!await this.child.has(e)){var r,i,o;null===(r=n.onProgress)||void 0===r||r.call(n,new AH("blocks:get:providers:get",e));const t=await dY(e,this.blockRetrievers,this.hashers,n);return null===(i=n.onProgress)||void 0===i||i.call(n,new AH("blocks:get:blockstore:put",e)),await this.child.put(e,t,n),null===(o=n.onProgress)||void 0===o||o.call(n,new AH("blocks:get:providers:notify",e)),this.blockAnnouncers.forEach((r=>{r.announce(e,t,n)})),t}return null===(t=n.onProgress)||void 0===t||t.call(n,new AH("blocks:get:blockstore:get",e)),this.child.get(e,n)}getMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(r){null===(r=n.onProgress)||void 0===r||r.call(n,new AH("blocks:get-many:blockstore:get-many")),yield*t.child.getMany(jd(e,(async e=>{if(!0!==n.offline&&!await t.child.has(e)){var r,i,o;null===(r=n.onProgress)||void 0===r||r.call(n,new AH("blocks:get-many:providers:get",e));const s=await dY(e,t.blockRetrievers,t.hashers,n);null===(i=n.onProgress)||void 0===i||i.call(n,new AH("blocks:get-many:blockstore:put",e)),await t.child.put(e,s,n),null===(o=n.onProgress)||void 0===o||o.call(n,new AH("blocks:get-many:providers:notify",e)),t.blockAnnouncers.forEach((t=>{t.announce(e,s,n)}))}})))}()}catch(n){return Promise.reject(n)}}async delete(e){var t;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};null===(t=n.onProgress)||void 0===t||t.call(n,new AH("blocks:delete:blockstore:delete",e)),await this.child.delete(e,n)}deleteMany(e){try{var t=this;let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return async function*(r){null===(r=n.onProgress)||void 0===r||r.call(n,new AH("blocks:delete-many:blockstore:delete-many")),yield*t.child.deleteMany(async function*(){for await(const t of e)yield t}(),n)}()}catch(n){return Promise.reject(n)}}async has(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return this.child.has(e,t)}getAll(){try{var e=this;let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return async function*(n){null===(n=t.onProgress)||void 0===n||n.call(t,new AH("blocks:get-all:blockstore:get-many")),yield*e.child.getAll(t)}()}catch(t){return Promise.reject(t)}}}const hY=(e,t)=>{const n=t.find((t=>t.code===e.multihash.code));if(null==n)throw new aq("No hasher configured for multihash code 0x".concat(e.multihash.code.toString(16),", please configure one. You can look up which hash this is at https://github.com/multiformats/multicodec/blob/master/table.csv"),"ERR_UNKNOWN_HASH_ALG");return async t=>{const r=await n.digest(t);if(!(0,Ms.f)(r.digest,e.multihash.digest))throw new aq("Hash of downloaded block did not match multihash from passed CID","ERR_HASH_MISMATCH")}};async function dY(e,t,n,r){const i=hY(e,n),o=SH([(new AbortController).signal,r.signal]);try{return await Promise.any(t.map((async t=>{try{let n=!1;const s=await t.retrieve(e,{...r,signal:o,validateFn:async e=>{await i(e),n=!0}});return n||await i(s),s}catch(n){throw aY.error("could not retrieve verified block for %c",e,n),n}})))}finally{o.clear()}}const fY=aH("helia");class pY{constructor(e){var t,n,r;(0,Yo.Z)(this,"libp2p",void 0),(0,Yo.Z)(this,"blockstore",void 0),(0,Yo.Z)(this,"datastore",void 0),(0,Yo.Z)(this,"pins",void 0);const i=function(){return[pq,gq,sY,...arguments.length>0&&void 0!==arguments[0]?arguments[0]:[]]}(e.hashers),o={blockstore:e.blockstore,datastore:e.datastore,libp2p:e.libp2p,hashers:i},s=null!==(t=null===(n=e.blockBrokers)||void 0===n?void 0:n.map((e=>e(o))))&&void 0!==t?t:[_G()(o),BG()()],a=new uY(e.blockstore,{blockBrokers:s,hashers:i});this.pins=new MQ(e.datastore,a,null!==(r=e.dagWalkers)&&void 0!==r?r:[]),this.libp2p=e.libp2p,this.blockstore=new rY(a,this.pins,{holdGcLock:e.holdGcLock}),this.datastore=e.datastore}async start(){await async function(e){if(!await e.has(iY))return void await e.put(iY,(0,yu.m)("".concat(1)));const t=await e.get(iY),n=(0,Au.B)(t);if(1!==parseInt(n,10))throw new Error("Unknown datastore version, a datastore migration may be required")}(this.datastore),await wH(this.blockstore),await this.libp2p.start()}async stop(){await this.libp2p.stop(),await EH(this.blockstore)}async gc(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t=await this.blockstore.lock.writeLock();try{const t=this,n=this.blockstore.unwrap();fY("gc start"),await fH(n.deleteMany(async function*(){for await(const{cid:s}of n.getAll())try{var r;if(await t.pins.isPinned(s,e))continue;yield s,null===(r=e.onProgress)||void 0===r||r.call(e,new AH("helia:gc:deleted",s))}catch(o){var i;fY.error("Error during gc",o),null===(i=e.onProgress)||void 0===i||i.call(e,new AH("helia:gc:error",o))}}()))}finally{t()}fY("gc finished")}}const gY=32,yY=64,mY=32;function vY(e,t){const n=new Uint8Array(yY);for(let r=0;r<mY;r++)n[r]=e[r],n[mY+r]=t[r];return n}const bY={get(){const e=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:globalThis).crypto;if(null==e||null==e.subtle)throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"),{code:"ERR_MISSING_WEB_CRYPTO"});return e}},wY={alg:"A128GCM",ext:!0,k:"scm9jmO_4BJAgdwWGVulLg",key_ops:["encrypt","decrypt"],kty:"oct"};async function EY(e,t){const n=function(e){var t,n,r,i,o,s;const a=null!==(t=null===e||void 0===e?void 0:e.algorithm)&&void 0!==t?t:"AES-GCM";let c=null!==(n=null===e||void 0===e?void 0:e.keyLength)&&void 0!==n?n:16;const l=null!==(r=null===e||void 0===e?void 0:e.nonceLength)&&void 0!==r?r:12,u=null!==(i=null===e||void 0===e?void 0:e.digest)&&void 0!==i?i:"SHA-256",h=null!==(o=null===e||void 0===e?void 0:e.saltLength)&&void 0!==o?o:16,d=null!==(s=null===e||void 0===e?void 0:e.iterations)&&void 0!==s?s:32767,f=bY.get();return c*=8,{encrypt:async function(e,t){const n=f.getRandomValues(new Uint8Array(h)),r=f.getRandomValues(new Uint8Array(l)),i={name:a,iv:r};let o;if("string"===typeof t&&(t=(0,yu.m)(t)),0===t.length){o=await f.subtle.importKey("jwk",wY,{name:"AES-GCM"},!0,["encrypt"]);try{const e={name:"PBKDF2",salt:n,iterations:d,hash:{name:u}},r=await f.subtle.importKey("raw",t,{name:"PBKDF2"},!1,["deriveKey"]);o=await f.subtle.deriveKey(e,r,{name:a,length:c},!0,["encrypt"])}catch{o=await f.subtle.importKey("jwk",wY,{name:"AES-GCM"},!0,["encrypt"])}}else{const e={name:"PBKDF2",salt:n,iterations:d,hash:{name:u}},r=await f.subtle.importKey("raw",t,{name:"PBKDF2"},!1,["deriveKey"]);o=await f.subtle.deriveKey(e,r,{name:a,length:c},!0,["encrypt"])}const s=await f.subtle.encrypt(i,o,e);return(0,Ls.z)([n,i.iv,new Uint8Array(s)])},decrypt:async function(e,t){const n=e.subarray(0,h),r=e.subarray(h,h+l),i=e.subarray(h+l),o={name:a,iv:r};let s;if("string"===typeof t&&(t=(0,yu.m)(t)),0===t.length)try{const e={name:"PBKDF2",salt:n,iterations:d,hash:{name:u}},r=await f.subtle.importKey("raw",t,{name:"PBKDF2"},!1,["deriveKey"]);s=await f.subtle.deriveKey(e,r,{name:a,length:c},!0,["decrypt"])}catch{s=await f.subtle.importKey("jwk",wY,{name:"AES-GCM"},!0,["decrypt"])}else{const e={name:"PBKDF2",salt:n,iterations:d,hash:{name:u}},r=await f.subtle.importKey("raw",t,{name:"PBKDF2"},!1,["deriveKey"]);s=await f.subtle.deriveKey(e,r,{name:a,length:c},!0,["decrypt"])}const p=await f.subtle.decrypt(o,s,i);return new Uint8Array(p)}}}(),r=await n.encrypt(e,t);return nH.encode(r)}var AY,SY,_Y,IY;!function(e){e.RSA="RSA",e.Ed25519="Ed25519",e.Secp256k1="Secp256k1"}(AY||(AY={})),function(e){e[e.RSA=0]="RSA",e[e.Ed25519=1]="Ed25519",e[e.Secp256k1=2]="Secp256k1"}(SY||(SY={})),function(e){e.codec=()=>bs(SY)}(AY||(AY={})),function(e){let t;e.codec=()=>(null==t&&(t=ws((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==n.lengthDelimited&&t.fork(),null!=e.Type&&(t.uint32(8),AY.codec().encode(e.Type,t)),null!=e.Data&&(t.uint32(18),t.bytes(e.Data)),!1!==n.lengthDelimited&&t.ldelim()}),((e,t)=>{const n={},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 1:n.Type=AY.codec().decode(e);break;case 2:n.Data=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(_Y||(_Y={})),function(e){let t;e.codec=()=>(null==t&&(t=ws((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==n.lengthDelimited&&t.fork(),null!=e.Type&&(t.uint32(8),AY.codec().encode(e.Type,t)),null!=e.Data&&(t.uint32(18),t.bytes(e.Data)),!1!==n.lengthDelimited&&t.ldelim()}),((e,t)=>{const n={},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 1:n.Type=AY.codec().decode(e);break;case 2:n.Data=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(IY||(IY={}));class CY{constructor(e){(0,Yo.Z)(this,"_key",void 0),this._key=DY(e,gY)}async verify(e,t){return async function(e,t,n){return ql.verify(t,n,e)}(this._key,t,e)}marshal(){return this._key}get bytes(){return _Y.encode({Type:AY.Ed25519,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await pq.digest(this.bytes);return e}}class TY{constructor(e,t){(0,Yo.Z)(this,"_key",void 0),(0,Yo.Z)(this,"_publicKey",void 0),this._key=DY(e,yY),this._publicKey=DY(t,gY)}async sign(e){return async function(e,t){const n=e.subarray(0,mY);return ql.sign(t,n)}(this._key,e)}get public(){return new CY(this._publicKey)}marshal(){return this._key}get bytes(){return IY.encode({Type:AY.Ed25519,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await pq.digest(this.bytes);return e}async id(){const e=sY.digest(this.public.bytes);return eH.encode(e.bytes).substring(1)}async export(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"libp2p-key";if("libp2p-key"===t)return EY(this.bytes,e);throw new aq("export format '".concat(t,"' is not supported"),"ERR_INVALID_EXPORT_FORMAT")}}function kY(e){if(e.length>yY){const t=(e=DY(e,yY+gY)).subarray(0,yY),n=e.subarray(yY,e.length);return new TY(t,n)}const t=(e=DY(e,yY)).subarray(0,yY),n=e.subarray(gY);return new TY(t,n)}function RY(e){return e=DY(e,gY),new CY(e)}async function xY(){const{privateKey:e,publicKey:t}=await async function(){const e=ql.utils.randomPrivateKey(),t=ql.getPublicKey(e);return{privateKey:vY(e,t),publicKey:t}}();return new TY(e,t)}async function PY(e){const{privateKey:t,publicKey:n}=await async function(e){if(e.length!==mY)throw new TypeError('"seed" must be 32 bytes in length.');if(!(e instanceof Uint8Array))throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');const t=e,n=ql.getPublicKey(t);return{privateKey:vY(t,n),publicKey:n}}(e);return new TY(t,n)}function DY(e,t){var n;if((e=Uint8Array.from(null!==(n=e)&&void 0!==n?n:[])).length!==t)throw new aq("Key must be a Uint8Array of length ".concat(t,", got ").concat(e.length),"ERR_INVALID_KEY_TYPE");return e}function OY(e,t){let n=Uint8Array.from(e.abs().toByteArray());if(n=0===n[0]?n.subarray(1):n,null!=t){if(n.length>t)throw new Error("byte array longer than desired length");n=(0,Ls.z)([new Uint8Array(t-n.length),n])}return(0,Au.B)(n,"base64url")}function NY(e){const t=function(e,t){let n=(0,yu.m)(e,"base64urlpad");if(null!=t){if(n.length>t)throw new Error("byte array longer than desired length");n=(0,Ls.z)([new Uint8Array(t-n.length),n])}return n}(e);return new(gu().jsbn.BigInteger)((0,Au.B)(t,"base16"),16)}const BY={"P-256":256,"P-384":384,"P-521":521};Object.keys(BY).join(" / ");function LY(e){if(isNaN(e)||e<=0)throw new aq("random bytes length must be a Number bigger than 0","ERR_INVALID_LENGTH");return _c(e)}function MY(e,t){return t.map((t=>NY(e[t])))}async function UY(e){const t=[await bY.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["sign"]),await KY(e)],n=await FY({privateKey:t[0],publicKey:t[1]});return{privateKey:n[0],publicKey:n[1]}}async function FY(e){if(null==e.privateKey||null==e.publicKey)throw new aq("Private and public key are required","ERR_INVALID_PARAMETERS");return Promise.all([bY.get().subtle.exportKey("jwk",e.privateKey),bY.get().subtle.exportKey("jwk",e.publicKey)])}async function KY(e){return bY.get().subtle.importKey("jwk",{kty:e.kty,n:e.n,e:e.e},{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["verify"])}function jY(e,t,n,r){const i=t?function(e){return gu().pki.setRsaPublicKey(...MY(e,["n","e"]))}(e):function(e){return gu().pki.setRsaPrivateKey(...MY(e,["n","e","d","p","q","dp","dq","qi"]))}(e),o=r((0,Au.B)(Uint8Array.from(n),"ascii"),i);return(0,yu.m)(o,"ascii")}function ZY(e){if("RSA"!==e.kty)throw new aq("invalid key type","ERR_INVALID_KEY_TYPE");if(null==e.n)throw new aq("invalid key modulus","ERR_INVALID_KEY_MODULUS");return 8*(0,yu.m)(e.n,"base64url").length}const zY=8192;class VY{constructor(e){(0,Yo.Z)(this,"_key",void 0),this._key=e}async verify(e,t){return async function(e,t,n){const r=await bY.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);return bY.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},r,t,n)}(this._key,t,e)}marshal(){return function(e){if(null==e.n||null==e.e)throw new aq("JWK was missing components","ERR_INVALID_PARAMETERS");const t=gu().pki.publicKeyToAsn1({n:NY(e.n),e:NY(e.e)});return(0,yu.m)(gu().asn1.toDer(t).getBytes(),"ascii")}(this._key)}get bytes(){return _Y.encode({Type:AY.RSA,Data:this.marshal()}).subarray()}encrypt(e){return jY(this._key,!0,e,((e,t)=>t.encrypt(e)))}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await pq.digest(this.bytes);return e}}class HY{constructor(e,t){(0,Yo.Z)(this,"_key",void 0),(0,Yo.Z)(this,"_publicKey",void 0),this._key=e,this._publicKey=t}genSecret(){return LY(16)}async sign(e){return async function(e,t){const n=await bY.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["sign"]),r=await bY.get().subtle.sign({name:"RSASSA-PKCS1-v1_5"},n,Uint8Array.from(t));return new Uint8Array(r,0,r.byteLength)}(this._key,e)}get public(){if(null==this._publicKey)throw new aq("public key not provided","ERR_PUBKEY_NOT_PROVIDED");return new VY(this._publicKey)}decrypt(e){return jY(this._key,!1,e,((e,t)=>t.decrypt(e)))}marshal(){return function(e){if(null==e.n||null==e.e||null==e.d||null==e.p||null==e.q||null==e.dp||null==e.dq||null==e.qi)throw new aq("JWK was missing components","ERR_INVALID_PARAMETERS");const t=gu().pki.privateKeyToAsn1({n:NY(e.n),e:NY(e.e),d:NY(e.d),p:NY(e.p),q:NY(e.q),dP:NY(e.dp),dQ:NY(e.dq),qInv:NY(e.qi)});return(0,yu.m)(gu().asn1.toDer(t).getBytes(),"ascii")}(this._key)}get bytes(){return IY.encode({Type:AY.RSA,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await pq.digest(this.bytes);return e}async id(){const e=await this.public.hash();return(0,Au.B)(e,"base58btc")}async export(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"pkcs-8";if("pkcs-8"===t){const t=new(gu().util.ByteBuffer)(this.marshal()),n=gu().asn1.fromDer(t),r=gu().pki.privateKeyFromAsn1(n),i={algorithm:"aes256",count:1e4,saltSize:16,prfAlgorithm:"sha512"};return gu().pki.encryptRsaPrivateKey(r,e,i)}if("libp2p-key"===t)return EY(this.bytes,e);throw new aq("export format '".concat(t,"' is not supported"),"ERR_INVALID_EXPORT_FORMAT")}}async function qY(e){const t=function(e){const t=gu().asn1.fromDer((0,Au.B)(e,"ascii")),n=gu().pki.privateKeyFromAsn1(t);return{kty:"RSA",n:OY(n.n),e:OY(n.e),d:OY(n.d),p:OY(n.p),q:OY(n.q),dp:OY(n.dP),dq:OY(n.dQ),qi:OY(n.qInv),alg:"RS256"}}(e);if(ZY(t)>zY)throw new aq("key size is too large","ERR_KEY_SIZE_TOO_LARGE");const n=await UY(t);return new HY(n.privateKey,n.publicKey)}function GY(e){const t=function(e){const t=gu().asn1.fromDer((0,Au.B)(e,"ascii")),n=gu().pki.publicKeyFromAsn1(t);return{kty:"RSA",n:OY(n.n),e:OY(n.e)}}(e);if(ZY(t)>zY)throw new aq("key size is too large","ERR_KEY_SIZE_TOO_LARGE");return new VY(t)}async function WY(e){if(ZY(e)>zY)throw new aq("key size is too large","ERR_KEY_SIZE_TOO_LARGE");const t=await UY(e);return new HY(t.privateKey,t.publicKey)}async function QY(e){if(e>zY)throw new aq("key size is too large","ERR_KEY_SIZE_TOO_LARGE");const t=await async function(e){const t=await bY.get().subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:e,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),n=await FY(t);return{privateKey:n[0],publicKey:n[1]}}(e);return new HY(t.privateKey,t.publicKey)}function YY(e){try{Eh.ProjectivePoint.fromHex(e)}catch(t){throw new aq(String(t),"ERR_INVALID_PUBLIC_KEY")}}class JY{constructor(e){(0,Yo.Z)(this,"_key",void 0),YY(e),this._key=e}async verify(e,t){return async function(e,t,n){try{const{digest:r}=await pq.digest(n);return Eh.verify(t,r,e)}catch(r){throw new aq(String(r),"ERR_INVALID_INPUT")}}(this._key,t,e)}marshal(){return e=this._key,Eh.ProjectivePoint.fromHex(e).toRawBytes(!0);var e}get bytes(){return _Y.encode({Type:AY.Secp256k1,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await pq.digest(this.bytes);return e}}class XY{constructor(e,t){(0,Yo.Z)(this,"_key",void 0),(0,Yo.Z)(this,"_publicKey",void 0),this._key=e,this._publicKey=null!==t&&void 0!==t?t:function(e){try{return Eh.getPublicKey(e,!0)}catch(t){throw new aq(String(t),"ERR_INVALID_PRIVATE_KEY")}}(e),function(e){try{Eh.getPublicKey(e,!0)}catch(t){throw new aq(String(t),"ERR_INVALID_PRIVATE_KEY")}}(this._key),YY(this._publicKey)}async sign(e){return async function(e,t){const{digest:n}=await pq.digest(t);try{return Eh.sign(n,e).toDERRawBytes()}catch(r){throw new aq(String(r),"ERR_INVALID_INPUT")}}(this._key,e)}get public(){return new JY(this._publicKey)}marshal(){return this._key}get bytes(){return IY.encode({Type:AY.Secp256k1,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await pq.digest(this.bytes);return e}async id(){const e=await this.public.hash();return(0,Au.B)(e,"base58btc")}async export(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"libp2p-key";if("libp2p-key"===t)return EY(this.bytes,e);throw new aq("export format '".concat(t,"' is not supported"),"ERR_INVALID_EXPORT_FORMAT")}}function $Y(e){return new XY(e)}function eJ(e){return new JY(e)}async function tJ(){const e=Eh.utils.randomPrivateKey();return new XY(e)}const nJ={rsa:Yt,ed25519:Qt,secp256k1:Jt};function rJ(e){const t=Object.keys(nJ).join(" / ");return new aq("invalid or unsupported key type ".concat(e,". Must be ").concat(t),"ERR_UNSUPPORTED_KEY_TYPE")}function iJ(e){var t,n;const r=_Y.decode(e),i=null!==(t=r.Data)&&void 0!==t?t:new Uint8Array;switch(r.Type){case AY.RSA:return nJ.rsa.unmarshalRsaPublicKey(i);case AY.Ed25519:return nJ.ed25519.unmarshalEd25519PublicKey(i);case AY.Secp256k1:return nJ.secp256k1.unmarshalSecp256k1PublicKey(i);default:throw rJ(null!==(n=r.Type)&&void 0!==n?n:"unknown")}}async function oJ(e){var t,n;const r=IY.decode(e),i=null!==(t=r.Data)&&void 0!==t?t:new Uint8Array;switch(r.Type){case AY.RSA:return nJ.rsa.unmarshalRsaPrivateKey(i);case AY.Ed25519:return nJ.ed25519.unmarshalEd25519PrivateKey(i);case AY.Secp256k1:return nJ.secp256k1.unmarshalSecp256k1PrivateKey(i);default:throw rJ(null!==(n=r.Type)&&void 0!==n?n:"RSA")}}const sJ=Symbol.for("@libp2p/content-routing");var aJ,cJ=new WeakMap;class lJ extends EventTarget{constructor(){super(...arguments),(0,dx.Z)(this,cJ,{writable:!0,value:new Map})}listenerCount(e){const t=(0,fx.Z)(this,cJ).get(e);return null==t?0:t.length}addEventListener(e,t,n){var r;super.addEventListener(e,t,n);let i=(0,fx.Z)(this,cJ).get(e);null==i&&(i=[],(0,fx.Z)(this,cJ).set(e,i)),i.push({callback:t,once:null!==(r=!0!==n&&!1!==n&&(null===n||void 0===n?void 0:n.once))&&void 0!==r&&r})}removeEventListener(e,t,n){super.removeEventListener(e.toString(),null!==t&&void 0!==t?t:null,n);let r=(0,fx.Z)(this,cJ).get(e);null!=r&&(r=r.filter((e=>{let{callback:n}=e;return n!==t})),(0,fx.Z)(this,cJ).set(e,r))}dispatchEvent(e){const t=super.dispatchEvent(e);let n=(0,fx.Z)(this,cJ).get(e.type);return null==n||(n=n.filter((e=>{let{once:t}=e;return!t})),(0,fx.Z)(this,cJ).set(e.type,n)),t}safeDispatchEvent(e,t){return this.dispatchEvent(new hJ(e,t))}}class uJ extends Event{constructor(e,t){super(e,t),(0,Yo.Z)(this,"detail",void 0),this.detail=null===t||void 0===t?void 0:t.detail}}const hJ=null!==(aJ=globalThis.CustomEvent)&&void 0!==aJ?aJ:uJ,dJ=function(e){try{for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r]}catch{}},fJ=Symbol.for("@libp2p/peer-discovery"),pJ=Symbol.for("@libp2p/peer-routing");class gJ extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"The operation was aborted"),(0,Yo.Z)(this,"code",void 0),(0,Yo.Z)(this,"type",void 0),this.code=gJ.code,this.type=gJ.type}}(0,Yo.Z)(gJ,"code","ABORT_ERR"),(0,Yo.Z)(gJ,"type","aborted");class yJ extends Error{constructor(e,t,n){var r;super(e),(0,Yo.Z)(this,"code",void 0),(0,Yo.Z)(this,"props",void 0),this.code=t,this.name=null!==(r=null===n||void 0===n?void 0:n.name)&&void 0!==r?r:"CodeError",this.props=null!==n&&void 0!==n?n:{}}}class mJ extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"Unexpected Peer"),(0,Yo.Z)(this,"code",void 0),this.code=mJ.code}}(0,Yo.Z)(mJ,"code","ERR_UNEXPECTED_PEER");class vJ extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"Invalid crypto exchange"),(0,Yo.Z)(this,"code",void 0),this.code=vJ.code}}(0,Yo.Z)(vJ,"code","ERR_INVALID_CRYPTO_EXCHANGE");class bJ extends Error{constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"Invalid crypto transmission"),(0,Yo.Z)(this,"code",void 0),this.code=bJ.code}}(0,Yo.Z)(bJ,"code","ERR_INVALID_CRYPTO_TRANSMISSION");n(18605);const wJ={get(){const e=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:globalThis).crypto;if(null==e||null==e.subtle)throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"),{code:"ERR_MISSING_WEB_CRYPTO"});return e}};var EJ=function(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var n=new Uint8Array(256),r=0;r<n.length;r++)n[r]=255;for(var i=0;i<e.length;i++){var o=e.charAt(i),s=o.charCodeAt(0);if(255!==n[s])throw new TypeError(o+" is ambiguous");n[s]=i}var a=e.length,c=e.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function h(e){if("string"!==typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var r=0,i=0;e[t]===c;)r++,t++;for(var o=(e.length-t)*l+1>>>0,s=new Uint8Array(o);e[t];){var u=n[e.charCodeAt(t)];if(255===u)return;for(var h=0,d=o-1;(0!==u||h<i)&&-1!==d;d--,h++)u+=a*s[d]>>>0,s[d]=u%256>>>0,u=u/256>>>0;if(0!==u)throw new Error("Non-zero carry");i=h,t++}if(" "!==e[t]){for(var f=o-i;f!==o&&0===s[f];)f++;for(var p=new Uint8Array(r+(o-f)),g=r;f!==o;)p[g++]=s[f++];return p}}}return{encode:function(t){if(t instanceof Uint8Array||(ArrayBuffer.isView(t)?t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength):Array.isArray(t)&&(t=Uint8Array.from(t))),!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(0===t.length)return"";for(var n=0,r=0,i=0,o=t.length;i!==o&&0===t[i];)i++,n++;for(var s=(o-i)*u+1>>>0,l=new Uint8Array(s);i!==o;){for(var h=t[i],d=0,f=s-1;(0!==h||d<r)&&-1!==f;f--,d++)h+=256*l[f]>>>0,l[f]=h%a>>>0,h=h/a>>>0;if(0!==h)throw new Error("Non-zero carry");r=d,i++}for(var p=s-r;p!==s&&0===l[p];)p++;for(var g=c.repeat(n);p<s;++p)g+=e.charAt(l[p]);return g},decodeUnsafe:h,decode:function(e){var n=h(e);if(n)return n;throw new Error("Non-".concat(t," character"))}}};const AJ=EJ,SJ=(new Uint8Array(0),e=>{if(e instanceof Uint8Array&&"Uint8Array"===e.constructor.name)return e;if(e instanceof ArrayBuffer)return new Uint8Array(e);if(ArrayBuffer.isView(e))return new Uint8Array(e.buffer,e.byteOffset,e.byteLength);throw new Error("Unknown type, must be binary type")});class _J{constructor(e,t,n){this.name=e,this.prefix=t,this.baseEncode=n}encode(e){if(e instanceof Uint8Array)return"".concat(this.prefix).concat(this.baseEncode(e));throw Error("Unknown type, must be binary type")}}class IJ{constructor(e,t,n){if(this.name=e,this.prefix=t,void 0===t.codePointAt(0))throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=n}decode(e){if("string"===typeof e){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error("Unable to decode multibase string ".concat(JSON.stringify(e),", ").concat(this.name," decoder only supports inputs prefixed with ").concat(this.prefix));return this.baseDecode(e.slice(this.prefix.length))}throw Error("Can only multibase decode strings")}or(e){return TJ(this,e)}}class CJ{constructor(e){this.decoders=e}or(e){return TJ(this,e)}decode(e){const t=e[0],n=this.decoders[t];if(n)return n.decode(e);throw RangeError("Unable to decode multibase string ".concat(JSON.stringify(e),", only inputs prefixed with ").concat(Object.keys(this.decoders)," are supported"))}}const TJ=(e,t)=>new CJ({...e.decoders||{[e.prefix]:e},...t.decoders||{[t.prefix]:t}});class kJ{constructor(e,t,n,r){this.name=e,this.prefix=t,this.baseEncode=n,this.baseDecode=r,this.encoder=new _J(e,t,n),this.decoder=new IJ(e,t,r)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const RJ=e=>{let{name:t,prefix:n,encode:r,decode:i}=e;return new kJ(t,n,r,i)},xJ=e=>{let{prefix:t,name:n,alphabet:r}=e;const{encode:i,decode:o}=AJ(r,n);return RJ({prefix:t,name:n,encode:i,decode:e=>SJ(o(e))})},PJ=e=>{let{name:t,prefix:n,bitsPerChar:r,alphabet:i}=e;return RJ({prefix:n,name:t,encode:e=>((e,t,n)=>{const r="="===t[t.length-1],i=(1<<n)-1;let o="",s=0,a=0;for(let c=0;c<e.length;++c)for(a=a<<8|e[c],s+=8;s>n;)s-=n,o+=t[i&a>>s];if(s&&(o+=t[i&a<<n-s]),r)for(;o.length*n&7;)o+="=";return o})(e,i,r),decode:e=>((e,t,n,r)=>{const i={};for(let u=0;u<t.length;++u)i[t[u]]=u;let o=e.length;for(;"="===e[o-1];)--o;const s=new Uint8Array(o*n/8|0);let a=0,c=0,l=0;for(let u=0;u<o;++u){const t=i[e[u]];if(void 0===t)throw new SyntaxError("Non-".concat(r," character"));c=c<<n|t,a+=n,a>=8&&(a-=8,s[l++]=255&c>>a)}if(a>=n||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return s})(e,i,r,t)})},DJ=xJ({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),OJ=xJ({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var NJ=function e(t,n,r){n=n||[];var i=r=r||0;for(;t>=MJ;)n[r++]=255&t|BJ,t/=128;for(;t&LJ;)n[r++]=255&t|BJ,t>>>=7;return n[r]=0|t,e.bytes=r-i+1,n},BJ=128,LJ=-128,MJ=Math.pow(2,31);var UJ=function e(t,n){var r,i=0,o=0,s=n=n||0,a=t.length;do{if(s>=a)throw e.bytes=0,new RangeError("Could not decode varint");r=t[s++],i+=o<28?(r&KJ)<<o:(r&KJ)*Math.pow(2,o),o+=7}while(r>=FJ);return e.bytes=s-n,i},FJ=128,KJ=127;var jJ=Math.pow(2,7),ZJ=Math.pow(2,14),zJ=Math.pow(2,21),VJ=Math.pow(2,28),HJ=Math.pow(2,35),qJ=Math.pow(2,42),GJ=Math.pow(2,49),WJ=Math.pow(2,56),QJ=Math.pow(2,63);const YJ={encode:NJ,decode:UJ,encodingLength:function(e){return e<jJ?1:e<ZJ?2:e<zJ?3:e<VJ?4:e<HJ?5:e<qJ?6:e<GJ?7:e<WJ?8:e<QJ?9:10}},JJ=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return[YJ.decode(e,t),YJ.decode.bytes]},XJ=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return YJ.encode(e,t,n),t},$J=e=>YJ.encodingLength(e),eX=(e,t)=>{const n=t.byteLength,r=$J(e),i=r+$J(n),o=new Uint8Array(i+n);return XJ(e,o,0),XJ(n,o,r),o.set(t,i),new nX(e,n,t,o)},tX=e=>{const t=SJ(e),[n,r]=JJ(t),[i,o]=JJ(t.subarray(r)),s=t.subarray(r+o);if(s.byteLength!==i)throw new Error("Incorrect length");return new nX(n,i,s,t)};class nX{constructor(e,t,n,r){this.code=e,this.size=t,this.digest=n,this.bytes=r}}const rX=SJ,iX={code:0,name:"identity",encode:rX,digest:e=>eX(0,rX(e))},oX=e=>{let{name:t,code:n,encode:r}=e;return new sX(t,n,r)};class sX{constructor(e,t,n){this.name=e,this.code=t,this.encode=n}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?eX(this.code,t):t.then((e=>eX(this.code,e)))}throw Error("Unknown type, must be binary type")}}const aX=e=>async t=>new Uint8Array(await crypto.subtle.digest(e,t)),cX=oX({name:"sha2-256",code:18,encode:aX("SHA-256")}),lX=oX({name:"sha2-512",code:19,encode:aX("SHA-512")}),uX=32,hX=64,dX=32;function fX(e,t){const n=new Uint8Array(hX);for(let r=0;r<dX;r++)n[r]=e[r],n[dX+r]=t[r];return n}const pX=PJ({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),gX=PJ({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),yX=PJ({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),mX=PJ({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),vX={alg:"A128GCM",ext:!0,k:"scm9jmO_4BJAgdwWGVulLg",key_ops:["encrypt","decrypt"],kty:"oct"};function bX(e){var t,n,r,i,o,s;const a=null!==(t=null===e||void 0===e?void 0:e.algorithm)&&void 0!==t?t:"AES-GCM";let c=null!==(n=null===e||void 0===e?void 0:e.keyLength)&&void 0!==n?n:16;const l=null!==(r=null===e||void 0===e?void 0:e.nonceLength)&&void 0!==r?r:12,u=null!==(i=null===e||void 0===e?void 0:e.digest)&&void 0!==i?i:"SHA-256",h=null!==(o=null===e||void 0===e?void 0:e.saltLength)&&void 0!==o?o:16,d=null!==(s=null===e||void 0===e?void 0:e.iterations)&&void 0!==s?s:32767,f=wJ.get();c*=8;return{encrypt:async function(e,t){const n=f.getRandomValues(new Uint8Array(h)),r=f.getRandomValues(new Uint8Array(l)),i={name:a,iv:r};let o;if("string"===typeof t&&(t=(0,yu.m)(t)),0===t.length){o=await f.subtle.importKey("jwk",vX,{name:"AES-GCM"},!0,["encrypt"]);try{const e={name:"PBKDF2",salt:n,iterations:d,hash:{name:u}},r=await f.subtle.importKey("raw",t,{name:"PBKDF2"},!1,["deriveKey"]);o=await f.subtle.deriveKey(e,r,{name:a,length:c},!0,["encrypt"])}catch{o=await f.subtle.importKey("jwk",vX,{name:"AES-GCM"},!0,["encrypt"])}}else{const e={name:"PBKDF2",salt:n,iterations:d,hash:{name:u}},r=await f.subtle.importKey("raw",t,{name:"PBKDF2"},!1,["deriveKey"]);o=await f.subtle.deriveKey(e,r,{name:a,length:c},!0,["encrypt"])}const s=await f.subtle.encrypt(i,o,e);return(0,Ls.z)([n,i.iv,new Uint8Array(s)])},decrypt:async function(e,t){const n=e.subarray(0,h),r=e.subarray(h,h+l),i=e.subarray(h+l),o={name:a,iv:r};let s;if("string"===typeof t&&(t=(0,yu.m)(t)),0===t.length)try{const e={name:"PBKDF2",salt:n,iterations:d,hash:{name:u}},r=await f.subtle.importKey("raw",t,{name:"PBKDF2"},!1,["deriveKey"]);s=await f.subtle.deriveKey(e,r,{name:a,length:c},!0,["decrypt"])}catch{s=await f.subtle.importKey("jwk",vX,{name:"AES-GCM"},!0,["decrypt"])}else{const e={name:"PBKDF2",salt:n,iterations:d,hash:{name:u}},r=await f.subtle.importKey("raw",t,{name:"PBKDF2"},!1,["deriveKey"]);s=await f.subtle.deriveKey(e,r,{name:a,length:c},!0,["decrypt"])}const p=await f.subtle.decrypt(o,s,i);return new Uint8Array(p)}}}async function wX(e,t){const n=bX(),r=await n.encrypt(e,t);return pX.encode(r)}var EX,AX,SX,_X;!function(e){e.RSA="RSA",e.Ed25519="Ed25519",e.Secp256k1="Secp256k1"}(EX||(EX={})),function(e){e[e.RSA=0]="RSA",e[e.Ed25519=1]="Ed25519",e[e.Secp256k1=2]="Secp256k1"}(AX||(AX={})),function(e){e.codec=()=>bs(AX)}(EX||(EX={})),function(e){let t;e.codec=()=>(null==t&&(t=ws((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==n.lengthDelimited&&t.fork(),null!=e.Type&&(t.uint32(8),EX.codec().encode(e.Type,t)),null!=e.Data&&(t.uint32(18),t.bytes(e.Data)),!1!==n.lengthDelimited&&t.ldelim()}),((e,t)=>{const n={},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 1:n.Type=EX.codec().decode(e);break;case 2:n.Data=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(SX||(SX={})),function(e){let t;e.codec=()=>(null==t&&(t=ws((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};!1!==n.lengthDelimited&&t.fork(),null!=e.Type&&(t.uint32(8),EX.codec().encode(e.Type,t)),null!=e.Data&&(t.uint32(18),t.bytes(e.Data)),!1!==n.lengthDelimited&&t.ldelim()}),((e,t)=>{const n={},r=null==t?e.len:e.pos+t;for(;e.pos<r;){const t=e.uint32();switch(t>>>3){case 1:n.Type=EX.codec().decode(e);break;case 2:n.Data=e.bytes();break;default:e.skipType(7&t)}}return n}))),t),e.encode=t=>fs(t,e.codec()),e.decode=t=>ds(t,e.codec())}(_X||(_X={}));class IX{constructor(e){(0,Yo.Z)(this,"_key",void 0),this._key=PX(e,uX)}async verify(e,t){return async function(e,t,n){return ql.verify(t,n,e)}(this._key,t,e)}marshal(){return this._key}get bytes(){return SX.encode({Type:EX.Ed25519,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await cX.digest(this.bytes);return e}}class CX{constructor(e,t){(0,Yo.Z)(this,"_key",void 0),(0,Yo.Z)(this,"_publicKey",void 0),this._key=PX(e,hX),this._publicKey=PX(t,uX)}async sign(e){return async function(e,t){const n=e.subarray(0,dX);return ql.sign(t,n)}(this._key,e)}get public(){return new IX(this._publicKey)}marshal(){return this._key}get bytes(){return _X.encode({Type:EX.Ed25519,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await cX.digest(this.bytes);return e}async id(){const e=iX.digest(this.public.bytes);return DJ.encode(e.bytes).substring(1)}async export(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"libp2p-key";if("libp2p-key"===t)return wX(this.bytes,e);throw new yJ("export format '".concat(t,"' is not supported"),"ERR_INVALID_EXPORT_FORMAT")}}function TX(e){if(e.length>hX){const t=(e=PX(e,hX+uX)).subarray(0,hX),n=e.subarray(hX,e.length);return new CX(t,n)}const t=(e=PX(e,hX)).subarray(0,hX),n=e.subarray(uX);return new CX(t,n)}function kX(e){return e=PX(e,uX),new IX(e)}async function RX(){const{privateKey:e,publicKey:t}=await async function(){const e=ql.utils.randomPrivateKey(),t=ql.getPublicKey(e);return{privateKey:fX(e,t),publicKey:t}}();return new CX(e,t)}async function xX(e){const{privateKey:t,publicKey:n}=await async function(e){if(e.length!==dX)throw new TypeError('"seed" must be 32 bytes in length.');if(!(e instanceof Uint8Array))throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');const t=e,n=ql.getPublicKey(t);return{privateKey:fX(t,n),publicKey:n}}(e);return new CX(t,n)}function PX(e,t){var n;if((e=Uint8Array.from(null!==(n=e)&&void 0!==n?n:[])).length!==t)throw new yJ("Key must be a Uint8Array of length ".concat(t,", got ").concat(e.length),"ERR_INVALID_KEY_TYPE");return e}function DX(e,t){let n=Uint8Array.from(e.abs().toByteArray());if(n=0===n[0]?n.subarray(1):n,null!=t){if(n.length>t)throw new Error("byte array longer than desired length");n=(0,Ls.z)([new Uint8Array(t-n.length),n])}return(0,Au.B)(n,"base64url")}function OX(e){const t=function(e,t){let n=(0,yu.m)(e,"base64urlpad");if(null!=t){if(n.length>t)throw new Error("byte array longer than desired length");n=(0,Ls.z)([new Uint8Array(t-n.length),n])}return n}(e);return new(gu().jsbn.BigInteger)((0,Au.B)(t,"base16"),16)}const NX={"P-256":256,"P-384":384,"P-521":521};Object.keys(NX).join(" / ");function BX(e){if(isNaN(e)||e<=0)throw new yJ("random bytes length must be a Number bigger than 0","ERR_INVALID_LENGTH");return _c(e)}function LX(e,t){return t.map((t=>OX(e[t])))}async function MX(e){const t=[await wJ.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["sign"]),await FX(e)],n=await UX({privateKey:t[0],publicKey:t[1]});return{privateKey:n[0],publicKey:n[1]}}async function UX(e){if(null==e.privateKey||null==e.publicKey)throw new yJ("Private and public key are required","ERR_INVALID_PARAMETERS");return Promise.all([wJ.get().subtle.exportKey("jwk",e.privateKey),wJ.get().subtle.exportKey("jwk",e.publicKey)])}async function FX(e){return wJ.get().subtle.importKey("jwk",{kty:e.kty,n:e.n,e:e.e},{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["verify"])}function KX(e,t,n,r){const i=t?function(e){return gu().pki.setRsaPublicKey(...LX(e,["n","e"]))}(e):function(e){return gu().pki.setRsaPrivateKey(...LX(e,["n","e","d","p","q","dp","dq","qi"]))}(e),o=r((0,Au.B)(Uint8Array.from(n),"ascii"),i);return(0,yu.m)(o,"ascii")}function jX(e){if("RSA"!==e.kty)throw new yJ("invalid key type","ERR_INVALID_KEY_TYPE");if(null==e.n)throw new yJ("invalid key modulus","ERR_INVALID_KEY_MODULUS");return 8*(0,yu.m)(e.n,"base64url").length}const ZX=8192;class zX{constructor(e){(0,Yo.Z)(this,"_key",void 0),this._key=e}async verify(e,t){return async function(e,t,n){const r=await wJ.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);return wJ.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},r,t,n)}(this._key,t,e)}marshal(){return function(e){if(null==e.n||null==e.e)throw new yJ("JWK was missing components","ERR_INVALID_PARAMETERS");const t=gu().pki.publicKeyToAsn1({n:OX(e.n),e:OX(e.e)});return(0,yu.m)(gu().asn1.toDer(t).getBytes(),"ascii")}(this._key)}get bytes(){return SX.encode({Type:EX.RSA,Data:this.marshal()}).subarray()}encrypt(e){return KX(this._key,!0,e,((e,t)=>t.encrypt(e)))}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await cX.digest(this.bytes);return e}}class VX{constructor(e,t){(0,Yo.Z)(this,"_key",void 0),(0,Yo.Z)(this,"_publicKey",void 0),this._key=e,this._publicKey=t}genSecret(){return BX(16)}async sign(e){return async function(e,t){const n=await wJ.get().subtle.importKey("jwk",e,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["sign"]),r=await wJ.get().subtle.sign({name:"RSASSA-PKCS1-v1_5"},n,Uint8Array.from(t));return new Uint8Array(r,0,r.byteLength)}(this._key,e)}get public(){if(null==this._publicKey)throw new yJ("public key not provided","ERR_PUBKEY_NOT_PROVIDED");return new zX(this._publicKey)}decrypt(e){return KX(this._key,!1,e,((e,t)=>t.decrypt(e)))}marshal(){return function(e){if(null==e.n||null==e.e||null==e.d||null==e.p||null==e.q||null==e.dp||null==e.dq||null==e.qi)throw new yJ("JWK was missing components","ERR_INVALID_PARAMETERS");const t=gu().pki.privateKeyToAsn1({n:OX(e.n),e:OX(e.e),d:OX(e.d),p:OX(e.p),q:OX(e.q),dP:OX(e.dp),dQ:OX(e.dq),qInv:OX(e.qi)});return(0,yu.m)(gu().asn1.toDer(t).getBytes(),"ascii")}(this._key)}get bytes(){return _X.encode({Type:EX.RSA,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await cX.digest(this.bytes);return e}async id(){const e=await this.public.hash();return(0,Au.B)(e,"base58btc")}async export(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"pkcs-8";if("pkcs-8"===t){const t=new(gu().util.ByteBuffer)(this.marshal()),n=gu().asn1.fromDer(t),r=gu().pki.privateKeyFromAsn1(n),i={algorithm:"aes256",count:1e4,saltSize:16,prfAlgorithm:"sha512"};return gu().pki.encryptRsaPrivateKey(r,e,i)}if("libp2p-key"===t)return wX(this.bytes,e);throw new yJ("export format '".concat(t,"' is not supported"),"ERR_INVALID_EXPORT_FORMAT")}}async function HX(e){const t=function(e){const t=gu().asn1.fromDer((0,Au.B)(e,"ascii")),n=gu().pki.privateKeyFromAsn1(t);return{kty:"RSA",n:DX(n.n),e:DX(n.e),d:DX(n.d),p:DX(n.p),q:DX(n.q),dp:DX(n.dP),dq:DX(n.dQ),qi:DX(n.qInv),alg:"RS256"}}(e);if(jX(t)>ZX)throw new yJ("key size is too large","ERR_KEY_SIZE_TOO_LARGE");const n=await MX(t);return new VX(n.privateKey,n.publicKey)}function qX(e){const t=function(e){const t=gu().asn1.fromDer((0,Au.B)(e,"ascii")),n=gu().pki.publicKeyFromAsn1(t);return{kty:"RSA",n:DX(n.n),e:DX(n.e)}}(e);if(jX(t)>ZX)throw new yJ("key size is too large","ERR_KEY_SIZE_TOO_LARGE");return new zX(t)}async function GX(e){if(jX(e)>ZX)throw new yJ("key size is too large","ERR_KEY_SIZE_TOO_LARGE");const t=await MX(e);return new VX(t.privateKey,t.publicKey)}async function WX(e){if(e>ZX)throw new yJ("key size is too large","ERR_KEY_SIZE_TOO_LARGE");const t=await async function(e){const t=await wJ.get().subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:e,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),n=await UX(t);return{privateKey:n[0],publicKey:n[1]}}(e);return new VX(t.privateKey,t.publicKey)}function QX(e){try{Eh.ProjectivePoint.fromHex(e)}catch(t){throw new yJ(String(t),"ERR_INVALID_PUBLIC_KEY")}}class YX{constructor(e){(0,Yo.Z)(this,"_key",void 0),QX(e),this._key=e}async verify(e,t){return async function(e,t,n){try{const{digest:r}=await cX.digest(n);return Eh.verify(t,r,e)}catch(r){throw new yJ(String(r),"ERR_INVALID_INPUT")}}(this._key,t,e)}marshal(){return e=this._key,Eh.ProjectivePoint.fromHex(e).toRawBytes(!0);var e}get bytes(){return SX.encode({Type:EX.Secp256k1,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await cX.digest(this.bytes);return e}}class JX{constructor(e,t){(0,Yo.Z)(this,"_key",void 0),(0,Yo.Z)(this,"_publicKey",void 0),this._key=e,this._publicKey=null!==t&&void 0!==t?t:function(e){try{return Eh.getPublicKey(e,!0)}catch(t){throw new yJ(String(t),"ERR_INVALID_PRIVATE_KEY")}}(e),function(e){try{Eh.getPublicKey(e,!0)}catch(t){throw new yJ(String(t),"ERR_INVALID_PRIVATE_KEY")}}(this._key),QX(this._publicKey)}async sign(e){return async function(e,t){const{digest:n}=await cX.digest(t);try{return Eh.sign(n,e).toDERRawBytes()}catch(r){throw new yJ(String(r),"ERR_INVALID_INPUT")}}(this._key,e)}get public(){return new YX(this._publicKey)}marshal(){return this._key}get bytes(){return _X.encode({Type:EX.Secp256k1,Data:this.marshal()}).subarray()}equals(e){return(0,Ms.f)(this.bytes,e.bytes)}async hash(){const{bytes:e}=await cX.digest(this.bytes);return e}async id(){const e=await this.public.hash();return(0,Au.B)(e,"base58btc")}async export(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"libp2p-key";if("libp2p-key"===t)return wX(this.bytes,e);throw new yJ("export format '".concat(t,"' is not supported"),"ERR_INVALID_EXPORT_FORMAT")}}function XX(e){return new JX(e)}function $X(e){return new YX(e)}async function e$(){const e=Eh.utils.randomPrivateKey();return new JX(e)}const t$={rsa:rn,ed25519:nn,secp256k1:on};function n$(e){const t=Object.keys(t$).join(" / ");return new yJ("invalid or unsupported key type ".concat(e,". Must be ").concat(t),"ERR_UNSUPPORTED_KEY_TYPE")}function r$(e){if("rsa"===(e=e.toLowerCase())||"ed25519"===e||"secp256k1"===e)return t$[e];throw n$(e)}async function i$(e){var t,n;const r=_X.decode(e),i=null!==(t=r.Data)&&void 0!==t?t:new Uint8Array;switch(r.Type){case EX.RSA:return t$.rsa.unmarshalRsaPrivateKey(i);case EX.Ed25519:return t$.ed25519.unmarshalEd25519PrivateKey(i);case EX.Secp256k1:return t$.secp256k1.unmarshalSecp256k1PrivateKey(i);default:throw n$(null!==(n=r.Type)&&void 0!==n?n:"RSA")}}async function o$(e,t){try{const n=await async function(e,t){const n=pX.decode(e);return bX().decrypt(n,t)}(e,t);return await i$(n)}catch(i){}const n=gu().pki.decryptRsaPrivateKey(e,t);if(null===n)throw new yJ("Cannot read the key, most likely the password is wrong or not a RSA key","ERR_CANNOT_DECRYPT_PEM");let r=gu().asn1.toDer(gu().pki.privateKeyToAsn1(n));return r=(0,yu.m)(r.getBytes(),"ascii"),t$.rsa.unmarshalRsaPrivateKey(r)}var s$=n(16019),a$=n.n(s$);const c$={sha1:"sha1","sha2-256":"sha256","sha2-512":"sha512"};function l$(e,t,n,r,i){if("sha1"!==i&&"sha2-256"!==i&&"sha2-512"!==i){const e=Object.keys(c$).join(" / ");throw new yJ("Hash '".concat(i,"' is unknown or not supported. Must be ").concat(e),"ERR_UNSUPPORTED_HASH_TYPE")}const o=c$[i],s=a$()(e,t,n,r,o);return Eu().encode64(s,null)}const u$=PJ({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),h$=PJ({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),d$=PJ({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),f$=PJ({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),p$=PJ({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),g$=PJ({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),y$=PJ({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),m$=PJ({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),v$=PJ({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});function b$(e){let t=function(e){const t=()=>{};return t.enabled=!1,t.color="",t.diff=0,t.log=()=>{},t.namespace=e,t.destroy=()=>!0,t.extend=()=>t,t}("".concat(e,":trace"));return sf().enabled("".concat(e,":trace"))&&null!=sf().names.map((e=>e.toString())).find((e=>e.includes(":trace")))&&(t=sf()("".concat(e,":trace"))),Object.assign(sf()(e),{error:sf()("".concat(e,":error")),trace:t})}sf().formatters.b=e=>null==e?"undefined":DJ.baseEncode(e),sf().formatters.t=e=>null==e?"undefined":u$.baseEncode(e),sf().formatters.m=e=>null==e?"undefined":pX.baseEncode(e),sf().formatters.p=e=>null==e?"undefined":e.toString(),sf().formatters.c=e=>null==e?"undefined":e.toString(),sf().formatters.k=e=>null==e?"undefined":e.toString(),sf().formatters.a=e=>null==e?"undefined":e.toString();const w$=Symbol.for("@libp2p/peer-id");const E$=xJ({prefix:"9",name:"base10",alphabet:"0123456789"}),A$=PJ({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),S$=PJ({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),_$=PJ({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),I$=Array.from("\ud83d\ude80\ud83e\ude90\u2604\ud83d\udef0\ud83c\udf0c\ud83c\udf11\ud83c\udf12\ud83c\udf13\ud83c\udf14\ud83c\udf15\ud83c\udf16\ud83c\udf17\ud83c\udf18\ud83c\udf0d\ud83c\udf0f\ud83c\udf0e\ud83d\udc09\u2600\ud83d\udcbb\ud83d\udda5\ud83d\udcbe\ud83d\udcbf\ud83d\ude02\u2764\ud83d\ude0d\ud83e\udd23\ud83d\ude0a\ud83d\ude4f\ud83d\udc95\ud83d\ude2d\ud83d\ude18\ud83d\udc4d\ud83d\ude05\ud83d\udc4f\ud83d\ude01\ud83d\udd25\ud83e\udd70\ud83d\udc94\ud83d\udc96\ud83d\udc99\ud83d\ude22\ud83e\udd14\ud83d\ude06\ud83d\ude44\ud83d\udcaa\ud83d\ude09\u263a\ud83d\udc4c\ud83e\udd17\ud83d\udc9c\ud83d\ude14\ud83d\ude0e\ud83d\ude07\ud83c\udf39\ud83e\udd26\ud83c\udf89\ud83d\udc9e\u270c\u2728\ud83e\udd37\ud83d\ude31\ud83d\ude0c\ud83c\udf38\ud83d\ude4c\ud83d\ude0b\ud83d\udc97\ud83d\udc9a\ud83d\ude0f\ud83d\udc9b\ud83d\ude42\ud83d\udc93\ud83e\udd29\ud83d\ude04\ud83d\ude00\ud83d\udda4\ud83d\ude03\ud83d\udcaf\ud83d\ude48\ud83d\udc47\ud83c\udfb6\ud83d\ude12\ud83e\udd2d\u2763\ud83d\ude1c\ud83d\udc8b\ud83d\udc40\ud83d\ude2a\ud83d\ude11\ud83d\udca5\ud83d\ude4b\ud83d\ude1e\ud83d\ude29\ud83d\ude21\ud83e\udd2a\ud83d\udc4a\ud83e\udd73\ud83d\ude25\ud83e\udd24\ud83d\udc49\ud83d\udc83\ud83d\ude33\u270b\ud83d\ude1a\ud83d\ude1d\ud83d\ude34\ud83c\udf1f\ud83d\ude2c\ud83d\ude43\ud83c\udf40\ud83c\udf37\ud83d\ude3b\ud83d\ude13\u2b50\u2705\ud83e\udd7a\ud83c\udf08\ud83d\ude08\ud83e\udd18\ud83d\udca6\u2714\ud83d\ude23\ud83c\udfc3\ud83d\udc90\u2639\ud83c\udf8a\ud83d\udc98\ud83d\ude20\u261d\ud83d\ude15\ud83c\udf3a\ud83c\udf82\ud83c\udf3b\ud83d\ude10\ud83d\udd95\ud83d\udc9d\ud83d\ude4a\ud83d\ude39\ud83d\udde3\ud83d\udcab\ud83d\udc80\ud83d\udc51\ud83c\udfb5\ud83e\udd1e\ud83d\ude1b\ud83d\udd34\ud83d\ude24\ud83c\udf3c\ud83d\ude2b\u26bd\ud83e\udd19\u2615\ud83c\udfc6\ud83e\udd2b\ud83d\udc48\ud83d\ude2e\ud83d\ude46\ud83c\udf7b\ud83c\udf43\ud83d\udc36\ud83d\udc81\ud83d\ude32\ud83c\udf3f\ud83e\udde1\ud83c\udf81\u26a1\ud83c\udf1e\ud83c\udf88\u274c\u270a\ud83d\udc4b\ud83d\ude30\ud83e\udd28\ud83d\ude36\ud83e\udd1d\ud83d\udeb6\ud83d\udcb0\ud83c\udf53\ud83d\udca2\ud83e\udd1f\ud83d\ude41\ud83d\udea8\ud83d\udca8\ud83e\udd2c\u2708\ud83c\udf80\ud83c\udf7a\ud83e\udd13\ud83d\ude19\ud83d\udc9f\ud83c\udf31\ud83d\ude16\ud83d\udc76\ud83e\udd74\u25b6\u27a1\u2753\ud83d\udc8e\ud83d\udcb8\u2b07\ud83d\ude28\ud83c\udf1a\ud83e\udd8b\ud83d\ude37\ud83d\udd7a\u26a0\ud83d\ude45\ud83d\ude1f\ud83d\ude35\ud83d\udc4e\ud83e\udd32\ud83e\udd20\ud83e\udd27\ud83d\udccc\ud83d\udd35\ud83d\udc85\ud83e\uddd0\ud83d\udc3e\ud83c\udf52\ud83d\ude17\ud83e\udd11\ud83c\udf0a\ud83e\udd2f\ud83d\udc37\u260e\ud83d\udca7\ud83d\ude2f\ud83d\udc86\ud83d\udc46\ud83c\udfa4\ud83d\ude47\ud83c\udf51\u2744\ud83c\udf34\ud83d\udca3\ud83d\udc38\ud83d\udc8c\ud83d\udccd\ud83e\udd40\ud83e\udd22\ud83d\udc45\ud83d\udca1\ud83d\udca9\ud83d\udc50\ud83d\udcf8\ud83d\udc7b\ud83e\udd10\ud83e\udd2e\ud83c\udfbc\ud83e\udd75\ud83d\udea9\ud83c\udf4e\ud83c\udf4a\ud83d\udc7c\ud83d\udc8d\ud83d\udce3\ud83e\udd42"),C$=I$.reduce(((e,t,n)=>(e[n]=t,e)),[]),T$=I$.reduce(((e,t,n)=>(e[t.codePointAt(0)]=n,e)),[]);const k$=RJ({prefix:"\ud83d\ude80",name:"base256emoji",encode:function(e){return e.reduce(((e,t)=>e+=C$[t]),"")},decode:function(e){const t=[];for(const n of e){const e=T$[n.codePointAt(0)];if(void 0===e)throw new Error("Non-base256emoji character: ".concat(n));t.push(e)}return new Uint8Array(t)}}),R$=xJ({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),x$=xJ({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),P$=PJ({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),D$=RJ({prefix:"\0",name:"identity",encode:e=>{return t=e,(new TextDecoder).decode(t);var t},decode:e=>(e=>(new TextEncoder).encode(e))(e)}),O$=new TextEncoder,N$=new TextDecoder,B$="json",L$=512,M$=e=>O$.encode(JSON.stringify(e)),U$=e=>JSON.parse(N$.decode(e)),F$="raw",K$=85,j$=e=>SJ(e),Z$=e=>SJ(e),z$=(e,t)=>{const{bytes:n,version:r}=e;return 0===r?W$(n,H$(e),t||DJ.encoder):Q$(n,H$(e),t||u$.encoder)},V$=new WeakMap,H$=e=>{const t=V$.get(e);if(null==t){const t=new Map;return V$.set(e,t),t}return t};class q${constructor(e,t,n,r){this.code=t,this.version=e,this.multihash=n,this.bytes=r,this["/"]=r}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==Y$)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==J$)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return q$.createV0(t)}default:throw Error("Can not convert CID version ".concat(this.version," to version 0. This is a bug please report"))}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,n=eX(e,t);return q$.createV1(this.code,n)}case 1:return this;default:throw Error("Can not convert CID version ".concat(this.version," to version 1. This is a bug please report"))}}equals(e){return q$.equals(this,e)}static equals(e,t){const n=t;return n&&e.code===n.code&&e.version===n.version&&((e,t)=>{if(e===t)return!0;{const n=t;return e.code===n.code&&e.size===n.size&&n.bytes instanceof Uint8Array&&((e,t)=>{if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;for(let n=0;n<e.byteLength;n++)if(e[n]!==t[n])return!1;return!0})(e.bytes,n.bytes)}})(e.multihash,n.multihash)}toString(e){return z$(this,e)}toJSON(){return{"/":z$(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return"CID(".concat(this.toString(),")")}static asCID(e){if(null==e)return null;const t=e;if(t instanceof q$)return t;if(null!=t["/"]&&t["/"]===t.bytes||t.asCID===t){const{version:e,code:n,multihash:r,bytes:i}=t;return new q$(e,n,r,i||X$(e,n,r.bytes))}if(!0===t[$$]){const{version:e,multihash:n,code:r}=t,i=tX(n);return q$.create(e,r,i)}return null}static create(e,t,n){if("number"!==typeof t)throw new Error("String codecs are no longer supported");if(!(n.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:if(t!==Y$)throw new Error("Version 0 CID must use dag-pb (code: ".concat(Y$,") block encoding"));return new q$(e,t,n,n.bytes);case 1:{const r=X$(e,t,n.bytes);return new q$(e,t,n,r)}default:throw new Error("Invalid version")}}static createV0(e){return q$.create(0,Y$,e)}static createV1(e,t){return q$.create(1,e,t)}static decode(e){const[t,n]=q$.decodeFirst(e);if(n.length)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=q$.inspectBytes(e),n=t.size-t.multihashSize,r=SJ(e.subarray(n,n+t.multihashSize));if(r.byteLength!==t.multihashSize)throw new Error("Incorrect length");const i=r.subarray(t.multihashSize-t.digestSize),o=new nX(t.multihashCode,t.digestSize,i,r);return[0===t.version?q$.createV0(o):q$.createV1(t.codec,o),e.subarray(t.size)]}static inspectBytes(e){let t=0;const n=()=>{const[n,r]=JJ(e.subarray(t));return t+=r,n};let r=n(),i=Y$;if(18===r?(r=0,t=0):i=n(),0!==r&&1!==r)throw new RangeError("Invalid CID version ".concat(r));const o=t,s=n(),a=n(),c=t+a;return{version:r,codec:i,multihashCode:s,digestSize:a,multihashSize:c-o,size:c}}static parse(e,t){const[n,r]=G$(e,t),i=q$.decode(r);if(0===i.version&&"Q"!==e[0])throw Error("Version 0 CID string must not include multibase prefix");return H$(i).set(n,e),i}}const G$=(e,t)=>{switch(e[0]){case"Q":{const n=t||DJ;return[DJ.prefix,n.decode("".concat(DJ.prefix).concat(e))]}case DJ.prefix:{const n=t||DJ;return[DJ.prefix,n.decode(e)]}case u$.prefix:{const n=t||u$;return[u$.prefix,n.decode(e)]}default:if(null==t)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[e[0],t.decode(e)]}},W$=(e,t,n)=>{const{prefix:r}=n;if(r!==DJ.prefix)throw Error("Cannot string encode V0 in ".concat(n.name," encoding"));const i=t.get(r);if(null==i){const i=n.encode(e).slice(1);return t.set(r,i),i}return i},Q$=(e,t,n)=>{const{prefix:r}=n,i=t.get(r);if(null==i){const i=n.encode(e);return t.set(r,i),i}return i},Y$=112,J$=18,X$=(e,t,n)=>{const r=$J(e),i=r+$J(t),o=new Uint8Array(i+n.byteLength);return XJ(e,o,0),XJ(t,o,r),o.set(n,i),o},$$=Symbol.for("@ipld/js-cid/CID"),e0={...fn,...ln,...dn,...an,...cn,...sn,...hn,...Xt,...tn,...un},t0=Symbol.for("nodejs.util.inspect.custom"),n0=Object.values(e0).map((e=>e.decoder)).reduce(((e,t)=>e.or(t)),e0.identity.decoder),r0=114,i0=36,o0=37;class s0{constructor(e){(0,Yo.Z)(this,"type",void 0),(0,Yo.Z)(this,"multihash",void 0),(0,Yo.Z)(this,"privateKey",void 0),(0,Yo.Z)(this,"publicKey",void 0),(0,Yo.Z)(this,"string",void 0),(0,Yo.Z)(this,w$,!0),this.type=e.type,this.multihash=e.multihash,this.privateKey=e.privateKey,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return"PeerId(".concat(this.toString(),")")}toString(){return null==this.string&&(this.string=DJ.encode(this.multihash.bytes).slice(1)),this.string}toCID(){return q$.createV1(r0,this.multihash)}toBytes(){return this.multihash.bytes}toJSON(){return this.toString()}equals(e){var t;if(e instanceof Uint8Array)return(0,Ms.f)(this.multihash.bytes,e);if("string"===typeof e)return function(e,t){var n;if(t=null!==(n=t)&&void 0!==n?n:n0,"1"===e.charAt(0)||"Q"===e.charAt(0)){const t=tX(DJ.decode("z".concat(e)));return e.startsWith("12D")?new c0({multihash:t}):e.startsWith("16U")?new l0({multihash:t}):new a0({multihash:t})}return function(e){try{const t=tX(e);if(t.code===iX.code){if(t.digest.length===i0)return new c0({multihash:t});if(t.digest.length===o0)return new l0({multihash:t})}if(t.code===cX.code)return new a0({multihash:t})}catch{return function(e){if(null==e||null==e.multihash||null==e.version||1===e.version&&e.code!==r0)throw new Error("Supplied PeerID CID is invalid");const t=e.multihash;if(t.code===cX.code)return new a0({multihash:e.multihash});if(t.code===iX.code){if(t.digest.length===i0)return new c0({multihash:e.multihash});if(t.digest.length===o0)return new l0({multihash:e.multihash})}throw new Error("Supplied PeerID CID is invalid")}(q$.decode(e))}throw new Error("Supplied PeerID CID is invalid")}(n0.decode(e))}(e).equals(this);if(null!=(null===e||void 0===e||null===(t=e.multihash)||void 0===t?void 0:t.bytes))return(0,Ms.f)(this.multihash.bytes,e.multihash.bytes);throw new Error("not valid Id")}[t0](){return"PeerId(".concat(this.toString(),")")}}class a0 extends s0{constructor(e){super({...e,type:"RSA"}),(0,Yo.Z)(this,"type","RSA"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.publicKey}}class c0 extends s0{constructor(e){super({...e,type:"Ed25519"}),(0,Yo.Z)(this,"type","Ed25519"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.multihash.digest}}class l0 extends s0{constructor(e){super({...e,type:"secp256k1"}),(0,Yo.Z)(this,"type","secp256k1"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.multihash.digest}}const u0="/",h0=(new TextEncoder).encode(u0),d0=h0[0];class f0{constructor(e,t){if((0,Yo.Z)(this,"_buf",void 0),"string"===typeof e)this._buf=(0,yu.m)(e);else{if(!(e instanceof Uint8Array))throw new Error("Invalid key, should be String of Uint8Array");this._buf=e}if(null==t&&(t=!0),t&&this.clean(),0===this._buf.byteLength||this._buf[0]!==d0)throw new Error("Invalid key")}toString(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"utf8";return(0,Au.B)(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return"Key(".concat(this.toString(),")")}static withNamespaces(e){return new f0(e.join(u0))}static random(){return new f0(function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:21;return crypto.getRandomValues(new Uint8Array(e)).reduce(((e,t)=>e+((t&=63)<36?t.toString(36):t<62?(t-26).toString(36).toUpperCase():t>62?"-":"_")),"")}().replace(/-/g,""))}static asKey(e){return e instanceof Uint8Array||"string"===typeof e?new f0(e):"function"===typeof e.uint8Array?new f0(e.uint8Array()):null}clean(){if(null!=this._buf&&0!==this._buf.byteLength||(this._buf=h0),this._buf[0]!==d0){const e=new Uint8Array(this._buf.byteLength+1);e.fill(d0,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===d0;)this._buf=this._buf.subarray(0,-1)}less(e){const t=this.list(),n=e.list();for(let r=0;r<t.length;r++){if(n.length<r+1)return!1;const e=t[r],i=n[r];if(e<i)return!0;if(e>i)return!1}return t.length<n.length}reverse(){return f0.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(u0).slice(1)}type(){return function(e){const t=e.split(":");if(t.length<2)return"";return t.slice(0,-1).join(":")}(this.baseNamespace())}name(){return function(e){const t=e.split(":");return t[t.length-1]}(this.baseNamespace())}instance(e){return new f0(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(u0)||(e+=u0),e+=this.type(),new f0(e)}parent(){const e=this.list();return 1===e.length?new f0(u0):new f0(e.slice(0,-1).join(u0))}child(e){return this.toString()===u0?e:e.toString()===u0?this:new f0(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()!==this.toString()&&e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()!==this.toString()&&this.toString().startsWith(e.toString())}isTopLevel(){return 1===this.list().length}concat(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return f0.withNamespaces([...this.namespaces(),...(r=t.map((e=>e.namespaces())),[].concat(...r))]);var r}}var p0,g0=n(94804),y0=n(6327),m0=n.n(y0);!function(e){e.ERR_INVALID_PARAMETERS="ERR_INVALID_PARAMETERS",e.ERR_INVALID_KEY_NAME="ERR_INVALID_KEY_NAME",e.ERR_INVALID_KEY_TYPE="ERR_INVALID_KEY_TYPE",e.ERR_KEY_ALREADY_EXISTS="ERR_KEY_ALREADY_EXISTS",e.ERR_INVALID_KEY_SIZE="ERR_INVALID_KEY_SIZE",e.ERR_KEY_NOT_FOUND="ERR_KEY_NOT_FOUND",e.ERR_OLD_KEY_NAME_INVALID="ERR_OLD_KEY_NAME_INVALID",e.ERR_NEW_KEY_NAME_INVALID="ERR_NEW_KEY_NAME_INVALID",e.ERR_PASSWORD_REQUIRED="ERR_PASSWORD_REQUIRED",e.ERR_PEM_REQUIRED="ERR_PEM_REQUIRED",e.ERR_CANNOT_READ_KEY="ERR_CANNOT_READ_KEY",e.ERR_MISSING_PRIVATE_KEY="ERR_MISSING_PRIVATE_KEY",e.ERR_INVALID_OLD_PASS_TYPE="ERR_INVALID_OLD_PASS_TYPE",e.ERR_INVALID_NEW_PASS_TYPE="ERR_INVALID_NEW_PASS_TYPE",e.ERR_INVALID_PASS_LENGTH="ERR_INVALID_PASS_LENGTH"}(p0||(p0={}));const v0=b$("libp2p:keychain"),b0="/info/",w0=new WeakMap,E0=14,A0=16,S0=1e3,_0={dek:{keyLength:64,iterationCount:1e4,salt:"you should override this value with a crypto secure random number",hash:"sha2-512"}};function I0(e){return null!=e&&("string"===typeof e&&(e===m0()(e.trim())&&e.length>0))}async function C0(){const e=800*Math.random()+200;await new Promise((t=>setTimeout(t,e)))}function T0(e){return new f0("/pkcs8/"+e)}function k0(e){return new f0(b0+e)}class R0{constructor(e,t){var n,r,i,o,s,a,c,l,u,h;if((0,Yo.Z)(this,"components",void 0),(0,Yo.Z)(this,"init",void 0),this.components=e,this.init=(0,g0.Z)(_0,t),null!=this.init.pass&&(null===(n=this.init.pass)||void 0===n?void 0:n.length)<20)throw new Error("pass must be least 20 characters");if(null!=(null===(r=this.init.dek)||void 0===r?void 0:r.keyLength)&&this.init.dek.keyLength<E0)throw new Error("dek.keyLength must be least ".concat(E0," bytes"));if(null!=(null===(i=this.init.dek)||void 0===i||null===(o=i.salt)||void 0===o?void 0:o.length)&&this.init.dek.salt.length<A0)throw new Error("dek.saltLength must be least ".concat(A0," bytes"));if(null!=(null===(s=this.init.dek)||void 0===s?void 0:s.iterationCount)&&this.init.dek.iterationCount<S0)throw new Error("dek.iterationCount must be least ".concat(S0));const d=null!=this.init.pass&&null!=(null===(a=this.init.dek)||void 0===a?void 0:a.salt)?l$(this.init.pass,null===(c=this.init.dek)||void 0===c?void 0:c.salt,null===(l=this.init.dek)||void 0===l?void 0:l.iterationCount,null===(u=this.init.dek)||void 0===u?void 0:u.keyLength,null===(h=this.init.dek)||void 0===h?void 0:h.hash):"";w0.set(this,{dek:d})}static generateOptions(){const e=Object.assign({},_0),t=3*Math.ceil(A0/3);return e.dek.salt=(0,Au.B)(BX(t),"base64"),e}static get options(){return _0}async createKey(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:2048;if(!I0(e)||"self"===e)throw await C0(),new yJ("Invalid key name",p0.ERR_INVALID_KEY_NAME);if("string"!==typeof t)throw await C0(),new yJ("Invalid key type",p0.ERR_INVALID_KEY_TYPE);const r=T0(e);if(await this.components.datastore.has(r))throw await C0(),new yJ("Key name already exists",p0.ERR_KEY_ALREADY_EXISTS);if("rsa"===t.toLowerCase())if(!Number.isSafeInteger(n)||n<2048)throw await C0(),new yJ("Invalid RSA key size",p0.ERR_INVALID_KEY_SIZE);let i;try{const o=await async function(e,t){return r$(e).generateKeyPair(null!==t&&void 0!==t?t:2048)}(t,n),s=await o.id(),a=w0.get(this);if(null==a)throw new yJ("dek missing",p0.ERR_INVALID_PARAMETERS);const c=a.dek,l=await o.export(c);i={name:e,id:s};const u=this.components.datastore.batch();u.put(r,(0,yu.m)(l)),u.put(k0(e),(0,yu.m)(JSON.stringify(i))),await u.commit()}catch(o){throw await C0(),o}return i}async listKeys(){const e={prefix:b0},t=[];for await(const n of this.components.datastore.query(e))t.push(JSON.parse((0,Au.B)(n.value)));return t}async findKeyById(e){try{const t=(await this.listKeys()).find((t=>t.id===e));if(null==t)throw new yJ("Key with id '".concat(e,"' does not exist."),p0.ERR_KEY_NOT_FOUND);return t}catch(t){throw await C0(),t}}async findKeyByName(e){if(!I0(e))throw await C0(),new yJ("Invalid key name '".concat(e,"'"),p0.ERR_INVALID_KEY_NAME);const t=k0(e);try{const e=await this.components.datastore.get(t);return JSON.parse((0,Au.B)(e))}catch(n){throw await C0(),v0.error(n),new yJ("Key '".concat(e,"' does not exist."),p0.ERR_KEY_NOT_FOUND)}}async removeKey(e){if(!I0(e)||"self"===e)throw await C0(),new yJ("Invalid key name '".concat(e,"'"),p0.ERR_INVALID_KEY_NAME);const t=T0(e),n=await this.findKeyByName(e),r=this.components.datastore.batch();return r.delete(t),r.delete(k0(e)),await r.commit(),n}async renameKey(e,t){if(!I0(e)||"self"===e)throw await C0(),new yJ("Invalid old key name '".concat(e,"'"),p0.ERR_OLD_KEY_NAME_INVALID);if(!I0(t)||"self"===t)throw await C0(),new yJ("Invalid new key name '".concat(t,"'"),p0.ERR_NEW_KEY_NAME_INVALID);const n=T0(e),r=T0(t),i=k0(e),o=k0(t);if(await this.components.datastore.has(r))throw await C0(),new yJ("Key '".concat(t,"' already exists"),p0.ERR_KEY_ALREADY_EXISTS);try{const e=await this.components.datastore.get(n),s=await this.components.datastore.get(i),a=JSON.parse((0,Au.B)(s));a.name=t;const c=this.components.datastore.batch();return c.put(r,e),c.put(o,(0,yu.m)(JSON.stringify(a))),c.delete(n),c.delete(i),await c.commit(),a}catch(s){throw await C0(),s}}async exportKey(e,t){if(!I0(e))throw await C0(),new yJ("Invalid key name '".concat(e,"'"),p0.ERR_INVALID_KEY_NAME);if(null==t)throw await C0(),new yJ("Password is required",p0.ERR_PASSWORD_REQUIRED);const n=T0(e);try{const e=await this.components.datastore.get(n),r=(0,Au.B)(e),i=w0.get(this);if(null==i)throw new yJ("dek missing",p0.ERR_INVALID_PARAMETERS);const o=i.dek,s=await o$(r,o);return await s.export(t)}catch(r){throw await C0(),r}}async exportPeerId(e){const t="temporary-password",n=await this.exportKey(e,t),r=await o$(n,t);return async function(e,t){return e.length===i0?new c0({multihash:eX(iX.code,e),privateKey:t}):e.length===o0?new l0({multihash:eX(iX.code,e),privateKey:t}):new a0({multihash:await cX.digest(e),publicKey:e,privateKey:t})}(r.public.bytes,r.bytes)}async importKey(e,t,n){if(!I0(e)||"self"===e)throw await C0(),new yJ("Invalid key name '".concat(e,"'"),p0.ERR_INVALID_KEY_NAME);if(null==t)throw await C0(),new yJ("PEM encoded key is required",p0.ERR_PEM_REQUIRED);const r=T0(e);if(await this.components.datastore.has(r))throw await C0(),new yJ("Key '".concat(e,"' already exists"),p0.ERR_KEY_ALREADY_EXISTS);let i,o;try{i=await o$(t,n)}catch(c){throw await C0(),new yJ("Cannot read the key, most likely the password is wrong",p0.ERR_CANNOT_READ_KEY)}try{o=await i.id();const e=w0.get(this);if(null==e)throw new yJ("dek missing",p0.ERR_INVALID_PARAMETERS);const n=e.dek;t=await i.export(n)}catch(c){throw await C0(),c}const s={name:e,id:o},a=this.components.datastore.batch();return a.put(r,(0,yu.m)(t)),a.put(k0(e),(0,yu.m)(JSON.stringify(s))),await a.commit(),s}async importPeer(e,t){try{if(!I0(e))throw new yJ("Invalid key name '".concat(e,"'"),p0.ERR_INVALID_KEY_NAME);if(null==t)throw new yJ("PeerId is required",p0.ERR_MISSING_PRIVATE_KEY);if(null==t.privateKey)throw new yJ("PeerId.privKey is required",p0.ERR_MISSING_PRIVATE_KEY);const n=await i$(t.privateKey),r=T0(e);if(await this.components.datastore.has(r))throw await C0(),new yJ("Key '".concat(e,"' already exists"),p0.ERR_KEY_ALREADY_EXISTS);const i=w0.get(this);if(null==i)throw new yJ("dek missing",p0.ERR_INVALID_PARAMETERS);const o=i.dek,s=await n.export(o),a={name:e,id:t.toString()},c=this.components.datastore.batch();return c.put(r,(0,yu.m)(s)),c.put(k0(e),(0,yu.m)(JSON.stringify(a))),await c.commit(),a}catch(n){throw await C0(),n}}async getPrivateKey(e){if(!I0(e))throw await C0(),new yJ("Invalid key name '".concat(e,"'"),p0.ERR_INVALID_KEY_NAME);try{const t=T0(e),n=await this.components.datastore.get(t);return(0,Au.B)(n)}catch(t){throw await C0(),v0.error(t),new yJ("Key '".concat(e,"' does not exist."),p0.ERR_KEY_NOT_FOUND)}}async rotateKeychainPass(e,t){var n,r,i,o;if("string"!==typeof e)throw await C0(),new yJ("Invalid old pass type '".concat(typeof e,"'"),p0.ERR_INVALID_OLD_PASS_TYPE);if("string"!==typeof t)throw await C0(),new yJ("Invalid new pass type '".concat(typeof t,"'"),p0.ERR_INVALID_NEW_PASS_TYPE);if(t.length<20)throw await C0(),new yJ("Invalid pass length ".concat(t.length),p0.ERR_INVALID_PASS_LENGTH);v0("recreating keychain");const s=w0.get(this);if(null==s)throw new yJ("dek missing",p0.ERR_INVALID_PARAMETERS);const a=s.dek;this.init.pass=t;const c=null!=t&&null!=(null===(n=this.init.dek)||void 0===n?void 0:n.salt)?l$(t,this.init.dek.salt,null===(r=this.init.dek)||void 0===r?void 0:r.iterationCount,null===(i=this.init.dek)||void 0===i?void 0:i.keyLength,null===(o=this.init.dek)||void 0===o?void 0:o.hash):"";w0.set(this,{dek:c});const l=await this.listKeys();for(const u of l){const e=await this.components.datastore.get(T0(u.name)),t=(0,Au.B)(e),n=await o$(t,a),r=c.toString(),i=await n.export(r),o=this.components.datastore.batch(),s={name:u.name,id:u.id};o.put(T0(u.name),(0,yu.m)(i)),o.put(k0(u.name),(0,yu.m)(JSON.stringify(s))),await o.commit()}v0("keychain reconstructed")}}const x0=Symbol.for("@libp2p/peer-id");function P0(e){return null!=e&&Boolean(e[x0])}const D0=zV({prefix:"9",name:"base10",alphabet:"0123456789"}),O0=VV({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),N0=VV({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),B0=VV({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),L0=Array.from("\ud83d\ude80\ud83e\ude90\u2604\ud83d\udef0\ud83c\udf0c\ud83c\udf11\ud83c\udf12\ud83c\udf13\ud83c\udf14\ud83c\udf15\ud83c\udf16\ud83c\udf17\ud83c\udf18\ud83c\udf0d\ud83c\udf0f\ud83c\udf0e\ud83d\udc09\u2600\ud83d\udcbb\ud83d\udda5\ud83d\udcbe\ud83d\udcbf\ud83d\ude02\u2764\ud83d\ude0d\ud83e\udd23\ud83d\ude0a\ud83d\ude4f\ud83d\udc95\ud83d\ude2d\ud83d\ude18\ud83d\udc4d\ud83d\ude05\ud83d\udc4f\ud83d\ude01\ud83d\udd25\ud83e\udd70\ud83d\udc94\ud83d\udc96\ud83d\udc99\ud83d\ude22\ud83e\udd14\ud83d\ude06\ud83d\ude44\ud83d\udcaa\ud83d\ude09\u263a\ud83d\udc4c\ud83e\udd17\ud83d\udc9c\ud83d\ude14\ud83d\ude0e\ud83d\ude07\ud83c\udf39\ud83e\udd26\ud83c\udf89\ud83d\udc9e\u270c\u2728\ud83e\udd37\ud83d\ude31\ud83d\ude0c\ud83c\udf38\ud83d\ude4c\ud83d\ude0b\ud83d\udc97\ud83d\udc9a\ud83d\ude0f\ud83d\udc9b\ud83d\ude42\ud83d\udc93\ud83e\udd29\ud83d\ude04\ud83d\ude00\ud83d\udda4\ud83d\ude03\ud83d\udcaf\ud83d\ude48\ud83d\udc47\ud83c\udfb6\ud83d\ude12\ud83e\udd2d\u2763\ud83d\ude1c\ud83d\udc8b\ud83d\udc40\ud83d\ude2a\ud83d\ude11\ud83d\udca5\ud83d\ude4b\ud83d\ude1e\ud83d\ude29\ud83d\ude21\ud83e\udd2a\ud83d\udc4a\ud83e\udd73\ud83d\ude25\ud83e\udd24\ud83d\udc49\ud83d\udc83\ud83d\ude33\u270b\ud83d\ude1a\ud83d\ude1d\ud83d\ude34\ud83c\udf1f\ud83d\ude2c\ud83d\ude43\ud83c\udf40\ud83c\udf37\ud83d\ude3b\ud83d\ude13\u2b50\u2705\ud83e\udd7a\ud83c\udf08\ud83d\ude08\ud83e\udd18\ud83d\udca6\u2714\ud83d\ude23\ud83c\udfc3\ud83d\udc90\u2639\ud83c\udf8a\ud83d\udc98\ud83d\ude20\u261d\ud83d\ude15\ud83c\udf3a\ud83c\udf82\ud83c\udf3b\ud83d\ude10\ud83d\udd95\ud83d\udc9d\ud83d\ude4a\ud83d\ude39\ud83d\udde3\ud83d\udcab\ud83d\udc80\ud83d\udc51\ud83c\udfb5\ud83e\udd1e\ud83d\ude1b\ud83d\udd34\ud83d\ude24\ud83c\udf3c\ud83d\ude2b\u26bd\ud83e\udd19\u2615\ud83c\udfc6\ud83e\udd2b\ud83d\udc48\ud83d\ude2e\ud83d\ude46\ud83c\udf7b\ud83c\udf43\ud83d\udc36\ud83d\udc81\ud83d\ude32\ud83c\udf3f\ud83e\udde1\ud83c\udf81\u26a1\ud83c\udf1e\ud83c\udf88\u274c\u270a\ud83d\udc4b\ud83d\ude30\ud83e\udd28\ud83d\ude36\ud83e\udd1d\ud83d\udeb6\ud83d\udcb0\ud83c\udf53\ud83d\udca2\ud83e\udd1f\ud83d\ude41\ud83d\udea8\ud83d\udca8\ud83e\udd2c\u2708\ud83c\udf80\ud83c\udf7a\ud83e\udd13\ud83d\ude19\ud83d\udc9f\ud83c\udf31\ud83d\ude16\ud83d\udc76\ud83e\udd74\u25b6\u27a1\u2753\ud83d\udc8e\ud83d\udcb8\u2b07\ud83d\ude28\ud83c\udf1a\ud83e\udd8b\ud83d\ude37\ud83d\udd7a\u26a0\ud83d\ude45\ud83d\ude1f\ud83d\ude35\ud83d\udc4e\ud83e\udd32\ud83e\udd20\ud83e\udd27\ud83d\udccc\ud83d\udd35\ud83d\udc85\ud83e\uddd0\ud83d\udc3e\ud83c\udf52\ud83d\ude17\ud83e\udd11\ud83c\udf0a\ud83e\udd2f\ud83d\udc37\u260e\ud83d\udca7\ud83d\ude2f\ud83d\udc86\ud83d\udc46\ud83c\udfa4\ud83d\ude47\ud83c\udf51\u2744\ud83c\udf34\ud83d\udca3\ud83d\udc38\ud83d\udc8c\ud83d\udccd\ud83e\udd40\ud83e\udd22\ud83d\udc45\ud83d\udca1\ud83d\udca9\ud83d\udc50\ud83d\udcf8\ud83d\udc7b\ud83e\udd10\ud83e\udd2e\ud83c\udfbc\ud83e\udd75\ud83d\udea9\ud83c\udf4e\ud83c\udf4a\ud83d\udc7c\ud83d\udc8d\ud83d\udce3\ud83e\udd42"),M0=L0.reduce(((e,t,n)=>(e[n]=t,e)),[]),U0=L0.reduce(((e,t,n)=>(e[t.codePointAt(0)]=n,e)),[]);const F0=ZV({prefix:"\ud83d\ude80",name:"base256emoji",encode:function(e){return e.reduce(((e,t)=>e+=M0[t]),"")},decode:function(e){const t=[];for(const n of e){const e=U0[n.codePointAt(0)];if(void 0===e)throw new Error("Non-base256emoji character: ".concat(n));t.push(e)}return new Uint8Array(t)}}),K0=VV({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),j0=ZV({prefix:"\0",name:"identity",encode:e=>{return t=e,(new TextDecoder).decode(t);var t},decode:e=>(e=>(new TextEncoder).encode(e))(e)}),Z0={...En,...vn,...wn,...yn,...mn,...jt,...Ht,...Zt,...zt,...bn},z0=Symbol.for("nodejs.util.inspect.custom"),V0=Object.values(Z0).map((e=>e.decoder)).reduce(((e,t)=>e.or(t)),Z0.identity.decoder),H0=114,q0=36,G0=37;class W0{constructor(e){(0,Yo.Z)(this,"type",void 0),(0,Yo.Z)(this,"multihash",void 0),(0,Yo.Z)(this,"privateKey",void 0),(0,Yo.Z)(this,"publicKey",void 0),(0,Yo.Z)(this,"string",void 0),(0,Yo.Z)(this,x0,!0),this.type=e.type,this.multihash=e.multihash,this.privateKey=e.privateKey,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return"PeerId(".concat(this.toString(),")")}toString(){return null==this.string&&(this.string=eH.encode(this.multihash.bytes).slice(1)),this.string}toCID(){return YH.createV1(H0,this.multihash)}toBytes(){return this.multihash.bytes}toJSON(){return this.toString()}equals(e){var t;if(e instanceof Uint8Array)return(0,Ms.f)(this.multihash.bytes,e);if("string"===typeof e)return X0(e).equals(this);if(null!=(null===e||void 0===e||null===(t=e.multihash)||void 0===t?void 0:t.bytes))return(0,Ms.f)(this.multihash.bytes,e.multihash.bytes);throw new Error("not valid Id")}[z0](){return"PeerId(".concat(this.toString(),")")}}class Q0 extends W0{constructor(e){super({...e,type:"RSA"}),(0,Yo.Z)(this,"type","RSA"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.publicKey}}class Y0 extends W0{constructor(e){super({...e,type:"Ed25519"}),(0,Yo.Z)(this,"type","Ed25519"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.multihash.digest}}class J0 extends W0{constructor(e){super({...e,type:"secp256k1"}),(0,Yo.Z)(this,"type","secp256k1"),(0,Yo.Z)(this,"publicKey",void 0),this.publicKey=e.multihash.digest}}function X0(e,t){var n;if(t=null!==(n=t)&&void 0!==n?n:V0,"1"===e.charAt(0)||"Q"===e.charAt(0)){const t=HH(eH.decode("z".concat(e)));return e.startsWith("12D")?new Y0({multihash:t}):e.startsWith("16U")?new J0({multihash:t}):new Q0({multihash:t})}return $0(V0.decode(e))}function $0(e){try{const t=HH(e);if(t.code===sY.code){if(t.digest.length===q0)return new Y0({multihash:t});if(t.digest.length===G0)return new J0({multihash:t})}if(t.code===pq.code)return new Q0({multihash:t})}catch{return function(e){if(null==e||null==e.multihash||null==e.version||1===e.version&&e.code!==H0)throw new Error("Supplied PeerID CID is invalid");const t=e.multihash;if(t.code===pq.code)return new Q0({multihash:e.multihash});if(t.code===sY.code){if(t.digest.length===q0)return new Y0({multihash:e.multihash});if(t.digest.length===G0)return new J0({multihash:e.multihash})}throw new Error("Supplied PeerID CID is invalid")}(YH.decode(e))}throw new Error("Supplied PeerID CID is invalid")}async function e1(e,t){return e.length===q0?new Y0({multihash:VH(sY.code,e),privateKey:t}):e.length===G0?new J0({multihash:VH(sY.code,e),privateKey:t}):new Q0({multihash:await pq.digest(e),publicKey:e,privateKey:t})}const t1=function(e){if(null!=e[Symbol.asyncIterator])return(async()=>{const t=[];for await(const n of e)t.push(n);return t})();const t=[];for(const n of e)t.push(n);return t};var n1=function(e,t){if(e.length>=255)throw new TypeError("Alphabet too long");for(var n=new Uint8Array(256),r=0;r<n.length;r++)n[r]=255;for(var i=0;i<e.length;i++){var o=e.charAt(i),s=o.charCodeAt(0);if(255!==n[s])throw new TypeError(o+" is ambiguous");n[s]=i}var a=e.length,c=e.charAt(0),l=Math.log(a)/Math.log(256),u=Math.log(256)/Math.log(a);function h(e){if("string"!==typeof e)throw new TypeError("Expected String");if(0===e.length)return new Uint8Array;var t=0;if(" "!==e[t]){for(var r=0,i=0;e[t]===c;)r++,t++;for(var o=(e.length-t)*l+1>>>0,s=new Uint8Array(o);e[t];){var u=n[e.charCodeAt(t)];if(255===u)return;for(var h=0,d=o-1;(0!==u||h<i)&&-1!==d;d--,h++)u